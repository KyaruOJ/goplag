// Code generated from SysVerilogHDL.g4 by ANTLR 4.8. DO NOT EDIT.

package parser // SysVerilogHDL

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 234, 3132,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 4, 177, 9, 177, 4, 178, 9, 178,
	4, 179, 9, 179, 4, 180, 9, 180, 4, 181, 9, 181, 4, 182, 9, 182, 4, 183,
	9, 183, 4, 184, 9, 184, 4, 185, 9, 185, 4, 186, 9, 186, 4, 187, 9, 187,
	4, 188, 9, 188, 4, 189, 9, 189, 4, 190, 9, 190, 4, 191, 9, 191, 4, 192,
	9, 192, 4, 193, 9, 193, 4, 194, 9, 194, 4, 195, 9, 195, 4, 196, 9, 196,
	4, 197, 9, 197, 4, 198, 9, 198, 4, 199, 9, 199, 4, 200, 9, 200, 4, 201,
	9, 201, 4, 202, 9, 202, 4, 203, 9, 203, 4, 204, 9, 204, 4, 205, 9, 205,
	4, 206, 9, 206, 4, 207, 9, 207, 4, 208, 9, 208, 4, 209, 9, 209, 4, 210,
	9, 210, 4, 211, 9, 211, 4, 212, 9, 212, 4, 213, 9, 213, 4, 214, 9, 214,
	4, 215, 9, 215, 4, 216, 9, 216, 4, 217, 9, 217, 4, 218, 9, 218, 4, 219,
	9, 219, 4, 220, 9, 220, 4, 221, 9, 221, 4, 222, 9, 222, 4, 223, 9, 223,
	4, 224, 9, 224, 4, 225, 9, 225, 4, 226, 9, 226, 4, 227, 9, 227, 4, 228,
	9, 228, 4, 229, 9, 229, 4, 230, 9, 230, 4, 231, 9, 231, 4, 232, 9, 232,
	4, 233, 9, 233, 4, 234, 9, 234, 4, 235, 9, 235, 4, 236, 9, 236, 4, 237,
	9, 237, 4, 238, 9, 238, 4, 239, 9, 239, 4, 240, 9, 240, 4, 241, 9, 241,
	4, 242, 9, 242, 4, 243, 9, 243, 4, 244, 9, 244, 4, 245, 9, 245, 4, 246,
	9, 246, 4, 247, 9, 247, 4, 248, 9, 248, 4, 249, 9, 249, 4, 250, 9, 250,
	4, 251, 9, 251, 4, 252, 9, 252, 4, 253, 9, 253, 4, 254, 9, 254, 4, 255,
	9, 255, 4, 256, 9, 256, 4, 257, 9, 257, 4, 258, 9, 258, 4, 259, 9, 259,
	4, 260, 9, 260, 4, 261, 9, 261, 4, 262, 9, 262, 4, 263, 9, 263, 4, 264,
	9, 264, 4, 265, 9, 265, 4, 266, 9, 266, 4, 267, 9, 267, 4, 268, 9, 268,
	4, 269, 9, 269, 4, 270, 9, 270, 4, 271, 9, 271, 4, 272, 9, 272, 4, 273,
	9, 273, 4, 274, 9, 274, 4, 275, 9, 275, 4, 276, 9, 276, 4, 277, 9, 277,
	4, 278, 9, 278, 4, 279, 9, 279, 4, 280, 9, 280, 4, 281, 9, 281, 4, 282,
	9, 282, 4, 283, 9, 283, 4, 284, 9, 284, 4, 285, 9, 285, 4, 286, 9, 286,
	4, 287, 9, 287, 4, 288, 9, 288, 4, 289, 9, 289, 4, 290, 9, 290, 4, 291,
	9, 291, 4, 292, 9, 292, 4, 293, 9, 293, 4, 294, 9, 294, 4, 295, 9, 295,
	4, 296, 9, 296, 4, 297, 9, 297, 4, 298, 9, 298, 4, 299, 9, 299, 4, 300,
	9, 300, 4, 301, 9, 301, 4, 302, 9, 302, 4, 303, 9, 303, 4, 304, 9, 304,
	4, 305, 9, 305, 4, 306, 9, 306, 4, 307, 9, 307, 4, 308, 9, 308, 4, 309,
	9, 309, 4, 310, 9, 310, 4, 311, 9, 311, 4, 312, 9, 312, 4, 313, 9, 313,
	4, 314, 9, 314, 4, 315, 9, 315, 4, 316, 9, 316, 4, 317, 9, 317, 4, 318,
	9, 318, 4, 319, 9, 319, 4, 320, 9, 320, 4, 321, 9, 321, 4, 322, 9, 322,
	4, 323, 9, 323, 4, 324, 9, 324, 4, 325, 9, 325, 4, 326, 9, 326, 4, 327,
	9, 327, 4, 328, 9, 328, 4, 329, 9, 329, 4, 330, 9, 330, 4, 331, 9, 331,
	4, 332, 9, 332, 4, 333, 9, 333, 4, 334, 9, 334, 4, 335, 9, 335, 4, 336,
	9, 336, 4, 337, 9, 337, 4, 338, 9, 338, 4, 339, 9, 339, 4, 340, 9, 340,
	4, 341, 9, 341, 4, 342, 9, 342, 4, 343, 9, 343, 4, 344, 9, 344, 4, 345,
	9, 345, 4, 346, 9, 346, 4, 347, 9, 347, 4, 348, 9, 348, 4, 349, 9, 349,
	4, 350, 9, 350, 4, 351, 9, 351, 4, 352, 9, 352, 4, 353, 9, 353, 4, 354,
	9, 354, 4, 355, 9, 355, 4, 356, 9, 356, 4, 357, 9, 357, 4, 358, 9, 358,
	4, 359, 9, 359, 4, 360, 9, 360, 4, 361, 9, 361, 4, 362, 9, 362, 4, 363,
	9, 363, 4, 364, 9, 364, 4, 365, 9, 365, 4, 366, 9, 366, 4, 367, 9, 367,
	4, 368, 9, 368, 4, 369, 9, 369, 4, 370, 9, 370, 4, 371, 9, 371, 4, 372,
	9, 372, 4, 373, 9, 373, 4, 374, 9, 374, 4, 375, 9, 375, 4, 376, 9, 376,
	4, 377, 9, 377, 4, 378, 9, 378, 4, 379, 9, 379, 4, 380, 9, 380, 4, 381,
	9, 381, 4, 382, 9, 382, 4, 383, 9, 383, 4, 384, 9, 384, 4, 385, 9, 385,
	4, 386, 9, 386, 4, 387, 9, 387, 4, 388, 9, 388, 4, 389, 9, 389, 4, 390,
	9, 390, 4, 391, 9, 391, 4, 392, 9, 392, 4, 393, 9, 393, 4, 394, 9, 394,
	4, 395, 9, 395, 4, 396, 9, 396, 4, 397, 9, 397, 4, 398, 9, 398, 4, 399,
	9, 399, 4, 400, 9, 400, 4, 401, 9, 401, 4, 402, 9, 402, 4, 403, 9, 403,
	4, 404, 9, 404, 4, 405, 9, 405, 4, 406, 9, 406, 4, 407, 9, 407, 4, 408,
	9, 408, 4, 409, 9, 409, 4, 410, 9, 410, 4, 411, 9, 411, 4, 412, 9, 412,
	4, 413, 9, 413, 4, 414, 9, 414, 4, 415, 9, 415, 4, 416, 9, 416, 4, 417,
	9, 417, 4, 418, 9, 418, 4, 419, 9, 419, 4, 420, 9, 420, 4, 421, 9, 421,
	4, 422, 9, 422, 4, 423, 9, 423, 4, 424, 9, 424, 4, 425, 9, 425, 4, 426,
	9, 426, 4, 427, 9, 427, 4, 428, 9, 428, 4, 429, 9, 429, 4, 430, 9, 430,
	4, 431, 9, 431, 4, 432, 9, 432, 4, 433, 9, 433, 4, 434, 9, 434, 4, 435,
	9, 435, 4, 436, 9, 436, 4, 437, 9, 437, 4, 438, 9, 438, 4, 439, 9, 439,
	4, 440, 9, 440, 4, 441, 9, 441, 4, 442, 9, 442, 4, 443, 9, 443, 4, 444,
	9, 444, 4, 445, 9, 445, 4, 446, 9, 446, 3, 2, 3, 2, 3, 3, 3, 3, 3, 4, 3,
	4, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 903, 10, 5, 3, 6, 3, 6, 3, 7, 3, 7, 3,
	8, 3, 8, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 3, 11, 7, 11, 917, 10, 11, 12,
	11, 14, 11, 920, 11, 11, 3, 12, 3, 12, 3, 12, 5, 12, 925, 10, 12, 3, 13,
	3, 13, 3, 14, 3, 14, 5, 14, 931, 10, 14, 3, 15, 3, 15, 3, 15, 5, 15, 936,
	10, 15, 3, 15, 3, 15, 5, 15, 940, 10, 15, 3, 15, 3, 15, 5, 15, 944, 10,
	15, 3, 15, 3, 15, 5, 15, 948, 10, 15, 3, 15, 3, 15, 5, 15, 952, 10, 15,
	5, 15, 954, 10, 15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
	16, 5, 16, 964, 10, 16, 3, 17, 3, 17, 3, 18, 5, 18, 969, 10, 18, 3, 18,
	5, 18, 972, 10, 18, 3, 19, 3, 19, 3, 19, 5, 19, 977, 10, 19, 3, 19, 3,
	19, 3, 20, 3, 20, 5, 20, 983, 10, 20, 3, 20, 3, 20, 3, 21, 7, 21, 988,
	10, 21, 12, 21, 14, 21, 991, 11, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 1003, 10, 22, 3, 23, 3, 23, 3,
	23, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 1015, 10, 24,
	3, 25, 3, 25, 3, 26, 3, 26, 3, 26, 3, 27, 7, 27, 1023, 10, 27, 12, 27,
	14, 27, 1026, 11, 27, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28,
	5, 28, 1035, 10, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3,
	29, 3, 29, 3, 29, 3, 29, 3, 29, 5, 29, 1049, 10, 29, 3, 30, 3, 30, 3, 31,
	3, 31, 3, 31, 3, 32, 3, 32, 3, 32, 5, 32, 1059, 10, 32, 3, 33, 3, 33, 3,
	33, 3, 33, 3, 34, 3, 34, 3, 34, 3, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5,
	35, 1084, 10, 35, 3, 36, 3, 36, 5, 36, 1088, 10, 36, 3, 37, 3, 37, 5, 37,
	1092, 10, 37, 3, 38, 3, 38, 3, 38, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 1101,
	10, 39, 3, 40, 3, 40, 3, 40, 3, 41, 3, 41, 5, 41, 1108, 10, 41, 3, 42,
	3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 1117, 10, 42, 3, 43, 3,
	43, 3, 43, 3, 43, 5, 43, 1123, 10, 43, 3, 44, 3, 44, 3, 45, 3, 45, 5, 45,
	1129, 10, 45, 3, 46, 3, 46, 3, 46, 3, 47, 7, 47, 1135, 10, 47, 12, 47,
	14, 47, 1138, 11, 47, 3, 48, 3, 48, 3, 48, 3, 49, 3, 49, 3, 50, 5, 50,
	1146, 10, 50, 3, 50, 5, 50, 1149, 10, 50, 3, 50, 3, 50, 3, 51, 3, 51, 3,
	51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 5, 51, 1162, 10, 51, 3, 52,
	3, 52, 3, 52, 3, 53, 3, 53, 3, 53, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55, 5,
	55, 1175, 10, 55, 3, 56, 3, 56, 5, 56, 1179, 10, 56, 3, 57, 3, 57, 3, 57,
	3, 58, 7, 58, 1185, 10, 58, 12, 58, 14, 58, 1188, 11, 58, 3, 59, 3, 59,
	3, 59, 3, 60, 3, 60, 3, 61, 6, 61, 1196, 10, 61, 13, 61, 14, 61, 1197,
	3, 62, 7, 62, 1201, 10, 62, 12, 62, 14, 62, 1204, 11, 62, 3, 63, 3, 63,
	3, 63, 3, 64, 3, 64, 3, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 5, 65, 1217,
	10, 65, 3, 66, 3, 66, 5, 66, 1221, 10, 66, 3, 67, 3, 67, 3, 67, 5, 67,
	1226, 10, 67, 3, 68, 7, 68, 1229, 10, 68, 12, 68, 14, 68, 1232, 11, 68,
	3, 69, 3, 69, 3, 69, 3, 70, 3, 70, 3, 71, 3, 71, 5, 71, 1241, 10, 71, 3,
	72, 3, 72, 3, 72, 3, 73, 7, 73, 1247, 10, 73, 12, 73, 14, 73, 1250, 11,
	73, 3, 74, 3, 74, 3, 74, 3, 75, 3, 75, 3, 76, 6, 76, 1258, 10, 76, 13,
	76, 14, 76, 1259, 3, 77, 7, 77, 1263, 10, 77, 12, 77, 14, 77, 1266, 11,
	77, 3, 78, 3, 78, 3, 78, 3, 79, 3, 79, 3, 79, 3, 80, 3, 80, 3, 80, 3, 80,
	5, 80, 1278, 10, 80, 3, 81, 5, 81, 1281, 10, 81, 3, 81, 5, 81, 1284, 10,
	81, 3, 81, 3, 81, 3, 82, 3, 82, 5, 82, 1290, 10, 82, 3, 83, 3, 83, 3, 83,
	3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 5, 83, 1303, 10,
	83, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 5, 84, 1313,
	10, 84, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 5, 85,
	1323, 10, 85, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3,
	86, 3, 86, 3, 86, 5, 86, 1336, 10, 86, 3, 87, 3, 87, 3, 87, 3, 88, 3, 88,
	3, 88, 3, 89, 3, 89, 3, 89, 3, 90, 3, 90, 3, 90, 3, 91, 3, 91, 3, 92, 3,
	92, 3, 93, 6, 93, 1355, 10, 93, 13, 93, 14, 93, 1356, 3, 94, 7, 94, 1360,
	10, 94, 12, 94, 14, 94, 1363, 11, 94, 3, 95, 3, 95, 3, 95, 3, 95, 3, 96,
	3, 96, 3, 96, 3, 96, 5, 96, 1373, 10, 96, 3, 97, 3, 97, 3, 97, 5, 97, 1378,
	10, 97, 3, 98, 3, 98, 3, 98, 3, 98, 3, 99, 3, 99, 3, 99, 3, 99, 3, 100,
	3, 100, 3, 100, 3, 100, 3, 101, 3, 101, 3, 102, 3, 102, 3, 103, 3, 103,
	3, 103, 3, 103, 3, 103, 3, 103, 3, 104, 3, 104, 3, 104, 3, 104, 5, 104,
	1406, 10, 104, 3, 105, 3, 105, 3, 105, 3, 105, 5, 105, 1412, 10, 105, 3,
	106, 3, 106, 3, 107, 3, 107, 3, 108, 3, 108, 3, 109, 3, 109, 3, 110, 3,
	110, 3, 110, 3, 110, 3, 111, 3, 111, 3, 112, 3, 112, 3, 112, 3, 113, 7,
	113, 1432, 10, 113, 12, 113, 14, 113, 1435, 11, 113, 3, 114, 3, 114, 3,
	114, 3, 115, 3, 115, 5, 115, 1442, 10, 115, 3, 115, 3, 115, 5, 115, 1446,
	10, 115, 3, 116, 3, 116, 3, 117, 3, 117, 3, 117, 3, 118, 7, 118, 1454,
	10, 118, 12, 118, 14, 118, 1457, 11, 118, 3, 119, 3, 119, 3, 119, 3, 120,
	3, 120, 5, 120, 1464, 10, 120, 3, 120, 3, 120, 5, 120, 1468, 10, 120, 3,
	121, 3, 121, 3, 122, 3, 122, 5, 122, 1474, 10, 122, 3, 122, 5, 122, 1477,
	10, 122, 3, 122, 5, 122, 1480, 10, 122, 3, 122, 5, 122, 1483, 10, 122,
	3, 122, 5, 122, 1486, 10, 122, 3, 122, 5, 122, 1489, 10, 122, 3, 122, 5,
	122, 1492, 10, 122, 3, 122, 3, 122, 3, 123, 3, 123, 5, 123, 1498, 10, 123,
	3, 123, 5, 123, 1501, 10, 123, 3, 123, 3, 123, 3, 124, 3, 124, 5, 124,
	1507, 10, 124, 3, 124, 5, 124, 1510, 10, 124, 3, 124, 3, 124, 3, 125, 3,
	125, 3, 126, 3, 126, 5, 126, 1518, 10, 126, 3, 126, 5, 126, 1521, 10, 126,
	3, 126, 3, 126, 3, 127, 5, 127, 1526, 10, 127, 3, 127, 3, 127, 5, 127,
	1530, 10, 127, 3, 127, 3, 127, 3, 128, 5, 128, 1535, 10, 128, 3, 128, 3,
	128, 5, 128, 1539, 10, 128, 3, 128, 3, 128, 3, 129, 3, 129, 3, 129, 3,
	130, 3, 130, 3, 130, 3, 131, 3, 131, 3, 131, 3, 132, 3, 132, 3, 132, 3,
	133, 3, 133, 3, 133, 3, 134, 5, 134, 1559, 10, 134, 3, 134, 3, 134, 5,
	134, 1563, 10, 134, 3, 134, 3, 134, 3, 135, 3, 135, 3, 135, 3, 136, 3,
	136, 3, 136, 3, 137, 3, 137, 3, 137, 3, 138, 3, 138, 5, 138, 1578, 10,
	138, 3, 138, 5, 138, 1581, 10, 138, 3, 138, 5, 138, 1584, 10, 138, 3, 138,
	5, 138, 1587, 10, 138, 3, 138, 3, 138, 5, 138, 1591, 10, 138, 3, 138, 3,
	138, 3, 138, 3, 138, 3, 138, 5, 138, 1598, 10, 138, 3, 139, 3, 139, 3,
	139, 3, 139, 3, 139, 3, 139, 3, 139, 3, 139, 3, 139, 3, 139, 5, 139, 1610,
	10, 139, 3, 140, 3, 140, 3, 141, 3, 141, 5, 141, 1616, 10, 141, 3, 141,
	3, 141, 3, 142, 7, 142, 1621, 10, 142, 12, 142, 14, 142, 1624, 11, 142,
	3, 143, 3, 143, 3, 143, 3, 144, 3, 144, 5, 144, 1631, 10, 144, 3, 145,
	3, 145, 3, 146, 3, 146, 3, 146, 3, 147, 3, 147, 5, 147, 1640, 10, 147,
	3, 147, 3, 147, 5, 147, 1644, 10, 147, 3, 147, 3, 147, 3, 147, 3, 147,
	3, 147, 3, 148, 3, 148, 3, 149, 3, 149, 5, 149, 1655, 10, 149, 3, 149,
	3, 149, 3, 150, 3, 150, 3, 150, 3, 151, 3, 151, 5, 151, 1664, 10, 151,
	3, 152, 7, 152, 1667, 10, 152, 12, 152, 14, 152, 1670, 11, 152, 3, 153,
	3, 153, 3, 154, 3, 154, 3, 154, 3, 155, 7, 155, 1678, 10, 155, 12, 155,
	14, 155, 1681, 11, 155, 3, 156, 3, 156, 3, 156, 3, 156, 3, 156, 3, 156,
	5, 156, 1689, 10, 156, 3, 157, 3, 157, 5, 157, 1693, 10, 157, 3, 157, 3,
	157, 3, 157, 3, 157, 3, 158, 3, 158, 3, 158, 3, 158, 5, 158, 1703, 10,
	158, 3, 159, 3, 159, 3, 159, 3, 160, 3, 160, 3, 160, 3, 160, 3, 160, 5,
	160, 1713, 10, 160, 3, 161, 3, 161, 3, 162, 7, 162, 1718, 10, 162, 12,
	162, 14, 162, 1721, 11, 162, 3, 163, 3, 163, 3, 163, 3, 164, 3, 164, 5,
	164, 1728, 10, 164, 3, 164, 5, 164, 1731, 10, 164, 3, 164, 5, 164, 1734,
	10, 164, 3, 164, 3, 164, 3, 164, 3, 164, 3, 165, 3, 165, 5, 165, 1742,
	10, 165, 3, 165, 3, 165, 3, 165, 3, 166, 3, 166, 3, 166, 5, 166, 1750,
	10, 166, 3, 166, 3, 166, 3, 167, 3, 167, 5, 167, 1756, 10, 167, 3, 168,
	3, 168, 3, 168, 3, 169, 7, 169, 1762, 10, 169, 12, 169, 14, 169, 1765,
	11, 169, 3, 170, 3, 170, 5, 170, 1769, 10, 170, 3, 171, 3, 171, 3, 172,
	3, 172, 3, 172, 3, 173, 7, 173, 1777, 10, 173, 12, 173, 14, 173, 1780,
	11, 173, 3, 174, 3, 174, 3, 174, 3, 175, 3, 175, 3, 175, 3, 175, 5, 175,
	1789, 10, 175, 3, 175, 5, 175, 1792, 10, 175, 3, 175, 3, 175, 5, 175, 1796,
	10, 175, 3, 176, 3, 176, 3, 176, 3, 177, 7, 177, 1802, 10, 177, 12, 177,
	14, 177, 1805, 11, 177, 3, 178, 3, 178, 3, 178, 3, 179, 3, 179, 5, 179,
	1812, 10, 179, 3, 180, 3, 180, 3, 181, 3, 181, 5, 181, 1818, 10, 181, 3,
	182, 3, 182, 5, 182, 1822, 10, 182, 3, 183, 3, 183, 5, 183, 1826, 10, 183,
	3, 184, 3, 184, 5, 184, 1830, 10, 184, 3, 184, 3, 184, 3, 185, 3, 185,
	3, 185, 3, 185, 3, 185, 3, 185, 3, 185, 5, 185, 1841, 10, 185, 3, 186,
	3, 186, 3, 186, 3, 187, 7, 187, 1847, 10, 187, 12, 187, 14, 187, 1850,
	11, 187, 3, 188, 3, 188, 3, 188, 3, 189, 3, 189, 3, 190, 3, 190, 3, 190,
	3, 190, 3, 190, 3, 190, 3, 190, 3, 190, 3, 190, 3, 190, 3, 190, 3, 190,
	3, 190, 3, 190, 3, 190, 3, 190, 5, 190, 1873, 10, 190, 3, 191, 3, 191,
	3, 191, 3, 191, 3, 191, 3, 191, 3, 191, 3, 191, 3, 191, 3, 191, 3, 191,
	3, 191, 3, 191, 3, 191, 3, 191, 3, 191, 5, 191, 1891, 10, 191, 3, 192,
	3, 192, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193,
	3, 193, 5, 193, 1904, 10, 193, 3, 194, 3, 194, 3, 195, 3, 195, 3, 196,
	3, 196, 3, 197, 3, 197, 3, 198, 3, 198, 3, 199, 3, 199, 3, 200, 3, 200,
	3, 201, 3, 201, 5, 201, 1922, 10, 201, 3, 201, 3, 201, 3, 201, 3, 202,
	3, 202, 5, 202, 1929, 10, 202, 3, 202, 3, 202, 3, 202, 3, 203, 3, 203,
	5, 203, 1936, 10, 203, 3, 203, 5, 203, 1939, 10, 203, 3, 203, 3, 203, 3,
	203, 3, 204, 3, 204, 5, 204, 1946, 10, 204, 3, 204, 3, 204, 3, 204, 3,
	205, 3, 205, 5, 205, 1953, 10, 205, 3, 205, 3, 205, 3, 205, 3, 206, 3,
	206, 5, 206, 1960, 10, 206, 3, 206, 5, 206, 1963, 10, 206, 3, 206, 3, 206,
	3, 206, 3, 207, 3, 207, 5, 207, 1970, 10, 207, 3, 207, 5, 207, 1973, 10,
	207, 3, 207, 3, 207, 3, 207, 3, 208, 3, 208, 3, 208, 3, 208, 3, 209, 3,
	209, 5, 209, 1984, 10, 209, 3, 209, 3, 209, 3, 209, 3, 210, 3, 210, 3,
	210, 3, 211, 3, 211, 3, 211, 3, 212, 3, 212, 3, 212, 3, 213, 3, 213, 3,
	213, 3, 214, 3, 214, 3, 214, 3, 215, 3, 215, 3, 215, 3, 216, 3, 216, 3,
	216, 3, 217, 3, 217, 3, 217, 3, 218, 7, 218, 2014, 10, 218, 12, 218, 14,
	218, 2017, 11, 218, 3, 219, 7, 219, 2020, 10, 219, 12, 219, 14, 219, 2023,
	11, 219, 3, 220, 7, 220, 2026, 10, 220, 12, 220, 14, 220, 2029, 11, 220,
	3, 221, 7, 221, 2032, 10, 221, 12, 221, 14, 221, 2035, 11, 221, 3, 222,
	7, 222, 2038, 10, 222, 12, 222, 14, 222, 2041, 11, 222, 3, 223, 7, 223,
	2044, 10, 223, 12, 223, 14, 223, 2047, 11, 223, 3, 224, 7, 224, 2050, 10,
	224, 12, 224, 14, 224, 2053, 11, 224, 3, 225, 7, 225, 2056, 10, 225, 12,
	225, 14, 225, 2059, 11, 225, 3, 226, 3, 226, 3, 226, 3, 227, 3, 227, 3,
	227, 3, 228, 3, 228, 3, 228, 3, 229, 3, 229, 3, 229, 3, 230, 3, 230, 3,
	230, 3, 231, 3, 231, 3, 231, 3, 232, 3, 232, 3, 232, 3, 233, 3, 233, 3,
	233, 3, 234, 5, 234, 2086, 10, 234, 3, 234, 3, 234, 3, 235, 5, 235, 2091,
	10, 235, 3, 235, 3, 235, 3, 236, 5, 236, 2096, 10, 236, 3, 236, 3, 236,
	3, 237, 5, 237, 2101, 10, 237, 3, 237, 3, 237, 3, 238, 5, 238, 2106, 10,
	238, 3, 238, 3, 238, 3, 239, 5, 239, 2111, 10, 239, 3, 239, 3, 239, 3,
	240, 5, 240, 2116, 10, 240, 3, 240, 3, 240, 3, 241, 5, 241, 2121, 10, 241,
	3, 241, 3, 241, 3, 242, 3, 242, 3, 242, 3, 242, 3, 243, 3, 243, 3, 243,
	3, 243, 3, 243, 3, 243, 3, 243, 3, 243, 3, 244, 3, 244, 3, 244, 3, 244,
	3, 244, 3, 244, 3, 244, 3, 244, 3, 245, 3, 245, 3, 245, 3, 245, 3, 245,
	3, 245, 3, 245, 3, 245, 3, 245, 3, 245, 3, 246, 3, 246, 3, 246, 3, 246,
	3, 246, 3, 246, 3, 247, 3, 247, 3, 247, 3, 247, 3, 247, 3, 247, 3, 248,
	3, 248, 3, 248, 3, 248, 3, 248, 3, 248, 3, 249, 3, 249, 3, 249, 3, 249,
	3, 249, 3, 249, 3, 249, 3, 249, 3, 250, 3, 250, 3, 250, 3, 251, 3, 251,
	3, 251, 3, 252, 7, 252, 2188, 10, 252, 12, 252, 14, 252, 2191, 11, 252,
	3, 253, 7, 253, 2194, 10, 253, 12, 253, 14, 253, 2197, 11, 253, 3, 254,
	3, 254, 3, 254, 3, 255, 3, 255, 3, 255, 3, 256, 3, 256, 3, 257, 3, 257,
	3, 258, 3, 258, 3, 259, 3, 259, 3, 260, 3, 260, 3, 261, 3, 261, 3, 262,
	7, 262, 2218, 10, 262, 12, 262, 14, 262, 2221, 11, 262, 3, 263, 3, 263,
	3, 263, 5, 263, 2226, 10, 263, 3, 263, 5, 263, 2229, 10, 263, 3, 264, 3,
	264, 3, 264, 3, 264, 3, 264, 3, 264, 3, 264, 3, 264, 5, 264, 2239, 10,
	264, 3, 265, 3, 265, 3, 265, 3, 265, 3, 265, 3, 265, 5, 265, 2247, 10,
	265, 3, 266, 3, 266, 3, 266, 5, 266, 2252, 10, 266, 3, 267, 3, 267, 5,
	267, 2256, 10, 267, 3, 268, 3, 268, 3, 268, 5, 268, 2261, 10, 268, 3, 269,
	3, 269, 5, 269, 2265, 10, 269, 3, 270, 3, 270, 3, 270, 3, 270, 5, 270,
	2271, 10, 270, 3, 271, 3, 271, 3, 272, 3, 272, 3, 273, 3, 273, 3, 273,
	5, 273, 2280, 10, 273, 3, 274, 3, 274, 3, 275, 3, 275, 3, 275, 3, 275,
	5, 275, 2288, 10, 275, 3, 276, 3, 276, 3, 276, 3, 277, 3, 277, 3, 277,
	3, 278, 3, 278, 3, 278, 3, 279, 3, 279, 3, 279, 3, 280, 3, 280, 3, 280,
	3, 281, 3, 281, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282,
	3, 283, 3, 283, 3, 284, 3, 284, 5, 284, 2318, 10, 284, 3, 285, 3, 285,
	3, 285, 3, 286, 3, 286, 3, 286, 5, 286, 2326, 10, 286, 3, 286, 3, 286,
	3, 286, 3, 286, 3, 286, 3, 287, 3, 287, 5, 287, 2335, 10, 287, 3, 288,
	3, 288, 3, 289, 3, 289, 5, 289, 2341, 10, 289, 3, 289, 3, 289, 3, 290,
	3, 290, 5, 290, 2347, 10, 290, 3, 291, 3, 291, 3, 292, 3, 292, 3, 292,
	3, 292, 5, 292, 2355, 10, 292, 3, 293, 3, 293, 3, 294, 3, 294, 5, 294,
	2361, 10, 294, 3, 295, 3, 295, 3, 296, 3, 296, 3, 296, 3, 296, 3, 296,
	3, 297, 3, 297, 5, 297, 2372, 10, 297, 3, 298, 3, 298, 7, 298, 2376, 10,
	298, 12, 298, 14, 298, 2379, 11, 298, 3, 299, 3, 299, 3, 299, 5, 299, 2384,
	10, 299, 3, 299, 3, 299, 3, 300, 3, 300, 3, 300, 5, 300, 2391, 10, 300,
	3, 300, 3, 300, 3, 301, 3, 301, 3, 301, 3, 302, 3, 302, 3, 302, 3, 303,
	3, 303, 3, 303, 3, 303, 3, 304, 3, 304, 3, 304, 3, 304, 3, 304, 3, 304,
	5, 304, 2411, 10, 304, 3, 305, 3, 305, 3, 305, 5, 305, 2416, 10, 305, 3,
	306, 3, 306, 3, 306, 3, 306, 3, 306, 3, 306, 3, 306, 3, 306, 3, 306, 3,
	306, 3, 306, 3, 306, 5, 306, 2430, 10, 306, 3, 307, 3, 307, 3, 307, 5,
	307, 2435, 10, 307, 3, 308, 3, 308, 3, 308, 3, 309, 3, 309, 3, 309, 3,
	309, 3, 309, 3, 310, 3, 310, 5, 310, 2447, 10, 310, 3, 311, 3, 311, 3,
	311, 3, 311, 3, 311, 5, 311, 2454, 10, 311, 3, 312, 3, 312, 3, 313, 3,
	313, 5, 313, 2460, 10, 313, 3, 314, 3, 314, 3, 314, 3, 315, 7, 315, 2466,
	10, 315, 12, 315, 14, 315, 2469, 11, 315, 3, 316, 3, 316, 3, 316, 3, 317,
	3, 317, 3, 317, 3, 318, 7, 318, 2478, 10, 318, 12, 318, 14, 318, 2481,
	11, 318, 3, 319, 3, 319, 3, 319, 3, 320, 3, 320, 3, 320, 3, 320, 3, 320,
	3, 320, 5, 320, 2492, 10, 320, 3, 321, 3, 321, 3, 321, 3, 321, 3, 321,
	3, 321, 3, 322, 3, 322, 3, 322, 3, 323, 3, 323, 3, 324, 3, 324, 3, 325,
	3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 326, 3, 326, 3, 326, 3, 327,
	3, 327, 3, 327, 3, 327, 5, 327, 2520, 10, 327, 3, 328, 7, 328, 2523, 10,
	328, 12, 328, 14, 328, 2526, 11, 328, 3, 329, 3, 329, 3, 329, 3, 329, 3,
	329, 3, 329, 3, 329, 3, 329, 3, 329, 3, 329, 5, 329, 2538, 10, 329, 3,
	330, 3, 330, 5, 330, 2542, 10, 330, 3, 330, 3, 330, 3, 330, 5, 330, 2547,
	10, 330, 3, 330, 5, 330, 2550, 10, 330, 3, 331, 3, 331, 3, 332, 3, 332,
	3, 333, 3, 333, 3, 333, 3, 334, 3, 334, 3, 335, 3, 335, 5, 335, 2563, 10,
	335, 3, 336, 3, 336, 3, 336, 3, 336, 3, 336, 3, 336, 3, 337, 3, 337, 3,
	337, 3, 338, 3, 338, 3, 338, 3, 338, 3, 338, 5, 338, 2579, 10, 338, 3,
	339, 3, 339, 3, 339, 3, 340, 3, 340, 3, 340, 3, 340, 3, 340, 3, 340, 3,
	341, 3, 341, 3, 341, 3, 341, 3, 341, 3, 341, 3, 342, 3, 342, 3, 342, 3,
	342, 3, 342, 3, 342, 3, 342, 3, 342, 3, 343, 3, 343, 3, 343, 3, 343, 3,
	343, 3, 343, 3, 343, 5, 343, 2611, 10, 343, 3, 343, 3, 343, 3, 343, 3,
	344, 3, 344, 3, 344, 3, 344, 3, 344, 3, 344, 3, 344, 3, 345, 7, 345, 2624,
	10, 345, 12, 345, 14, 345, 2627, 11, 345, 3, 346, 3, 346, 3, 346, 3, 346,
	3, 346, 3, 346, 5, 346, 2635, 10, 346, 3, 346, 5, 346, 2638, 10, 346, 3,
	347, 3, 347, 5, 347, 2642, 10, 347, 3, 348, 3, 348, 3, 348, 3, 348, 3,
	348, 3, 348, 3, 349, 3, 349, 3, 349, 3, 350, 3, 350, 3, 351, 3, 351, 3,
	351, 3, 351, 3, 351, 5, 351, 2660, 10, 351, 3, 352, 3, 352, 3, 352, 3,
	353, 3, 353, 3, 353, 3, 353, 3, 353, 3, 353, 3, 354, 3, 354, 3, 354, 3,
	354, 3, 354, 3, 354, 3, 355, 3, 355, 3, 355, 3, 355, 3, 355, 3, 355, 3,
	355, 3, 355, 3, 356, 3, 356, 3, 356, 3, 356, 3, 356, 3, 356, 3, 356, 5,
	356, 2692, 10, 356, 3, 356, 3, 356, 3, 356, 3, 357, 3, 357, 5, 357, 2699,
	10, 357, 3, 358, 3, 358, 3, 359, 3, 359, 3, 359, 3, 359, 5, 359, 2707,
	10, 359, 3, 360, 3, 360, 3, 360, 3, 360, 3, 360, 3, 360, 3, 360, 3, 361,
	7, 361, 2717, 10, 361, 12, 361, 14, 361, 2720, 11, 361, 3, 362, 3, 362,
	3, 362, 3, 362, 3, 362, 3, 362, 5, 362, 2728, 10, 362, 3, 362, 5, 362,
	2731, 10, 362, 3, 363, 3, 363, 3, 364, 3, 364, 3, 364, 3, 365, 3, 365,
	3, 366, 3, 366, 3, 366, 3, 367, 7, 367, 2744, 10, 367, 12, 367, 14, 367,
	2747, 11, 367, 3, 368, 3, 368, 3, 368, 3, 368, 3, 368, 3, 368, 3, 368,
	5, 368, 2756, 10, 368, 3, 369, 3, 369, 3, 369, 3, 369, 5, 369, 2762, 10,
	369, 3, 370, 3, 370, 3, 370, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3,
	371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 5, 371, 2778, 10, 371, 3,
	372, 3, 372, 3, 372, 3, 373, 3, 373, 3, 373, 3, 374, 3, 374, 3, 374, 3,
	375, 3, 375, 3, 375, 3, 375, 3, 376, 3, 376, 3, 376, 3, 376, 3, 376, 3,
	376, 3, 377, 3, 377, 3, 377, 3, 377, 3, 377, 3, 377, 3, 378, 3, 378, 3,
	378, 3, 378, 3, 378, 7, 378, 2810, 10, 378, 12, 378, 14, 378, 2813, 11,
	378, 3, 378, 3, 378, 3, 378, 3, 378, 3, 378, 3, 378, 3, 378, 3, 378, 3,
	378, 5, 378, 2824, 10, 378, 3, 379, 3, 379, 3, 379, 3, 379, 3, 379, 3,
	380, 3, 380, 3, 380, 3, 380, 3, 380, 3, 380, 3, 380, 5, 380, 2838, 10,
	380, 3, 381, 3, 381, 3, 381, 3, 382, 7, 382, 2844, 10, 382, 12, 382, 14,
	382, 2847, 11, 382, 3, 383, 3, 383, 3, 383, 3, 384, 3, 384, 3, 384, 3,
	384, 3, 385, 3, 385, 3, 385, 3, 385, 3, 386, 3, 386, 3, 386, 3, 386, 3,
	387, 3, 387, 3, 387, 3, 388, 3, 388, 5, 388, 2869, 10, 388, 3, 389, 3,
	389, 3, 390, 3, 390, 3, 390, 3, 390, 5, 390, 2877, 10, 390, 3, 391, 3,
	391, 3, 391, 3, 391, 3, 392, 3, 392, 3, 393, 3, 393, 5, 393, 2887, 10,
	393, 3, 393, 3, 393, 3, 394, 3, 394, 5, 394, 2893, 10, 394, 3, 395, 3,
	395, 3, 396, 3, 396, 3, 397, 3, 397, 3, 397, 3, 397, 3, 398, 3, 398, 3,
	399, 3, 399, 5, 399, 2907, 10, 399, 3, 400, 3, 400, 5, 400, 2911, 10, 400,
	3, 401, 3, 401, 3, 401, 3, 401, 3, 402, 3, 402, 3, 402, 3, 402, 3, 403,
	3, 403, 3, 403, 3, 403, 3, 403, 3, 404, 3, 404, 3, 404, 3, 404, 3, 404,
	3, 405, 3, 405, 6, 405, 2933, 10, 405, 13, 405, 14, 405, 2934, 3, 406,
	3, 406, 7, 406, 2939, 10, 406, 12, 406, 14, 406, 2942, 11, 406, 3, 407,
	3, 407, 3, 407, 3, 407, 3, 408, 3, 408, 3, 409, 3, 409, 3, 409, 5, 409,
	2953, 10, 409, 3, 410, 3, 410, 5, 410, 2957, 10, 410, 3, 411, 3, 411, 5,
	411, 2961, 10, 411, 3, 411, 5, 411, 2964, 10, 411, 3, 412, 3, 412, 3, 412,
	3, 412, 3, 412, 5, 412, 2971, 10, 412, 3, 413, 3, 413, 3, 413, 5, 413,
	2976, 10, 413, 3, 413, 3, 413, 3, 413, 3, 413, 5, 413, 2982, 10, 413, 3,
	414, 3, 414, 3, 414, 5, 414, 2987, 10, 414, 3, 414, 3, 414, 3, 414, 3,
	414, 5, 414, 2993, 10, 414, 3, 415, 3, 415, 3, 416, 3, 416, 3, 416, 3,
	417, 7, 417, 3001, 10, 417, 12, 417, 14, 417, 3004, 11, 417, 3, 418, 3,
	418, 3, 418, 3, 419, 3, 419, 3, 419, 3, 419, 3, 419, 3, 419, 3, 419, 3,
	419, 3, 419, 3, 419, 3, 419, 3, 419, 3, 419, 5, 419, 3022, 10, 419, 3,
	420, 3, 420, 3, 421, 3, 421, 5, 421, 3028, 10, 421, 3, 421, 5, 421, 3031,
	10, 421, 3, 421, 3, 421, 3, 421, 3, 422, 3, 422, 3, 422, 3, 423, 7, 423,
	3040, 10, 423, 12, 423, 14, 423, 3043, 11, 423, 3, 424, 3, 424, 3, 424,
	3, 425, 3, 425, 3, 425, 3, 425, 3, 426, 3, 426, 3, 426, 3, 427, 3, 427,
	3, 427, 3, 428, 3, 428, 3, 429, 3, 429, 3, 429, 3, 430, 7, 430, 3064, 10,
	430, 12, 430, 14, 430, 3067, 11, 430, 3, 431, 3, 431, 3, 431, 3, 431, 3,
	431, 3, 431, 3, 431, 3, 432, 3, 432, 7, 432, 3078, 10, 432, 12, 432, 14,
	432, 3081, 11, 432, 3, 433, 3, 433, 3, 433, 3, 433, 3, 433, 5, 433, 3088,
	10, 433, 3, 434, 3, 434, 3, 435, 3, 435, 3, 436, 3, 436, 3, 436, 3, 437,
	7, 437, 3098, 10, 437, 12, 437, 14, 437, 3101, 11, 437, 3, 438, 3, 438,
	3, 438, 3, 439, 3, 439, 5, 439, 3108, 10, 439, 3, 440, 3, 440, 3, 440,
	3, 440, 3, 440, 3, 441, 3, 441, 3, 441, 3, 442, 3, 442, 3, 442, 3, 443,
	3, 443, 3, 443, 3, 444, 3, 444, 5, 444, 3126, 10, 444, 3, 445, 3, 445,
	3, 446, 3, 446, 3, 446, 2, 2, 447, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20,
	22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56,
	58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92,
	94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122,
	124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152,
	154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182,
	184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212,
	214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242,
	244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272,
	274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302,
	304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332,
	334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362,
	364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392,
	394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422,
	424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452,
	454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 482,
	484, 486, 488, 490, 492, 494, 496, 498, 500, 502, 504, 506, 508, 510, 512,
	514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542,
	544, 546, 548, 550, 552, 554, 556, 558, 560, 562, 564, 566, 568, 570, 572,
	574, 576, 578, 580, 582, 584, 586, 588, 590, 592, 594, 596, 598, 600, 602,
	604, 606, 608, 610, 612, 614, 616, 618, 620, 622, 624, 626, 628, 630, 632,
	634, 636, 638, 640, 642, 644, 646, 648, 650, 652, 654, 656, 658, 660, 662,
	664, 666, 668, 670, 672, 674, 676, 678, 680, 682, 684, 686, 688, 690, 692,
	694, 696, 698, 700, 702, 704, 706, 708, 710, 712, 714, 716, 718, 720, 722,
	724, 726, 728, 730, 732, 734, 736, 738, 740, 742, 744, 746, 748, 750, 752,
	754, 756, 758, 760, 762, 764, 766, 768, 770, 772, 774, 776, 778, 780, 782,
	784, 786, 788, 790, 792, 794, 796, 798, 800, 802, 804, 806, 808, 810, 812,
	814, 816, 818, 820, 822, 824, 826, 828, 830, 832, 834, 836, 838, 840, 842,
	844, 846, 848, 850, 852, 854, 856, 858, 860, 862, 864, 866, 868, 870, 872,
	874, 876, 878, 880, 882, 884, 886, 888, 890, 2, 30, 4, 2, 121, 121, 123,
	123, 4, 2, 171, 171, 189, 189, 3, 2, 64, 66, 4, 2, 4, 13, 232, 232, 9,
	2, 4, 5, 7, 7, 9, 9, 11, 28, 217, 217, 219, 219, 230, 230, 3, 2, 29, 30,
	3, 2, 31, 34, 4, 2, 163, 163, 190, 190, 8, 2, 127, 127, 172, 173, 182,
	187, 192, 192, 195, 195, 199, 200, 6, 2, 142, 142, 169, 169, 172, 172,
	196, 196, 6, 2, 143, 143, 170, 170, 173, 173, 197, 197, 5, 2, 116, 116,
	122, 122, 164, 164, 4, 2, 161, 161, 193, 193, 4, 2, 59, 59, 63, 63, 5,
	2, 57, 57, 70, 70, 167, 167, 4, 2, 61, 62, 130, 131, 5, 2, 126, 126, 140,
	140, 156, 157, 4, 2, 68, 68, 148, 148, 4, 2, 60, 60, 129, 129, 7, 2, 54,
	54, 124, 124, 128, 128, 133, 133, 201, 202, 4, 2, 158, 158, 179, 179, 4,
	2, 159, 160, 180, 181, 4, 2, 125, 125, 137, 137, 3, 2, 113, 115, 3, 2,
	51, 53, 3, 2, 204, 205, 4, 2, 44, 45, 47, 48, 4, 2, 46, 46, 49, 49, 2,
	3116, 2, 892, 3, 2, 2, 2, 4, 894, 3, 2, 2, 2, 6, 896, 3, 2, 2, 2, 8, 902,
	3, 2, 2, 2, 10, 904, 3, 2, 2, 2, 12, 906, 3, 2, 2, 2, 14, 908, 3, 2, 2,
	2, 16, 910, 3, 2, 2, 2, 18, 912, 3, 2, 2, 2, 20, 918, 3, 2, 2, 2, 22, 924,
	3, 2, 2, 2, 24, 926, 3, 2, 2, 2, 26, 930, 3, 2, 2, 2, 28, 953, 3, 2, 2,
	2, 30, 955, 3, 2, 2, 2, 32, 965, 3, 2, 2, 2, 34, 968, 3, 2, 2, 2, 36, 973,
	3, 2, 2, 2, 38, 980, 3, 2, 2, 2, 40, 989, 3, 2, 2, 2, 42, 1002, 3, 2, 2,
	2, 44, 1004, 3, 2, 2, 2, 46, 1007, 3, 2, 2, 2, 48, 1016, 3, 2, 2, 2, 50,
	1018, 3, 2, 2, 2, 52, 1024, 3, 2, 2, 2, 54, 1034, 3, 2, 2, 2, 56, 1048,
	3, 2, 2, 2, 58, 1050, 3, 2, 2, 2, 60, 1052, 3, 2, 2, 2, 62, 1058, 3, 2,
	2, 2, 64, 1060, 3, 2, 2, 2, 66, 1064, 3, 2, 2, 2, 68, 1083, 3, 2, 2, 2,
	70, 1085, 3, 2, 2, 2, 72, 1091, 3, 2, 2, 2, 74, 1093, 3, 2, 2, 2, 76, 1100,
	3, 2, 2, 2, 78, 1102, 3, 2, 2, 2, 80, 1107, 3, 2, 2, 2, 82, 1116, 3, 2,
	2, 2, 84, 1122, 3, 2, 2, 2, 86, 1124, 3, 2, 2, 2, 88, 1128, 3, 2, 2, 2,
	90, 1130, 3, 2, 2, 2, 92, 1136, 3, 2, 2, 2, 94, 1139, 3, 2, 2, 2, 96, 1142,
	3, 2, 2, 2, 98, 1145, 3, 2, 2, 2, 100, 1161, 3, 2, 2, 2, 102, 1163, 3,
	2, 2, 2, 104, 1166, 3, 2, 2, 2, 106, 1169, 3, 2, 2, 2, 108, 1174, 3, 2,
	2, 2, 110, 1178, 3, 2, 2, 2, 112, 1180, 3, 2, 2, 2, 114, 1186, 3, 2, 2,
	2, 116, 1189, 3, 2, 2, 2, 118, 1192, 3, 2, 2, 2, 120, 1195, 3, 2, 2, 2,
	122, 1202, 3, 2, 2, 2, 124, 1205, 3, 2, 2, 2, 126, 1208, 3, 2, 2, 2, 128,
	1216, 3, 2, 2, 2, 130, 1220, 3, 2, 2, 2, 132, 1222, 3, 2, 2, 2, 134, 1230,
	3, 2, 2, 2, 136, 1233, 3, 2, 2, 2, 138, 1236, 3, 2, 2, 2, 140, 1240, 3,
	2, 2, 2, 142, 1242, 3, 2, 2, 2, 144, 1248, 3, 2, 2, 2, 146, 1251, 3, 2,
	2, 2, 148, 1254, 3, 2, 2, 2, 150, 1257, 3, 2, 2, 2, 152, 1264, 3, 2, 2,
	2, 154, 1267, 3, 2, 2, 2, 156, 1270, 3, 2, 2, 2, 158, 1277, 3, 2, 2, 2,
	160, 1280, 3, 2, 2, 2, 162, 1289, 3, 2, 2, 2, 164, 1302, 3, 2, 2, 2, 166,
	1312, 3, 2, 2, 2, 168, 1322, 3, 2, 2, 2, 170, 1335, 3, 2, 2, 2, 172, 1337,
	3, 2, 2, 2, 174, 1340, 3, 2, 2, 2, 176, 1343, 3, 2, 2, 2, 178, 1346, 3,
	2, 2, 2, 180, 1349, 3, 2, 2, 2, 182, 1351, 3, 2, 2, 2, 184, 1354, 3, 2,
	2, 2, 186, 1361, 3, 2, 2, 2, 188, 1364, 3, 2, 2, 2, 190, 1372, 3, 2, 2,
	2, 192, 1377, 3, 2, 2, 2, 194, 1379, 3, 2, 2, 2, 196, 1383, 3, 2, 2, 2,
	198, 1387, 3, 2, 2, 2, 200, 1391, 3, 2, 2, 2, 202, 1393, 3, 2, 2, 2, 204,
	1395, 3, 2, 2, 2, 206, 1405, 3, 2, 2, 2, 208, 1411, 3, 2, 2, 2, 210, 1413,
	3, 2, 2, 2, 212, 1415, 3, 2, 2, 2, 214, 1417, 3, 2, 2, 2, 216, 1419, 3,
	2, 2, 2, 218, 1421, 3, 2, 2, 2, 220, 1425, 3, 2, 2, 2, 222, 1427, 3, 2,
	2, 2, 224, 1433, 3, 2, 2, 2, 226, 1436, 3, 2, 2, 2, 228, 1439, 3, 2, 2,
	2, 230, 1447, 3, 2, 2, 2, 232, 1449, 3, 2, 2, 2, 234, 1455, 3, 2, 2, 2,
	236, 1458, 3, 2, 2, 2, 238, 1461, 3, 2, 2, 2, 240, 1469, 3, 2, 2, 2, 242,
	1471, 3, 2, 2, 2, 244, 1495, 3, 2, 2, 2, 246, 1504, 3, 2, 2, 2, 248, 1513,
	3, 2, 2, 2, 250, 1515, 3, 2, 2, 2, 252, 1525, 3, 2, 2, 2, 254, 1534, 3,
	2, 2, 2, 256, 1542, 3, 2, 2, 2, 258, 1545, 3, 2, 2, 2, 260, 1548, 3, 2,
	2, 2, 262, 1551, 3, 2, 2, 2, 264, 1554, 3, 2, 2, 2, 266, 1558, 3, 2, 2,
	2, 268, 1566, 3, 2, 2, 2, 270, 1569, 3, 2, 2, 2, 272, 1572, 3, 2, 2, 2,
	274, 1575, 3, 2, 2, 2, 276, 1609, 3, 2, 2, 2, 278, 1611, 3, 2, 2, 2, 280,
	1613, 3, 2, 2, 2, 282, 1622, 3, 2, 2, 2, 284, 1625, 3, 2, 2, 2, 286, 1630,
	3, 2, 2, 2, 288, 1632, 3, 2, 2, 2, 290, 1634, 3, 2, 2, 2, 292, 1637, 3,
	2, 2, 2, 294, 1650, 3, 2, 2, 2, 296, 1652, 3, 2, 2, 2, 298, 1658, 3, 2,
	2, 2, 300, 1663, 3, 2, 2, 2, 302, 1668, 3, 2, 2, 2, 304, 1671, 3, 2, 2,
	2, 306, 1673, 3, 2, 2, 2, 308, 1679, 3, 2, 2, 2, 310, 1688, 3, 2, 2, 2,
	312, 1690, 3, 2, 2, 2, 314, 1702, 3, 2, 2, 2, 316, 1704, 3, 2, 2, 2, 318,
	1712, 3, 2, 2, 2, 320, 1714, 3, 2, 2, 2, 322, 1719, 3, 2, 2, 2, 324, 1722,
	3, 2, 2, 2, 326, 1725, 3, 2, 2, 2, 328, 1739, 3, 2, 2, 2, 330, 1746, 3,
	2, 2, 2, 332, 1755, 3, 2, 2, 2, 334, 1757, 3, 2, 2, 2, 336, 1763, 3, 2,
	2, 2, 338, 1766, 3, 2, 2, 2, 340, 1770, 3, 2, 2, 2, 342, 1772, 3, 2, 2,
	2, 344, 1778, 3, 2, 2, 2, 346, 1781, 3, 2, 2, 2, 348, 1795, 3, 2, 2, 2,
	350, 1797, 3, 2, 2, 2, 352, 1803, 3, 2, 2, 2, 354, 1806, 3, 2, 2, 2, 356,
	1809, 3, 2, 2, 2, 358, 1813, 3, 2, 2, 2, 360, 1817, 3, 2, 2, 2, 362, 1819,
	3, 2, 2, 2, 364, 1823, 3, 2, 2, 2, 366, 1827, 3, 2, 2, 2, 368, 1840, 3,
	2, 2, 2, 370, 1842, 3, 2, 2, 2, 372, 1848, 3, 2, 2, 2, 374, 1851, 3, 2,
	2, 2, 376, 1854, 3, 2, 2, 2, 378, 1872, 3, 2, 2, 2, 380, 1890, 3, 2, 2,
	2, 382, 1892, 3, 2, 2, 2, 384, 1903, 3, 2, 2, 2, 386, 1905, 3, 2, 2, 2,
	388, 1907, 3, 2, 2, 2, 390, 1909, 3, 2, 2, 2, 392, 1911, 3, 2, 2, 2, 394,
	1913, 3, 2, 2, 2, 396, 1915, 3, 2, 2, 2, 398, 1917, 3, 2, 2, 2, 400, 1919,
	3, 2, 2, 2, 402, 1926, 3, 2, 2, 2, 404, 1933, 3, 2, 2, 2, 406, 1943, 3,
	2, 2, 2, 408, 1950, 3, 2, 2, 2, 410, 1957, 3, 2, 2, 2, 412, 1967, 3, 2,
	2, 2, 414, 1977, 3, 2, 2, 2, 416, 1981, 3, 2, 2, 2, 418, 1988, 3, 2, 2,
	2, 420, 1991, 3, 2, 2, 2, 422, 1994, 3, 2, 2, 2, 424, 1997, 3, 2, 2, 2,
	426, 2000, 3, 2, 2, 2, 428, 2003, 3, 2, 2, 2, 430, 2006, 3, 2, 2, 2, 432,
	2009, 3, 2, 2, 2, 434, 2015, 3, 2, 2, 2, 436, 2021, 3, 2, 2, 2, 438, 2027,
	3, 2, 2, 2, 440, 2033, 3, 2, 2, 2, 442, 2039, 3, 2, 2, 2, 444, 2045, 3,
	2, 2, 2, 446, 2051, 3, 2, 2, 2, 448, 2057, 3, 2, 2, 2, 450, 2060, 3, 2,
	2, 2, 452, 2063, 3, 2, 2, 2, 454, 2066, 3, 2, 2, 2, 456, 2069, 3, 2, 2,
	2, 458, 2072, 3, 2, 2, 2, 460, 2075, 3, 2, 2, 2, 462, 2078, 3, 2, 2, 2,
	464, 2081, 3, 2, 2, 2, 466, 2085, 3, 2, 2, 2, 468, 2090, 3, 2, 2, 2, 470,
	2095, 3, 2, 2, 2, 472, 2100, 3, 2, 2, 2, 474, 2105, 3, 2, 2, 2, 476, 2110,
	3, 2, 2, 2, 478, 2115, 3, 2, 2, 2, 480, 2120, 3, 2, 2, 2, 482, 2124, 3,
	2, 2, 2, 484, 2128, 3, 2, 2, 2, 486, 2136, 3, 2, 2, 2, 488, 2144, 3, 2,
	2, 2, 490, 2154, 3, 2, 2, 2, 492, 2160, 3, 2, 2, 2, 494, 2166, 3, 2, 2,
	2, 496, 2172, 3, 2, 2, 2, 498, 2180, 3, 2, 2, 2, 500, 2183, 3, 2, 2, 2,
	502, 2189, 3, 2, 2, 2, 504, 2195, 3, 2, 2, 2, 506, 2198, 3, 2, 2, 2, 508,
	2201, 3, 2, 2, 2, 510, 2204, 3, 2, 2, 2, 512, 2206, 3, 2, 2, 2, 514, 2208,
	3, 2, 2, 2, 516, 2210, 3, 2, 2, 2, 518, 2212, 3, 2, 2, 2, 520, 2214, 3,
	2, 2, 2, 522, 2219, 3, 2, 2, 2, 524, 2228, 3, 2, 2, 2, 526, 2238, 3, 2,
	2, 2, 528, 2246, 3, 2, 2, 2, 530, 2251, 3, 2, 2, 2, 532, 2255, 3, 2, 2,
	2, 534, 2260, 3, 2, 2, 2, 536, 2264, 3, 2, 2, 2, 538, 2270, 3, 2, 2, 2,
	540, 2272, 3, 2, 2, 2, 542, 2274, 3, 2, 2, 2, 544, 2279, 3, 2, 2, 2, 546,
	2281, 3, 2, 2, 2, 548, 2287, 3, 2, 2, 2, 550, 2289, 3, 2, 2, 2, 552, 2292,
	3, 2, 2, 2, 554, 2295, 3, 2, 2, 2, 556, 2298, 3, 2, 2, 2, 558, 2301, 3,
	2, 2, 2, 560, 2304, 3, 2, 2, 2, 562, 2306, 3, 2, 2, 2, 564, 2313, 3, 2,
	2, 2, 566, 2315, 3, 2, 2, 2, 568, 2319, 3, 2, 2, 2, 570, 2325, 3, 2, 2,
	2, 572, 2332, 3, 2, 2, 2, 574, 2336, 3, 2, 2, 2, 576, 2338, 3, 2, 2, 2,
	578, 2344, 3, 2, 2, 2, 580, 2348, 3, 2, 2, 2, 582, 2354, 3, 2, 2, 2, 584,
	2356, 3, 2, 2, 2, 586, 2360, 3, 2, 2, 2, 588, 2362, 3, 2, 2, 2, 590, 2364,
	3, 2, 2, 2, 592, 2371, 3, 2, 2, 2, 594, 2377, 3, 2, 2, 2, 596, 2380, 3,
	2, 2, 2, 598, 2387, 3, 2, 2, 2, 600, 2394, 3, 2, 2, 2, 602, 2397, 3, 2,
	2, 2, 604, 2400, 3, 2, 2, 2, 606, 2410, 3, 2, 2, 2, 608, 2415, 3, 2, 2,
	2, 610, 2429, 3, 2, 2, 2, 612, 2434, 3, 2, 2, 2, 614, 2436, 3, 2, 2, 2,
	616, 2439, 3, 2, 2, 2, 618, 2446, 3, 2, 2, 2, 620, 2453, 3, 2, 2, 2, 622,
	2455, 3, 2, 2, 2, 624, 2459, 3, 2, 2, 2, 626, 2461, 3, 2, 2, 2, 628, 2467,
	3, 2, 2, 2, 630, 2470, 3, 2, 2, 2, 632, 2473, 3, 2, 2, 2, 634, 2479, 3,
	2, 2, 2, 636, 2482, 3, 2, 2, 2, 638, 2491, 3, 2, 2, 2, 640, 2493, 3, 2,
	2, 2, 642, 2499, 3, 2, 2, 2, 644, 2502, 3, 2, 2, 2, 646, 2504, 3, 2, 2,
	2, 648, 2506, 3, 2, 2, 2, 650, 2512, 3, 2, 2, 2, 652, 2515, 3, 2, 2, 2,
	654, 2524, 3, 2, 2, 2, 656, 2537, 3, 2, 2, 2, 658, 2539, 3, 2, 2, 2, 660,
	2551, 3, 2, 2, 2, 662, 2553, 3, 2, 2, 2, 664, 2555, 3, 2, 2, 2, 666, 2558,
	3, 2, 2, 2, 668, 2560, 3, 2, 2, 2, 670, 2564, 3, 2, 2, 2, 672, 2570, 3,
	2, 2, 2, 674, 2578, 3, 2, 2, 2, 676, 2580, 3, 2, 2, 2, 678, 2583, 3, 2,
	2, 2, 680, 2589, 3, 2, 2, 2, 682, 2595, 3, 2, 2, 2, 684, 2603, 3, 2, 2,
	2, 686, 2615, 3, 2, 2, 2, 688, 2625, 3, 2, 2, 2, 690, 2637, 3, 2, 2, 2,
	692, 2639, 3, 2, 2, 2, 694, 2643, 3, 2, 2, 2, 696, 2649, 3, 2, 2, 2, 698,
	2652, 3, 2, 2, 2, 700, 2659, 3, 2, 2, 2, 702, 2661, 3, 2, 2, 2, 704, 2664,
	3, 2, 2, 2, 706, 2670, 3, 2, 2, 2, 708, 2676, 3, 2, 2, 2, 710, 2684, 3,
	2, 2, 2, 712, 2698, 3, 2, 2, 2, 714, 2700, 3, 2, 2, 2, 716, 2706, 3, 2,
	2, 2, 718, 2708, 3, 2, 2, 2, 720, 2718, 3, 2, 2, 2, 722, 2730, 3, 2, 2,
	2, 724, 2732, 3, 2, 2, 2, 726, 2734, 3, 2, 2, 2, 728, 2737, 3, 2, 2, 2,
	730, 2739, 3, 2, 2, 2, 732, 2745, 3, 2, 2, 2, 734, 2755, 3, 2, 2, 2, 736,
	2761, 3, 2, 2, 2, 738, 2763, 3, 2, 2, 2, 740, 2777, 3, 2, 2, 2, 742, 2779,
	3, 2, 2, 2, 744, 2782, 3, 2, 2, 2, 746, 2785, 3, 2, 2, 2, 748, 2788, 3,
	2, 2, 2, 750, 2792, 3, 2, 2, 2, 752, 2798, 3, 2, 2, 2, 754, 2823, 3, 2,
	2, 2, 756, 2825, 3, 2, 2, 2, 758, 2837, 3, 2, 2, 2, 760, 2839, 3, 2, 2,
	2, 762, 2845, 3, 2, 2, 2, 764, 2848, 3, 2, 2, 2, 766, 2851, 3, 2, 2, 2,
	768, 2855, 3, 2, 2, 2, 770, 2859, 3, 2, 2, 2, 772, 2863, 3, 2, 2, 2, 774,
	2868, 3, 2, 2, 2, 776, 2870, 3, 2, 2, 2, 778, 2876, 3, 2, 2, 2, 780, 2878,
	3, 2, 2, 2, 782, 2882, 3, 2, 2, 2, 784, 2884, 3, 2, 2, 2, 786, 2890, 3,
	2, 2, 2, 788, 2894, 3, 2, 2, 2, 790, 2896, 3, 2, 2, 2, 792, 2898, 3, 2,
	2, 2, 794, 2902, 3, 2, 2, 2, 796, 2904, 3, 2, 2, 2, 798, 2908, 3, 2, 2,
	2, 800, 2912, 3, 2, 2, 2, 802, 2916, 3, 2, 2, 2, 804, 2920, 3, 2, 2, 2,
	806, 2925, 3, 2, 2, 2, 808, 2932, 3, 2, 2, 2, 810, 2940, 3, 2, 2, 2, 812,
	2943, 3, 2, 2, 2, 814, 2947, 3, 2, 2, 2, 816, 2952, 3, 2, 2, 2, 818, 2956,
	3, 2, 2, 2, 820, 2958, 3, 2, 2, 2, 822, 2970, 3, 2, 2, 2, 824, 2972, 3,
	2, 2, 2, 826, 2983, 3, 2, 2, 2, 828, 2994, 3, 2, 2, 2, 830, 2996, 3, 2,
	2, 2, 832, 3002, 3, 2, 2, 2, 834, 3005, 3, 2, 2, 2, 836, 3021, 3, 2, 2,
	2, 838, 3023, 3, 2, 2, 2, 840, 3025, 3, 2, 2, 2, 842, 3035, 3, 2, 2, 2,
	844, 3041, 3, 2, 2, 2, 846, 3044, 3, 2, 2, 2, 848, 3047, 3, 2, 2, 2, 850,
	3051, 3, 2, 2, 2, 852, 3054, 3, 2, 2, 2, 854, 3057, 3, 2, 2, 2, 856, 3059,
	3, 2, 2, 2, 858, 3065, 3, 2, 2, 2, 860, 3068, 3, 2, 2, 2, 862, 3079, 3,
	2, 2, 2, 864, 3087, 3, 2, 2, 2, 866, 3089, 3, 2, 2, 2, 868, 3091, 3, 2,
	2, 2, 870, 3093, 3, 2, 2, 2, 872, 3099, 3, 2, 2, 2, 874, 3102, 3, 2, 2,
	2, 876, 3105, 3, 2, 2, 2, 878, 3109, 3, 2, 2, 2, 880, 3114, 3, 2, 2, 2,
	882, 3117, 3, 2, 2, 2, 884, 3120, 3, 2, 2, 2, 886, 3125, 3, 2, 2, 2, 888,
	3127, 3, 2, 2, 2, 890, 3129, 3, 2, 2, 2, 892, 893, 9, 2, 2, 2, 893, 3,
	3, 2, 2, 2, 894, 895, 9, 3, 2, 2, 895, 5, 3, 2, 2, 2, 896, 897, 9, 4, 2,
	2, 897, 7, 3, 2, 2, 2, 898, 903, 7, 229, 2, 2, 899, 903, 7, 3, 2, 2, 900,
	901, 7, 229, 2, 2, 901, 903, 7, 229, 2, 2, 902, 898, 3, 2, 2, 2, 902, 899,
	3, 2, 2, 2, 902, 900, 3, 2, 2, 2, 903, 9, 3, 2, 2, 2, 904, 905, 9, 5, 2,
	2, 905, 11, 3, 2, 2, 2, 906, 907, 9, 6, 2, 2, 907, 13, 3, 2, 2, 2, 908,
	909, 9, 7, 2, 2, 909, 15, 3, 2, 2, 2, 910, 911, 9, 8, 2, 2, 911, 17, 3,
	2, 2, 2, 912, 913, 5, 20, 11, 2, 913, 914, 7, 2, 2, 3, 914, 19, 3, 2, 2,
	2, 915, 917, 5, 28, 15, 2, 916, 915, 3, 2, 2, 2, 917, 920, 3, 2, 2, 2,
	918, 916, 3, 2, 2, 2, 918, 919, 3, 2, 2, 2, 919, 21, 3, 2, 2, 2, 920, 918,
	3, 2, 2, 2, 921, 925, 5, 26, 14, 2, 922, 925, 5, 24, 13, 2, 923, 925, 5,
	56, 29, 2, 924, 921, 3, 2, 2, 2, 924, 922, 3, 2, 2, 2, 924, 923, 3, 2,
	2, 2, 925, 23, 3, 2, 2, 2, 926, 927, 5, 860, 431, 2, 927, 25, 3, 2, 2,
	2, 928, 931, 5, 878, 440, 2, 929, 931, 5, 884, 443, 2, 930, 928, 3, 2,
	2, 2, 930, 929, 3, 2, 2, 2, 931, 27, 3, 2, 2, 2, 932, 954, 5, 22, 12, 2,
	933, 935, 5, 46, 24, 2, 934, 936, 5, 8, 5, 2, 935, 934, 3, 2, 2, 2, 935,
	936, 3, 2, 2, 2, 936, 954, 3, 2, 2, 2, 937, 939, 5, 30, 16, 2, 938, 940,
	5, 8, 5, 2, 939, 938, 3, 2, 2, 2, 939, 940, 3, 2, 2, 2, 940, 954, 3, 2,
	2, 2, 941, 943, 5, 274, 138, 2, 942, 944, 5, 8, 5, 2, 943, 942, 3, 2, 2,
	2, 943, 944, 3, 2, 2, 2, 944, 954, 3, 2, 2, 2, 945, 947, 5, 272, 137, 2,
	946, 948, 5, 8, 5, 2, 947, 946, 3, 2, 2, 2, 947, 948, 3, 2, 2, 2, 948,
	954, 3, 2, 2, 2, 949, 951, 5, 812, 407, 2, 950, 952, 5, 8, 5, 2, 951, 950,
	3, 2, 2, 2, 951, 952, 3, 2, 2, 2, 952, 954, 3, 2, 2, 2, 953, 932, 3, 2,
	2, 2, 953, 933, 3, 2, 2, 2, 953, 937, 3, 2, 2, 2, 953, 941, 3, 2, 2, 2,
	953, 945, 3, 2, 2, 2, 953, 949, 3, 2, 2, 2, 954, 29, 3, 2, 2, 2, 955, 956,
	5, 858, 430, 2, 956, 957, 5, 2, 2, 2, 957, 958, 5, 32, 17, 2, 958, 959,
	5, 34, 18, 2, 959, 960, 5, 8, 5, 2, 960, 961, 5, 40, 21, 2, 961, 963, 7,
	85, 2, 2, 962, 964, 5, 44, 23, 2, 963, 962, 3, 2, 2, 2, 963, 964, 3, 2,
	2, 2, 964, 31, 3, 2, 2, 2, 965, 966, 5, 868, 435, 2, 966, 33, 3, 2, 2,
	2, 967, 969, 5, 36, 19, 2, 968, 967, 3, 2, 2, 2, 968, 969, 3, 2, 2, 2,
	969, 971, 3, 2, 2, 2, 970, 972, 5, 38, 20, 2, 971, 970, 3, 2, 2, 2, 971,
	972, 3, 2, 2, 2, 972, 35, 3, 2, 2, 2, 973, 974, 7, 218, 2, 2, 974, 976,
	7, 223, 2, 2, 975, 977, 5, 88, 45, 2, 976, 975, 3, 2, 2, 2, 976, 977, 3,
	2, 2, 2, 977, 978, 3, 2, 2, 2, 978, 979, 7, 208, 2, 2, 979, 37, 3, 2, 2,
	2, 980, 982, 7, 223, 2, 2, 981, 983, 5, 130, 66, 2, 982, 981, 3, 2, 2,
	2, 982, 983, 3, 2, 2, 2, 983, 984, 3, 2, 2, 2, 984, 985, 7, 208, 2, 2,
	985, 39, 3, 2, 2, 2, 986, 988, 5, 42, 22, 2, 987, 986, 3, 2, 2, 2, 988,
	991, 3, 2, 2, 2, 989, 987, 3, 2, 2, 2, 989, 990, 3, 2, 2, 2, 990, 41, 3,
	2, 2, 2, 991, 989, 3, 2, 2, 2, 992, 1003, 5, 56, 29, 2, 993, 1003, 5, 60,
	31, 2, 994, 1003, 5, 64, 33, 2, 995, 1003, 5, 66, 34, 2, 996, 1003, 5,
	70, 36, 2, 997, 1003, 5, 74, 38, 2, 998, 1003, 5, 650, 326, 2, 999, 1003,
	5, 78, 40, 2, 1000, 1003, 5, 82, 42, 2, 1001, 1003, 5, 84, 43, 2, 1002,
	992, 3, 2, 2, 2, 1002, 993, 3, 2, 2, 2, 1002, 994, 3, 2, 2, 2, 1002, 995,
	3, 2, 2, 2, 1002, 996, 3, 2, 2, 2, 1002, 997, 3, 2, 2, 2, 1002, 998, 3,
	2, 2, 2, 1002, 999, 3, 2, 2, 2, 1002, 1000, 3, 2, 2, 2, 1002, 1001, 3,
	2, 2, 2, 1003, 43, 3, 2, 2, 2, 1004, 1005, 7, 209, 2, 2, 1005, 1006, 5,
	32, 17, 2, 1006, 45, 3, 2, 2, 2, 1007, 1008, 5, 858, 430, 2, 1008, 1009,
	7, 138, 2, 2, 1009, 1010, 5, 48, 25, 2, 1010, 1011, 5, 8, 5, 2, 1011, 1012,
	5, 52, 27, 2, 1012, 1014, 7, 86, 2, 2, 1013, 1015, 5, 50, 26, 2, 1014,
	1013, 3, 2, 2, 2, 1014, 1015, 3, 2, 2, 2, 1015, 47, 3, 2, 2, 2, 1016, 1017,
	5, 868, 435, 2, 1017, 49, 3, 2, 2, 2, 1018, 1019, 7, 209, 2, 2, 1019, 1020,
	5, 48, 25, 2, 1020, 51, 3, 2, 2, 2, 1021, 1023, 5, 54, 28, 2, 1022, 1021,
	3, 2, 2, 2, 1023, 1026, 3, 2, 2, 2, 1024, 1022, 3, 2, 2, 2, 1024, 1025,
	3, 2, 2, 2, 1025, 53, 3, 2, 2, 2, 1026, 1024, 3, 2, 2, 2, 1027, 1035, 5,
	56, 29, 2, 1028, 1035, 5, 60, 31, 2, 1029, 1035, 5, 66, 34, 2, 1030, 1035,
	5, 70, 36, 2, 1031, 1035, 5, 78, 40, 2, 1032, 1035, 5, 82, 42, 2, 1033,
	1035, 5, 84, 43, 2, 1034, 1027, 3, 2, 2, 2, 1034, 1028, 3, 2, 2, 2, 1034,
	1029, 3, 2, 2, 2, 1034, 1030, 3, 2, 2, 2, 1034, 1031, 3, 2, 2, 2, 1034,
	1032, 3, 2, 2, 2, 1034, 1033, 3, 2, 2, 2, 1035, 55, 3, 2, 2, 2, 1036, 1037,
	7, 105, 2, 2, 1037, 1038, 5, 48, 25, 2, 1038, 1039, 7, 214, 2, 2, 1039,
	1040, 7, 230, 2, 2, 1040, 1041, 5, 8, 5, 2, 1041, 1049, 3, 2, 2, 2, 1042,
	1043, 7, 105, 2, 2, 1043, 1044, 5, 48, 25, 2, 1044, 1045, 7, 214, 2, 2,
	1045, 1046, 5, 58, 30, 2, 1046, 1047, 5, 8, 5, 2, 1047, 1049, 3, 2, 2,
	2, 1048, 1036, 3, 2, 2, 2, 1048, 1042, 3, 2, 2, 2, 1049, 57, 3, 2, 2, 2,
	1050, 1051, 5, 868, 435, 2, 1051, 59, 3, 2, 2, 2, 1052, 1053, 5, 62, 32,
	2, 1053, 1054, 5, 8, 5, 2, 1054, 61, 3, 2, 2, 2, 1055, 1059, 5, 102, 52,
	2, 1056, 1059, 5, 104, 53, 2, 1057, 1059, 5, 106, 54, 2, 1058, 1055, 3,
	2, 2, 2, 1058, 1056, 3, 2, 2, 2, 1058, 1057, 3, 2, 2, 2, 1059, 63, 3, 2,
	2, 2, 1060, 1061, 5, 858, 430, 2, 1061, 1062, 5, 158, 80, 2, 1062, 1063,
	5, 8, 5, 2, 1063, 65, 3, 2, 2, 2, 1064, 1065, 5, 858, 430, 2, 1065, 1066,
	5, 68, 35, 2, 1066, 1067, 5, 8, 5, 2, 1067, 67, 3, 2, 2, 2, 1068, 1084,
	5, 242, 122, 2, 1069, 1084, 5, 244, 123, 2, 1070, 1084, 5, 246, 124, 2,
	1071, 1084, 5, 250, 126, 2, 1072, 1084, 5, 252, 127, 2, 1073, 1084, 5,
	254, 128, 2, 1074, 1084, 5, 256, 129, 2, 1075, 1084, 5, 258, 130, 2, 1076,
	1084, 5, 260, 131, 2, 1077, 1084, 5, 262, 132, 2, 1078, 1084, 5, 264, 133,
	2, 1079, 1084, 5, 266, 134, 2, 1080, 1084, 5, 268, 135, 2, 1081, 1084,
	5, 270, 136, 2, 1082, 1084, 5, 272, 137, 2, 1083, 1068, 3, 2, 2, 2, 1083,
	1069, 3, 2, 2, 2, 1083, 1070, 3, 2, 2, 2, 1083, 1071, 3, 2, 2, 2, 1083,
	1072, 3, 2, 2, 2, 1083, 1073, 3, 2, 2, 2, 1083, 1074, 3, 2, 2, 2, 1083,
	1075, 3, 2, 2, 2, 1083, 1076, 3, 2, 2, 2, 1083, 1077, 3, 2, 2, 2, 1083,
	1078, 3, 2, 2, 2, 1083, 1079, 3, 2, 2, 2, 1083, 1080, 3, 2, 2, 2, 1083,
	1081, 3, 2, 2, 2, 1083, 1082, 3, 2, 2, 2, 1084, 69, 3, 2, 2, 2, 1085, 1087,
	5, 72, 37, 2, 1086, 1088, 5, 8, 5, 2, 1087, 1086, 3, 2, 2, 2, 1087, 1088,
	3, 2, 2, 2, 1088, 71, 3, 2, 2, 2, 1089, 1092, 5, 292, 147, 2, 1090, 1092,
	5, 274, 138, 2, 1091, 1089, 3, 2, 2, 2, 1091, 1090, 3, 2, 2, 2, 1092, 73,
	3, 2, 2, 2, 1093, 1094, 5, 858, 430, 2, 1094, 1095, 5, 76, 39, 2, 1095,
	75, 3, 2, 2, 2, 1096, 1101, 5, 840, 421, 2, 1097, 1101, 5, 850, 426, 2,
	1098, 1101, 5, 852, 427, 2, 1099, 1101, 5, 856, 429, 2, 1100, 1096, 3,
	2, 2, 2, 1100, 1097, 3, 2, 2, 2, 1100, 1098, 3, 2, 2, 2, 1100, 1099, 3,
	2, 2, 2, 1101, 77, 3, 2, 2, 2, 1102, 1103, 5, 858, 430, 2, 1103, 1104,
	5, 80, 41, 2, 1104, 79, 3, 2, 2, 2, 1105, 1108, 5, 328, 165, 2, 1106, 1108,
	5, 384, 193, 2, 1107, 1105, 3, 2, 2, 2, 1107, 1106, 3, 2, 2, 2, 1108, 81,
	3, 2, 2, 2, 1109, 1117, 5, 878, 440, 2, 1110, 1111, 5, 880, 441, 2, 1111,
	1112, 5, 8, 5, 2, 1112, 1117, 3, 2, 2, 2, 1113, 1114, 5, 882, 442, 2, 1114,
	1115, 5, 8, 5, 2, 1115, 1117, 3, 2, 2, 2, 1116, 1109, 3, 2, 2, 2, 1116,
	1110, 3, 2, 2, 2, 1116, 1113, 3, 2, 2, 2, 1117, 83, 3, 2, 2, 2, 1118, 1123,
	5, 884, 443, 2, 1119, 1120, 5, 812, 407, 2, 1120, 1121, 5, 8, 5, 2, 1121,
	1123, 3, 2, 2, 2, 1122, 1118, 3, 2, 2, 2, 1122, 1119, 3, 2, 2, 2, 1123,
	85, 3, 2, 2, 2, 1124, 1125, 5, 8, 5, 2, 1125, 87, 3, 2, 2, 2, 1126, 1129,
	5, 90, 46, 2, 1127, 1129, 5, 96, 49, 2, 1128, 1126, 3, 2, 2, 2, 1128, 1127,
	3, 2, 2, 2, 1129, 89, 3, 2, 2, 2, 1130, 1131, 5, 102, 52, 2, 1131, 1132,
	5, 92, 47, 2, 1132, 91, 3, 2, 2, 2, 1133, 1135, 5, 94, 48, 2, 1134, 1133,
	3, 2, 2, 2, 1135, 1138, 3, 2, 2, 2, 1136, 1134, 3, 2, 2, 2, 1136, 1137,
	3, 2, 2, 2, 1137, 93, 3, 2, 2, 2, 1138, 1136, 3, 2, 2, 2, 1139, 1140, 7,
	210, 2, 2, 1140, 1141, 5, 102, 52, 2, 1141, 95, 3, 2, 2, 2, 1142, 1143,
	5, 222, 112, 2, 1143, 97, 3, 2, 2, 2, 1144, 1146, 9, 9, 2, 2, 1145, 1144,
	3, 2, 2, 2, 1145, 1146, 3, 2, 2, 2, 1146, 1148, 3, 2, 2, 2, 1147, 1149,
	5, 184, 93, 2, 1148, 1147, 3, 2, 2, 2, 1148, 1149, 3, 2, 2, 2, 1149, 1150,
	3, 2, 2, 2, 1150, 1151, 5, 232, 117, 2, 1151, 99, 3, 2, 2, 2, 1152, 1162,
	5, 98, 50, 2, 1153, 1162, 5, 246, 124, 2, 1154, 1162, 5, 252, 127, 2, 1155,
	1162, 5, 254, 128, 2, 1156, 1162, 5, 256, 129, 2, 1157, 1162, 5, 258, 130,
	2, 1158, 1162, 5, 260, 131, 2, 1159, 1162, 5, 266, 134, 2, 1160, 1162,
	5, 268, 135, 2, 1161, 1152, 3, 2, 2, 2, 1161, 1153, 3, 2, 2, 2, 1161, 1154,
	3, 2, 2, 2, 1161, 1155, 3, 2, 2, 2, 1161, 1156, 3, 2, 2, 2, 1161, 1157,
	3, 2, 2, 2, 1161, 1158, 3, 2, 2, 2, 1161, 1159, 3, 2, 2, 2, 1161, 1160,
	3, 2, 2, 2, 1162, 101, 3, 2, 2, 2, 1163, 1164, 7, 135, 2, 2, 1164, 1165,
	5, 100, 51, 2, 1165, 103, 3, 2, 2, 2, 1166, 1167, 7, 119, 2, 2, 1167, 1168,
	5, 100, 51, 2, 1168, 105, 3, 2, 2, 2, 1169, 1170, 7, 74, 2, 2, 1170, 1171,
	5, 100, 51, 2, 1171, 107, 3, 2, 2, 2, 1172, 1175, 5, 132, 67, 2, 1173,
	1175, 5, 110, 56, 2, 1174, 1172, 3, 2, 2, 2, 1174, 1173, 3, 2, 2, 2, 1175,
	109, 3, 2, 2, 2, 1176, 1179, 5, 112, 57, 2, 1177, 1179, 5, 118, 60, 2,
	1178, 1176, 3, 2, 2, 2, 1178, 1177, 3, 2, 2, 2, 1179, 111, 3, 2, 2, 2,
	1180, 1181, 5, 126, 64, 2, 1181, 1182, 5, 114, 58, 2, 1182, 113, 3, 2,
	2, 2, 1183, 1185, 5, 116, 59, 2, 1184, 1183, 3, 2, 2, 2, 1185, 1188, 3,
	2, 2, 2, 1186, 1184, 3, 2, 2, 2, 1186, 1187, 3, 2, 2, 2, 1187, 115, 3,
	2, 2, 2, 1188, 1186, 3, 2, 2, 2, 1189, 1190, 7, 210, 2, 2, 1190, 1191,
	5, 126, 64, 2, 1191, 117, 3, 2, 2, 2, 1192, 1193, 5, 120, 61, 2, 1193,
	119, 3, 2, 2, 2, 1194, 1196, 5, 124, 63, 2, 1195, 1194, 3, 2, 2, 2, 1196,
	1197, 3, 2, 2, 2, 1197, 1195, 3, 2, 2, 2, 1197, 1198, 3, 2, 2, 2, 1198,
	121, 3, 2, 2, 2, 1199, 1201, 5, 124, 63, 2, 1200, 1199, 3, 2, 2, 2, 1201,
	1204, 3, 2, 2, 2, 1202, 1200, 3, 2, 2, 2, 1202, 1203, 3, 2, 2, 2, 1203,
	123, 3, 2, 2, 2, 1204, 1202, 3, 2, 2, 2, 1205, 1206, 5, 126, 64, 2, 1206,
	1207, 5, 8, 5, 2, 1207, 125, 3, 2, 2, 2, 1208, 1209, 5, 858, 430, 2, 1209,
	1210, 5, 128, 65, 2, 1210, 127, 3, 2, 2, 2, 1211, 1217, 5, 172, 87, 2,
	1212, 1217, 5, 174, 88, 2, 1213, 1217, 5, 176, 89, 2, 1214, 1217, 5, 178,
	90, 2, 1215, 1217, 5, 170, 86, 2, 1216, 1211, 3, 2, 2, 2, 1216, 1212, 3,
	2, 2, 2, 1216, 1213, 3, 2, 2, 2, 1216, 1214, 3, 2, 2, 2, 1216, 1215, 3,
	2, 2, 2, 1217, 129, 3, 2, 2, 2, 1218, 1221, 5, 132, 67, 2, 1219, 1221,
	5, 140, 71, 2, 1220, 1218, 3, 2, 2, 2, 1220, 1219, 3, 2, 2, 2, 1221, 131,
	3, 2, 2, 2, 1222, 1223, 5, 138, 70, 2, 1223, 1225, 5, 134, 68, 2, 1224,
	1226, 7, 210, 2, 2, 1225, 1224, 3, 2, 2, 2, 1225, 1226, 3, 2, 2, 2, 1226,
	133, 3, 2, 2, 2, 1227, 1229, 5, 136, 69, 2, 1228, 1227, 3, 2, 2, 2, 1229,
	1232, 3, 2, 2, 2, 1230, 1228, 3, 2, 2, 2, 1230, 1231, 3, 2, 2, 2, 1231,
	135, 3, 2, 2, 2, 1232, 1230, 3, 2, 2, 2, 1233, 1234, 7, 210, 2, 2, 1234,
	1235, 5, 138, 70, 2, 1235, 137, 3, 2, 2, 2, 1236, 1237, 5, 868, 435, 2,
	1237, 139, 3, 2, 2, 2, 1238, 1241, 5, 142, 72, 2, 1239, 1241, 5, 148, 75,
	2, 1240, 1238, 3, 2, 2, 2, 1240, 1239, 3, 2, 2, 2, 1241, 141, 3, 2, 2,
	2, 1242, 1243, 5, 156, 79, 2, 1243, 1244, 5, 144, 73, 2, 1244, 143, 3,
	2, 2, 2, 1245, 1247, 5, 146, 74, 2, 1246, 1245, 3, 2, 2, 2, 1247, 1250,
	3, 2, 2, 2, 1248, 1246, 3, 2, 2, 2, 1248, 1249, 3, 2, 2, 2, 1249, 145,
	3, 2, 2, 2, 1250, 1248, 3, 2, 2, 2, 1251, 1252, 7, 210, 2, 2, 1252, 1253,
	5, 156, 79, 2, 1253, 147, 3, 2, 2, 2, 1254, 1255, 5, 150, 76, 2, 1255,
	149, 3, 2, 2, 2, 1256, 1258, 5, 154, 78, 2, 1257, 1256, 3, 2, 2, 2, 1258,
	1259, 3, 2, 2, 2, 1259, 1257, 3, 2, 2, 2, 1259, 1260, 3, 2, 2, 2, 1260,
	151, 3, 2, 2, 2, 1261, 1263, 5, 154, 78, 2, 1262, 1261, 3, 2, 2, 2, 1263,
	1266, 3, 2, 2, 2, 1264, 1262, 3, 2, 2, 2, 1264, 1265, 3, 2, 2, 2, 1265,
	153, 3, 2, 2, 2, 1266, 1264, 3, 2, 2, 2, 1267, 1268, 5, 156, 79, 2, 1268,
	1269, 5, 8, 5, 2, 1269, 155, 3, 2, 2, 2, 1270, 1271, 5, 858, 430, 2, 1271,
	1272, 5, 158, 80, 2, 1272, 157, 3, 2, 2, 2, 1273, 1278, 5, 172, 87, 2,
	1274, 1278, 5, 174, 88, 2, 1275, 1278, 5, 176, 89, 2, 1276, 1278, 5, 178,
	90, 2, 1277, 1273, 3, 2, 2, 2, 1277, 1274, 3, 2, 2, 2, 1277, 1275, 3, 2,
	2, 2, 1277, 1276, 3, 2, 2, 2, 1278, 159, 3, 2, 2, 2, 1279, 1281, 9, 9,
	2, 2, 1280, 1279, 3, 2, 2, 2, 1280, 1281, 3, 2, 2, 2, 1281, 1283, 3, 2,
	2, 2, 1282, 1284, 5, 184, 93, 2, 1283, 1282, 3, 2, 2, 2, 1283, 1284, 3,
	2, 2, 2, 1284, 1285, 3, 2, 2, 2, 1285, 1286, 5, 222, 112, 2, 1286, 161,
	3, 2, 2, 2, 1287, 1290, 5, 160, 81, 2, 1288, 1290, 5, 242, 122, 2, 1289,
	1287, 3, 2, 2, 2, 1289, 1288, 3, 2, 2, 2, 1290, 163, 3, 2, 2, 2, 1291,
	1303, 5, 160, 81, 2, 1292, 1303, 5, 242, 122, 2, 1293, 1303, 5, 244, 123,
	2, 1294, 1303, 5, 246, 124, 2, 1295, 1303, 5, 250, 126, 2, 1296, 1303,
	5, 254, 128, 2, 1297, 1303, 5, 252, 127, 2, 1298, 1303, 5, 256, 129, 2,
	1299, 1303, 5, 258, 130, 2, 1300, 1303, 5, 266, 134, 2, 1301, 1303, 5,
	268, 135, 2, 1302, 1291, 3, 2, 2, 2, 1302, 1292, 3, 2, 2, 2, 1302, 1293,
	3, 2, 2, 2, 1302, 1294, 3, 2, 2, 2, 1302, 1295, 3, 2, 2, 2, 1302, 1296,
	3, 2, 2, 2, 1302, 1297, 3, 2, 2, 2, 1302, 1298, 3, 2, 2, 2, 1302, 1299,
	3, 2, 2, 2, 1302, 1300, 3, 2, 2, 2, 1302, 1301, 3, 2, 2, 2, 1303, 165,
	3, 2, 2, 2, 1304, 1313, 5, 160, 81, 2, 1305, 1313, 5, 242, 122, 2, 1306,
	1313, 5, 244, 123, 2, 1307, 1313, 5, 246, 124, 2, 1308, 1313, 5, 252, 127,
	2, 1309, 1313, 5, 258, 130, 2, 1310, 1313, 5, 266, 134, 2, 1311, 1313,
	5, 268, 135, 2, 1312, 1304, 3, 2, 2, 2, 1312, 1305, 3, 2, 2, 2, 1312, 1306,
	3, 2, 2, 2, 1312, 1307, 3, 2, 2, 2, 1312, 1308, 3, 2, 2, 2, 1312, 1309,
	3, 2, 2, 2, 1312, 1310, 3, 2, 2, 2, 1312, 1311, 3, 2, 2, 2, 1313, 167,
	3, 2, 2, 2, 1314, 1323, 5, 160, 81, 2, 1315, 1323, 5, 242, 122, 2, 1316,
	1323, 5, 244, 123, 2, 1317, 1323, 5, 246, 124, 2, 1318, 1323, 5, 252, 127,
	2, 1319, 1323, 5, 258, 130, 2, 1320, 1323, 5, 266, 134, 2, 1321, 1323,
	5, 268, 135, 2, 1322, 1314, 3, 2, 2, 2, 1322, 1315, 3, 2, 2, 2, 1322, 1316,
	3, 2, 2, 2, 1322, 1317, 3, 2, 2, 2, 1322, 1318, 3, 2, 2, 2, 1322, 1319,
	3, 2, 2, 2, 1322, 1320, 3, 2, 2, 2, 1322, 1321, 3, 2, 2, 2, 1323, 169,
	3, 2, 2, 2, 1324, 1336, 5, 160, 81, 2, 1325, 1336, 5, 256, 129, 2, 1326,
	1336, 5, 242, 122, 2, 1327, 1336, 5, 244, 123, 2, 1328, 1336, 5, 246, 124,
	2, 1329, 1336, 5, 250, 126, 2, 1330, 1336, 5, 254, 128, 2, 1331, 1336,
	5, 252, 127, 2, 1332, 1336, 5, 258, 130, 2, 1333, 1336, 5, 266, 134, 2,
	1334, 1336, 5, 268, 135, 2, 1335, 1324, 3, 2, 2, 2, 1335, 1325, 3, 2, 2,
	2, 1335, 1326, 3, 2, 2, 2, 1335, 1327, 3, 2, 2, 2, 1335, 1328, 3, 2, 2,
	2, 1335, 1329, 3, 2, 2, 2, 1335, 1330, 3, 2, 2, 2, 1335, 1331, 3, 2, 2,
	2, 1335, 1332, 3, 2, 2, 2, 1335, 1333, 3, 2, 2, 2, 1335, 1334, 3, 2, 2,
	2, 1336, 171, 3, 2, 2, 2, 1337, 1338, 7, 108, 2, 2, 1338, 1339, 5, 162,
	82, 2, 1339, 173, 3, 2, 2, 2, 1340, 1341, 7, 109, 2, 2, 1341, 1342, 5,
	164, 83, 2, 1342, 175, 3, 2, 2, 2, 1343, 1344, 7, 134, 2, 2, 1344, 1345,
	5, 166, 84, 2, 1345, 177, 3, 2, 2, 2, 1346, 1347, 7, 151, 2, 2, 1347, 1348,
	5, 168, 85, 2, 1348, 179, 3, 2, 2, 2, 1349, 1350, 5, 182, 92, 2, 1350,
	181, 3, 2, 2, 2, 1351, 1352, 5, 868, 435, 2, 1352, 183, 3, 2, 2, 2, 1353,
	1355, 5, 188, 95, 2, 1354, 1353, 3, 2, 2, 2, 1355, 1356, 3, 2, 2, 2, 1356,
	1354, 3, 2, 2, 2, 1356, 1357, 3, 2, 2, 2, 1357, 185, 3, 2, 2, 2, 1358,
	1360, 5, 188, 95, 2, 1359, 1358, 3, 2, 2, 2, 1360, 1363, 3, 2, 2, 2, 1361,
	1359, 3, 2, 2, 2, 1361, 1362, 3, 2, 2, 2, 1362, 187, 3, 2, 2, 2, 1363,
	1361, 3, 2, 2, 2, 1364, 1365, 7, 220, 2, 2, 1365, 1366, 5, 190, 96, 2,
	1366, 1367, 7, 227, 2, 2, 1367, 189, 3, 2, 2, 2, 1368, 1373, 5, 192, 97,
	2, 1369, 1373, 5, 194, 98, 2, 1370, 1373, 5, 196, 99, 2, 1371, 1373, 5,
	198, 100, 2, 1372, 1368, 3, 2, 2, 2, 1372, 1369, 3, 2, 2, 2, 1372, 1370,
	3, 2, 2, 2, 1372, 1371, 3, 2, 2, 2, 1373, 191, 3, 2, 2, 2, 1374, 1378,
	5, 734, 368, 2, 1375, 1378, 7, 213, 2, 2, 1376, 1378, 7, 230, 2, 2, 1377,
	1374, 3, 2, 2, 2, 1377, 1375, 3, 2, 2, 2, 1377, 1376, 3, 2, 2, 2, 1378,
	193, 3, 2, 2, 2, 1379, 1380, 5, 200, 101, 2, 1380, 1381, 7, 209, 2, 2,
	1381, 1382, 5, 734, 368, 2, 1382, 195, 3, 2, 2, 2, 1383, 1384, 5, 200,
	101, 2, 1384, 1385, 7, 224, 2, 2, 1385, 1386, 5, 734, 368, 2, 1386, 197,
	3, 2, 2, 2, 1387, 1388, 5, 200, 101, 2, 1388, 1389, 7, 222, 2, 2, 1389,
	1390, 5, 734, 368, 2, 1390, 199, 3, 2, 2, 2, 1391, 1392, 5, 734, 368, 2,
	1392, 201, 3, 2, 2, 2, 1393, 1394, 9, 10, 2, 2, 1394, 203, 3, 2, 2, 2,
	1395, 1396, 7, 223, 2, 2, 1396, 1397, 5, 206, 104, 2, 1397, 1398, 7, 210,
	2, 2, 1398, 1399, 5, 208, 105, 2, 1399, 1400, 7, 208, 2, 2, 1400, 205,
	3, 2, 2, 2, 1401, 1406, 5, 210, 106, 2, 1402, 1406, 5, 212, 107, 2, 1403,
	1406, 5, 214, 108, 2, 1404, 1406, 5, 216, 109, 2, 1405, 1401, 3, 2, 2,
	2, 1405, 1402, 3, 2, 2, 2, 1405, 1403, 3, 2, 2, 2, 1405, 1404, 3, 2, 2,
	2, 1406, 207, 3, 2, 2, 2, 1407, 1412, 5, 210, 106, 2, 1408, 1412, 5, 212,
	107, 2, 1409, 1412, 5, 214, 108, 2, 1410, 1412, 5, 216, 109, 2, 1411, 1407,
	3, 2, 2, 2, 1411, 1408, 3, 2, 2, 2, 1411, 1409, 3, 2, 2, 2, 1411, 1410,
	3, 2, 2, 2, 1412, 209, 3, 2, 2, 2, 1413, 1414, 9, 11, 2, 2, 1414, 211,
	3, 2, 2, 2, 1415, 1416, 9, 12, 2, 2, 1416, 213, 3, 2, 2, 2, 1417, 1418,
	7, 100, 2, 2, 1418, 215, 3, 2, 2, 2, 1419, 1420, 7, 101, 2, 2, 1420, 217,
	3, 2, 2, 2, 1421, 1422, 7, 223, 2, 2, 1422, 1423, 5, 220, 111, 2, 1423,
	1424, 7, 208, 2, 2, 1424, 219, 3, 2, 2, 2, 1425, 1426, 9, 13, 2, 2, 1426,
	221, 3, 2, 2, 2, 1427, 1428, 5, 228, 115, 2, 1428, 1429, 5, 224, 113, 2,
	1429, 223, 3, 2, 2, 2, 1430, 1432, 5, 226, 114, 2, 1431, 1430, 3, 2, 2,
	2, 1432, 1435, 3, 2, 2, 2, 1433, 1431, 3, 2, 2, 2, 1433, 1434, 3, 2, 2,
	2, 1434, 225, 3, 2, 2, 2, 1435, 1433, 3, 2, 2, 2, 1436, 1437, 7, 210, 2,
	2, 1437, 1438, 5, 228, 115, 2, 1438, 227, 3, 2, 2, 2, 1439, 1441, 5, 230,
	116, 2, 1440, 1442, 5, 184, 93, 2, 1441, 1440, 3, 2, 2, 2, 1441, 1442,
	3, 2, 2, 2, 1442, 1445, 3, 2, 2, 2, 1443, 1444, 7, 215, 2, 2, 1444, 1446,
	5, 734, 368, 2, 1445, 1443, 3, 2, 2, 2, 1445, 1446, 3, 2, 2, 2, 1446, 229,
	3, 2, 2, 2, 1447, 1448, 5, 868, 435, 2, 1448, 231, 3, 2, 2, 2, 1449, 1450,
	5, 238, 120, 2, 1450, 1451, 5, 234, 118, 2, 1451, 233, 3, 2, 2, 2, 1452,
	1454, 5, 236, 119, 2, 1453, 1452, 3, 2, 2, 2, 1454, 1457, 3, 2, 2, 2, 1455,
	1453, 3, 2, 2, 2, 1455, 1456, 3, 2, 2, 2, 1456, 235, 3, 2, 2, 2, 1457,
	1455, 3, 2, 2, 2, 1458, 1459, 7, 210, 2, 2, 1459, 1460, 5, 238, 120, 2,
	1460, 237, 3, 2, 2, 2, 1461, 1463, 5, 240, 121, 2, 1462, 1464, 5, 184,
	93, 2, 1463, 1462, 3, 2, 2, 2, 1463, 1464, 3, 2, 2, 2, 1464, 1467, 3, 2,
	2, 2, 1465, 1466, 7, 215, 2, 2, 1466, 1468, 5, 734, 368, 2, 1467, 1465,
	3, 2, 2, 2, 1467, 1468, 3, 2, 2, 2, 1468, 239, 3, 2, 2, 2, 1469, 1470,
	5, 870, 436, 2, 1470, 241, 3, 2, 2, 2, 1471, 1473, 5, 202, 102, 2, 1472,
	1474, 5, 180, 91, 2, 1473, 1472, 3, 2, 2, 2, 1473, 1474, 3, 2, 2, 2, 1474,
	1476, 3, 2, 2, 2, 1475, 1477, 5, 204, 103, 2, 1476, 1475, 3, 2, 2, 2, 1476,
	1477, 3, 2, 2, 2, 1477, 1479, 3, 2, 2, 2, 1478, 1480, 5, 218, 110, 2, 1479,
	1478, 3, 2, 2, 2, 1479, 1480, 3, 2, 2, 2, 1480, 1482, 3, 2, 2, 2, 1481,
	1483, 9, 14, 2, 2, 1482, 1481, 3, 2, 2, 2, 1482, 1483, 3, 2, 2, 2, 1483,
	1485, 3, 2, 2, 2, 1484, 1486, 9, 9, 2, 2, 1485, 1484, 3, 2, 2, 2, 1485,
	1486, 3, 2, 2, 2, 1486, 1488, 3, 2, 2, 2, 1487, 1489, 5, 184, 93, 2, 1488,
	1487, 3, 2, 2, 2, 1488, 1489, 3, 2, 2, 2, 1489, 1491, 3, 2, 2, 2, 1490,
	1492, 5, 368, 185, 2, 1491, 1490, 3, 2, 2, 2, 1491, 1492, 3, 2, 2, 2, 1492,
	1493, 3, 2, 2, 2, 1493, 1494, 5, 222, 112, 2, 1494, 243, 3, 2, 2, 2, 1495,
	1497, 7, 152, 2, 2, 1496, 1498, 9, 9, 2, 2, 1497, 1496, 3, 2, 2, 2, 1497,
	1498, 3, 2, 2, 2, 1498, 1500, 3, 2, 2, 2, 1499, 1501, 5, 184, 93, 2, 1500,
	1499, 3, 2, 2, 2, 1500, 1501, 3, 2, 2, 2, 1501, 1502, 3, 2, 2, 2, 1502,
	1503, 5, 222, 112, 2, 1503, 245, 3, 2, 2, 2, 1504, 1506, 7, 120, 2, 2,
	1505, 1507, 9, 9, 2, 2, 1506, 1505, 3, 2, 2, 2, 1506, 1507, 3, 2, 2, 2,
	1507, 1509, 3, 2, 2, 2, 1508, 1510, 5, 184, 93, 2, 1509, 1508, 3, 2, 2,
	2, 1509, 1510, 3, 2, 2, 2, 1510, 1511, 3, 2, 2, 2, 1511, 1512, 5, 222,
	112, 2, 1512, 247, 3, 2, 2, 2, 1513, 1514, 9, 15, 2, 2, 1514, 249, 3, 2,
	2, 2, 1515, 1517, 5, 248, 125, 2, 1516, 1518, 9, 9, 2, 2, 1517, 1516, 3,
	2, 2, 2, 1517, 1518, 3, 2, 2, 2, 1518, 1520, 3, 2, 2, 2, 1519, 1521, 5,
	184, 93, 2, 1520, 1519, 3, 2, 2, 2, 1520, 1521, 3, 2, 2, 2, 1521, 1522,
	3, 2, 2, 2, 1522, 1523, 5, 222, 112, 2, 1523, 251, 3, 2, 2, 2, 1524, 1526,
	7, 57, 2, 2, 1525, 1524, 3, 2, 2, 2, 1525, 1526, 3, 2, 2, 2, 1526, 1527,
	3, 2, 2, 2, 1527, 1529, 7, 112, 2, 2, 1528, 1530, 9, 9, 2, 2, 1529, 1528,
	3, 2, 2, 2, 1529, 1530, 3, 2, 2, 2, 1530, 1531, 3, 2, 2, 2, 1531, 1532,
	5, 222, 112, 2, 1532, 253, 3, 2, 2, 2, 1533, 1535, 9, 16, 2, 2, 1534, 1533,
	3, 2, 2, 2, 1534, 1535, 3, 2, 2, 2, 1535, 1536, 3, 2, 2, 2, 1536, 1538,
	7, 111, 2, 2, 1537, 1539, 9, 9, 2, 2, 1538, 1537, 3, 2, 2, 2, 1538, 1539,
	3, 2, 2, 2, 1539, 1540, 3, 2, 2, 2, 1540, 1541, 5, 222, 112, 2, 1541, 255,
	3, 2, 2, 2, 1542, 1543, 7, 149, 2, 2, 1543, 1544, 5, 222, 112, 2, 1544,
	257, 3, 2, 2, 2, 1545, 1546, 7, 176, 2, 2, 1546, 1547, 5, 222, 112, 2,
	1547, 259, 3, 2, 2, 2, 1548, 1549, 7, 150, 2, 2, 1549, 1550, 5, 222, 112,
	2, 1550, 261, 3, 2, 2, 2, 1551, 1552, 7, 91, 2, 2, 1552, 1553, 5, 222,
	112, 2, 1553, 263, 3, 2, 2, 2, 1554, 1555, 7, 99, 2, 2, 1555, 1556, 5,
	222, 112, 2, 1556, 265, 3, 2, 2, 2, 1557, 1559, 7, 57, 2, 2, 1558, 1557,
	3, 2, 2, 2, 1558, 1559, 3, 2, 2, 2, 1559, 1560, 3, 2, 2, 2, 1560, 1562,
	5, 180, 91, 2, 1561, 1563, 5, 188, 95, 2, 1562, 1561, 3, 2, 2, 2, 1562,
	1563, 3, 2, 2, 2, 1563, 1564, 3, 2, 2, 2, 1564, 1565, 5, 222, 112, 2, 1565,
	267, 3, 2, 2, 2, 1566, 1567, 7, 168, 2, 2, 1567, 1568, 5, 222, 112, 2,
	1568, 269, 3, 2, 2, 2, 1569, 1570, 5, 312, 157, 2, 1570, 1571, 5, 222,
	112, 2, 1571, 271, 3, 2, 2, 2, 1572, 1573, 5, 326, 164, 2, 1573, 1574,
	5, 222, 112, 2, 1574, 273, 3, 2, 2, 2, 1575, 1577, 7, 97, 2, 2, 1576, 1578,
	7, 57, 2, 2, 1577, 1576, 3, 2, 2, 2, 1577, 1578, 3, 2, 2, 2, 1578, 1580,
	3, 2, 2, 2, 1579, 1581, 9, 9, 2, 2, 1580, 1579, 3, 2, 2, 2, 1580, 1581,
	3, 2, 2, 2, 1581, 1583, 3, 2, 2, 2, 1582, 1584, 5, 276, 139, 2, 1583, 1582,
	3, 2, 2, 2, 1583, 1584, 3, 2, 2, 2, 1584, 1586, 3, 2, 2, 2, 1585, 1587,
	5, 188, 95, 2, 1586, 1585, 3, 2, 2, 2, 1586, 1587, 3, 2, 2, 2, 1587, 1588,
	3, 2, 2, 2, 1588, 1590, 5, 278, 140, 2, 1589, 1591, 5, 280, 141, 2, 1590,
	1589, 3, 2, 2, 2, 1590, 1591, 3, 2, 2, 2, 1591, 1592, 3, 2, 2, 2, 1592,
	1593, 5, 8, 5, 2, 1593, 1594, 5, 282, 142, 2, 1594, 1595, 5, 288, 145,
	2, 1595, 1597, 7, 83, 2, 2, 1596, 1598, 5, 290, 146, 2, 1597, 1596, 3,
	2, 2, 2, 1597, 1598, 3, 2, 2, 2, 1598, 275, 3, 2, 2, 2, 1599, 1610, 7,
	120, 2, 2, 1600, 1610, 7, 112, 2, 2, 1601, 1610, 7, 111, 2, 2, 1602, 1610,
	7, 149, 2, 2, 1603, 1610, 7, 150, 2, 2, 1604, 1610, 7, 176, 2, 2, 1605,
	1610, 7, 152, 2, 2, 1606, 1610, 7, 168, 2, 2, 1607, 1610, 5, 248, 125,
	2, 1608, 1610, 5, 180, 91, 2, 1609, 1599, 3, 2, 2, 2, 1609, 1600, 3, 2,
	2, 2, 1609, 1601, 3, 2, 2, 2, 1609, 1602, 3, 2, 2, 2, 1609, 1603, 3, 2,
	2, 2, 1609, 1604, 3, 2, 2, 2, 1609, 1605, 3, 2, 2, 2, 1609, 1606, 3, 2,
	2, 2, 1609, 1607, 3, 2, 2, 2, 1609, 1608, 3, 2, 2, 2, 1610, 277, 3, 2,
	2, 2, 1611, 1612, 5, 868, 435, 2, 1612, 279, 3, 2, 2, 2, 1613, 1615, 7,
	223, 2, 2, 1614, 1616, 5, 108, 55, 2, 1615, 1614, 3, 2, 2, 2, 1615, 1616,
	3, 2, 2, 2, 1616, 1617, 3, 2, 2, 2, 1617, 1618, 7, 208, 2, 2, 1618, 281,
	3, 2, 2, 2, 1619, 1621, 5, 284, 143, 2, 1620, 1619, 3, 2, 2, 2, 1621, 1624,
	3, 2, 2, 2, 1622, 1620, 3, 2, 2, 2, 1622, 1623, 3, 2, 2, 2, 1623, 283,
	3, 2, 2, 2, 1624, 1622, 3, 2, 2, 2, 1625, 1626, 5, 286, 144, 2, 1626, 1627,
	5, 8, 5, 2, 1627, 285, 3, 2, 2, 2, 1628, 1631, 5, 836, 419, 2, 1629, 1631,
	5, 158, 80, 2, 1630, 1628, 3, 2, 2, 2, 1630, 1629, 3, 2, 2, 2, 1631, 287,
	3, 2, 2, 2, 1632, 1633, 5, 522, 262, 2, 1633, 289, 3, 2, 2, 2, 1634, 1635,
	7, 209, 2, 2, 1635, 1636, 5, 278, 140, 2, 1636, 291, 3, 2, 2, 2, 1637,
	1639, 7, 174, 2, 2, 1638, 1640, 7, 57, 2, 2, 1639, 1638, 3, 2, 2, 2, 1639,
	1640, 3, 2, 2, 2, 1640, 1641, 3, 2, 2, 2, 1641, 1643, 5, 294, 148, 2, 1642,
	1644, 5, 296, 149, 2, 1643, 1642, 3, 2, 2, 2, 1643, 1644, 3, 2, 2, 2, 1644,
	1645, 3, 2, 2, 2, 1645, 1646, 5, 8, 5, 2, 1646, 1647, 5, 302, 152, 2, 1647,
	1648, 5, 304, 153, 2, 1648, 1649, 7, 89, 2, 2, 1649, 293, 3, 2, 2, 2, 1650,
	1651, 5, 868, 435, 2, 1651, 295, 3, 2, 2, 2, 1652, 1654, 7, 223, 2, 2,
	1653, 1655, 5, 108, 55, 2, 1654, 1653, 3, 2, 2, 2, 1654, 1655, 3, 2, 2,
	2, 1655, 1656, 3, 2, 2, 2, 1656, 1657, 7, 208, 2, 2, 1657, 297, 3, 2, 2,
	2, 1658, 1659, 5, 300, 151, 2, 1659, 1660, 5, 8, 5, 2, 1660, 299, 3, 2,
	2, 2, 1661, 1664, 5, 836, 419, 2, 1662, 1664, 5, 158, 80, 2, 1663, 1661,
	3, 2, 2, 2, 1663, 1662, 3, 2, 2, 2, 1664, 301, 3, 2, 2, 2, 1665, 1667,
	5, 298, 150, 2, 1666, 1665, 3, 2, 2, 2, 1667, 1670, 3, 2, 2, 2, 1668, 1666,
	3, 2, 2, 2, 1668, 1669, 3, 2, 2, 2, 1669, 303, 3, 2, 2, 2, 1670, 1668,
	3, 2, 2, 2, 1671, 1672, 5, 522, 262, 2, 1672, 305, 3, 2, 2, 2, 1673, 1674,
	5, 310, 156, 2, 1674, 1675, 5, 8, 5, 2, 1675, 307, 3, 2, 2, 2, 1676, 1678,
	5, 306, 154, 2, 1677, 1676, 3, 2, 2, 2, 1678, 1681, 3, 2, 2, 2, 1679, 1677,
	3, 2, 2, 2, 1679, 1680, 3, 2, 2, 2, 1680, 309, 3, 2, 2, 2, 1681, 1679,
	3, 2, 2, 2, 1682, 1689, 5, 246, 124, 2, 1683, 1689, 5, 250, 126, 2, 1684,
	1689, 5, 254, 128, 2, 1685, 1689, 5, 252, 127, 2, 1686, 1689, 5, 266, 134,
	2, 1687, 1689, 5, 258, 130, 2, 1688, 1682, 3, 2, 2, 2, 1688, 1683, 3, 2,
	2, 2, 1688, 1684, 3, 2, 2, 2, 1688, 1685, 3, 2, 2, 2, 1688, 1686, 3, 2,
	2, 2, 1688, 1687, 3, 2, 2, 2, 1689, 311, 3, 2, 2, 2, 1690, 1692, 5, 4,
	3, 2, 1691, 1693, 7, 139, 2, 2, 1692, 1691, 3, 2, 2, 2, 1692, 1693, 3,
	2, 2, 2, 1693, 1694, 3, 2, 2, 2, 1694, 1695, 7, 221, 2, 2, 1695, 1696,
	5, 308, 155, 2, 1696, 1697, 7, 228, 2, 2, 1697, 313, 3, 2, 2, 2, 1698,
	1703, 7, 112, 2, 2, 1699, 1703, 7, 120, 2, 2, 1700, 1703, 5, 248, 125,
	2, 1701, 1703, 7, 111, 2, 2, 1702, 1698, 3, 2, 2, 2, 1702, 1699, 3, 2,
	2, 2, 1702, 1700, 3, 2, 2, 2, 1702, 1701, 3, 2, 2, 2, 1703, 315, 3, 2,
	2, 2, 1704, 1705, 5, 318, 160, 2, 1705, 1706, 5, 322, 162, 2, 1706, 317,
	3, 2, 2, 2, 1707, 1713, 5, 320, 161, 2, 1708, 1709, 5, 320, 161, 2, 1709,
	1710, 7, 215, 2, 2, 1710, 1711, 5, 734, 368, 2, 1711, 1713, 3, 2, 2, 2,
	1712, 1707, 3, 2, 2, 2, 1712, 1708, 3, 2, 2, 2, 1713, 319, 3, 2, 2, 2,
	1714, 1715, 5, 868, 435, 2, 1715, 321, 3, 2, 2, 2, 1716, 1718, 5, 324,
	163, 2, 1717, 1716, 3, 2, 2, 2, 1718, 1721, 3, 2, 2, 2, 1719, 1717, 3,
	2, 2, 2, 1719, 1720, 3, 2, 2, 2, 1720, 323, 3, 2, 2, 2, 1721, 1719, 3,
	2, 2, 2, 1722, 1723, 7, 210, 2, 2, 1723, 1724, 5, 318, 160, 2, 1724, 325,
	3, 2, 2, 2, 1725, 1727, 7, 90, 2, 2, 1726, 1728, 5, 314, 158, 2, 1727,
	1726, 3, 2, 2, 2, 1727, 1728, 3, 2, 2, 2, 1728, 1730, 3, 2, 2, 2, 1729,
	1731, 9, 9, 2, 2, 1730, 1729, 3, 2, 2, 2, 1730, 1731, 3, 2, 2, 2, 1731,
	1733, 3, 2, 2, 2, 1732, 1734, 5, 188, 95, 2, 1733, 1732, 3, 2, 2, 2, 1733,
	1734, 3, 2, 2, 2, 1734, 1735, 3, 2, 2, 2, 1735, 1736, 7, 221, 2, 2, 1736,
	1737, 5, 316, 159, 2, 1737, 1738, 7, 228, 2, 2, 1738, 327, 3, 2, 2, 2,
	1739, 1741, 5, 32, 17, 2, 1740, 1742, 5, 330, 166, 2, 1741, 1740, 3, 2,
	2, 2, 1741, 1742, 3, 2, 2, 2, 1742, 1743, 3, 2, 2, 2, 1743, 1744, 5, 350,
	176, 2, 1744, 1745, 5, 8, 5, 2, 1745, 329, 3, 2, 2, 2, 1746, 1747, 7, 218,
	2, 2, 1747, 1749, 7, 223, 2, 2, 1748, 1750, 5, 332, 167, 2, 1749, 1748,
	3, 2, 2, 2, 1749, 1750, 3, 2, 2, 2, 1750, 1751, 3, 2, 2, 2, 1751, 1752,
	7, 208, 2, 2, 1752, 331, 3, 2, 2, 2, 1753, 1756, 5, 334, 168, 2, 1754,
	1756, 5, 342, 172, 2, 1755, 1753, 3, 2, 2, 2, 1755, 1754, 3, 2, 2, 2, 1756,
	333, 3, 2, 2, 2, 1757, 1758, 5, 340, 171, 2, 1758, 1759, 5, 336, 169, 2,
	1759, 335, 3, 2, 2, 2, 1760, 1762, 5, 338, 170, 2, 1761, 1760, 3, 2, 2,
	2, 1762, 1765, 3, 2, 2, 2, 1763, 1761, 3, 2, 2, 2, 1763, 1764, 3, 2, 2,
	2, 1764, 337, 3, 2, 2, 2, 1765, 1763, 3, 2, 2, 2, 1766, 1768, 7, 210, 2,
	2, 1767, 1769, 5, 340, 171, 2, 1768, 1767, 3, 2, 2, 2, 1768, 1769, 3, 2,
	2, 2, 1769, 339, 3, 2, 2, 2, 1770, 1771, 5, 734, 368, 2, 1771, 341, 3,
	2, 2, 2, 1772, 1773, 5, 348, 175, 2, 1773, 1774, 5, 344, 173, 2, 1774,
	343, 3, 2, 2, 2, 1775, 1777, 5, 346, 174, 2, 1776, 1775, 3, 2, 2, 2, 1777,
	1780, 3, 2, 2, 2, 1778, 1776, 3, 2, 2, 2, 1778, 1779, 3, 2, 2, 2, 1779,
	345, 3, 2, 2, 2, 1780, 1778, 3, 2, 2, 2, 1781, 1782, 7, 210, 2, 2, 1782,
	1783, 5, 348, 175, 2, 1783, 347, 3, 2, 2, 2, 1784, 1785, 7, 212, 2, 2,
	1785, 1791, 5, 868, 435, 2, 1786, 1788, 7, 223, 2, 2, 1787, 1789, 5, 734,
	368, 2, 1788, 1787, 3, 2, 2, 2, 1788, 1789, 3, 2, 2, 2, 1789, 1790, 3,
	2, 2, 2, 1790, 1792, 7, 208, 2, 2, 1791, 1786, 3, 2, 2, 2, 1791, 1792,
	3, 2, 2, 2, 1792, 1796, 3, 2, 2, 2, 1793, 1794, 7, 212, 2, 2, 1794, 1796,
	7, 230, 2, 2, 1795, 1784, 3, 2, 2, 2, 1795, 1793, 3, 2, 2, 2, 1796, 349,
	3, 2, 2, 2, 1797, 1798, 5, 356, 179, 2, 1798, 1799, 5, 352, 177, 2, 1799,
	351, 3, 2, 2, 2, 1800, 1802, 5, 354, 178, 2, 1801, 1800, 3, 2, 2, 2, 1802,
	1805, 3, 2, 2, 2, 1803, 1801, 3, 2, 2, 2, 1803, 1804, 3, 2, 2, 2, 1804,
	353, 3, 2, 2, 2, 1805, 1803, 3, 2, 2, 2, 1806, 1807, 7, 210, 2, 2, 1807,
	1808, 5, 356, 179, 2, 1808, 355, 3, 2, 2, 2, 1809, 1811, 5, 358, 180, 2,
	1810, 1812, 5, 366, 184, 2, 1811, 1810, 3, 2, 2, 2, 1811, 1812, 3, 2, 2,
	2, 1812, 357, 3, 2, 2, 2, 1813, 1814, 5, 360, 181, 2, 1814, 359, 3, 2,
	2, 2, 1815, 1818, 5, 362, 182, 2, 1816, 1818, 5, 364, 183, 2, 1817, 1815,
	3, 2, 2, 2, 1817, 1816, 3, 2, 2, 2, 1818, 361, 3, 2, 2, 2, 1819, 1821,
	7, 205, 2, 2, 1820, 1822, 5, 188, 95, 2, 1821, 1820, 3, 2, 2, 2, 1821,
	1822, 3, 2, 2, 2, 1822, 363, 3, 2, 2, 2, 1823, 1825, 7, 204, 2, 2, 1824,
	1826, 5, 188, 95, 2, 1825, 1824, 3, 2, 2, 2, 1825, 1826, 3, 2, 2, 2, 1826,
	365, 3, 2, 2, 2, 1827, 1829, 7, 223, 2, 2, 1828, 1830, 5, 332, 167, 2,
	1829, 1828, 3, 2, 2, 2, 1829, 1830, 3, 2, 2, 2, 1830, 1831, 3, 2, 2, 2,
	1831, 1832, 7, 208, 2, 2, 1832, 367, 3, 2, 2, 2, 1833, 1834, 7, 218, 2,
	2, 1834, 1841, 5, 376, 189, 2, 1835, 1836, 7, 218, 2, 2, 1836, 1837, 7,
	223, 2, 2, 1837, 1838, 5, 370, 186, 2, 1838, 1839, 7, 208, 2, 2, 1839,
	1841, 3, 2, 2, 2, 1840, 1833, 3, 2, 2, 2, 1840, 1835, 3, 2, 2, 2, 1841,
	369, 3, 2, 2, 2, 1842, 1843, 5, 376, 189, 2, 1843, 1844, 5, 372, 187, 2,
	1844, 371, 3, 2, 2, 2, 1845, 1847, 5, 374, 188, 2, 1846, 1845, 3, 2, 2,
	2, 1847, 1850, 3, 2, 2, 2, 1848, 1846, 3, 2, 2, 2, 1848, 1849, 3, 2, 2,
	2, 1849, 373, 3, 2, 2, 2, 1850, 1848, 3, 2, 2, 2, 1851, 1852, 7, 210, 2,
	2, 1852, 1853, 5, 376, 189, 2, 1853, 375, 3, 2, 2, 2, 1854, 1855, 5, 734,
	368, 2, 1855, 377, 3, 2, 2, 2, 1856, 1857, 7, 223, 2, 2, 1857, 1858, 5,
	210, 106, 2, 1858, 1859, 7, 210, 2, 2, 1859, 1860, 5, 212, 107, 2, 1860,
	1861, 7, 208, 2, 2, 1861, 1873, 3, 2, 2, 2, 1862, 1863, 7, 223, 2, 2, 1863,
	1864, 5, 212, 107, 2, 1864, 1865, 7, 210, 2, 2, 1865, 1866, 5, 210, 106,
	2, 1866, 1867, 7, 208, 2, 2, 1867, 1873, 3, 2, 2, 2, 1868, 1869, 7, 223,
	2, 2, 1869, 1870, 5, 210, 106, 2, 1870, 1871, 7, 208, 2, 2, 1871, 1873,
	3, 2, 2, 2, 1872, 1856, 3, 2, 2, 2, 1872, 1862, 3, 2, 2, 2, 1872, 1868,
	3, 2, 2, 2, 1873, 379, 3, 2, 2, 2, 1874, 1875, 7, 223, 2, 2, 1875, 1876,
	5, 210, 106, 2, 1876, 1877, 7, 210, 2, 2, 1877, 1878, 5, 212, 107, 2, 1878,
	1879, 7, 208, 2, 2, 1879, 1891, 3, 2, 2, 2, 1880, 1881, 7, 223, 2, 2, 1881,
	1882, 5, 212, 107, 2, 1882, 1883, 7, 210, 2, 2, 1883, 1884, 5, 210, 106,
	2, 1884, 1885, 7, 208, 2, 2, 1885, 1891, 3, 2, 2, 2, 1886, 1887, 7, 223,
	2, 2, 1887, 1888, 5, 212, 107, 2, 1888, 1889, 7, 208, 2, 2, 1889, 1891,
	3, 2, 2, 2, 1890, 1874, 3, 2, 2, 2, 1890, 1880, 3, 2, 2, 2, 1890, 1886,
	3, 2, 2, 2, 1891, 381, 3, 2, 2, 2, 1892, 1893, 5, 360, 181, 2, 1893, 383,
	3, 2, 2, 2, 1894, 1904, 5, 408, 205, 2, 1895, 1904, 5, 406, 204, 2, 1896,
	1904, 5, 414, 208, 2, 1897, 1904, 5, 400, 201, 2, 1898, 1904, 5, 402, 202,
	2, 1899, 1904, 5, 404, 203, 2, 1900, 1904, 5, 412, 207, 2, 1901, 1904,
	5, 410, 206, 2, 1902, 1904, 5, 416, 209, 2, 1903, 1894, 3, 2, 2, 2, 1903,
	1895, 3, 2, 2, 2, 1903, 1896, 3, 2, 2, 2, 1903, 1897, 3, 2, 2, 2, 1903,
	1898, 3, 2, 2, 2, 1903, 1899, 3, 2, 2, 2, 1903, 1900, 3, 2, 2, 2, 1903,
	1901, 3, 2, 2, 2, 1903, 1902, 3, 2, 2, 2, 1904, 385, 3, 2, 2, 2, 1905,
	1906, 9, 17, 2, 2, 1906, 387, 3, 2, 2, 2, 1907, 1908, 9, 18, 2, 2, 1908,
	389, 3, 2, 2, 2, 1909, 1910, 9, 19, 2, 2, 1910, 391, 3, 2, 2, 2, 1911,
	1912, 9, 20, 2, 2, 1912, 393, 3, 2, 2, 2, 1913, 1914, 9, 21, 2, 2, 1914,
	395, 3, 2, 2, 2, 1915, 1916, 9, 22, 2, 2, 1916, 397, 3, 2, 2, 2, 1917,
	1918, 9, 23, 2, 2, 1918, 399, 3, 2, 2, 2, 1919, 1921, 7, 145, 2, 2, 1920,
	1922, 5, 378, 190, 2, 1921, 1920, 3, 2, 2, 2, 1921, 1922, 3, 2, 2, 2, 1922,
	1923, 3, 2, 2, 2, 1923, 1924, 5, 418, 210, 2, 1924, 1925, 5, 8, 5, 2, 1925,
	401, 3, 2, 2, 2, 1926, 1928, 7, 144, 2, 2, 1927, 1929, 5, 380, 191, 2,
	1928, 1927, 3, 2, 2, 2, 1928, 1929, 3, 2, 2, 2, 1929, 1930, 3, 2, 2, 2,
	1930, 1931, 5, 418, 210, 2, 1931, 1932, 5, 8, 5, 2, 1932, 403, 3, 2, 2,
	2, 1933, 1935, 5, 386, 194, 2, 1934, 1936, 5, 204, 103, 2, 1935, 1934,
	3, 2, 2, 2, 1935, 1936, 3, 2, 2, 2, 1936, 1938, 3, 2, 2, 2, 1937, 1939,
	5, 368, 185, 2, 1938, 1937, 3, 2, 2, 2, 1938, 1939, 3, 2, 2, 2, 1939, 1940,
	3, 2, 2, 2, 1940, 1941, 5, 420, 211, 2, 1941, 1942, 5, 8, 5, 2, 1942, 405,
	3, 2, 2, 2, 1943, 1945, 5, 388, 195, 2, 1944, 1946, 5, 368, 185, 2, 1945,
	1944, 3, 2, 2, 2, 1945, 1946, 3, 2, 2, 2, 1946, 1947, 3, 2, 2, 2, 1947,
	1948, 5, 422, 212, 2, 1948, 1949, 5, 8, 5, 2, 1949, 407, 3, 2, 2, 2, 1950,
	1952, 5, 390, 196, 2, 1951, 1953, 5, 368, 185, 2, 1952, 1951, 3, 2, 2,
	2, 1952, 1953, 3, 2, 2, 2, 1953, 1954, 3, 2, 2, 2, 1954, 1955, 5, 424,
	213, 2, 1955, 1956, 5, 8, 5, 2, 1956, 409, 3, 2, 2, 2, 1957, 1959, 5, 392,
	197, 2, 1958, 1960, 5, 204, 103, 2, 1959, 1958, 3, 2, 2, 2, 1959, 1960,
	3, 2, 2, 2, 1960, 1962, 3, 2, 2, 2, 1961, 1963, 5, 368, 185, 2, 1962, 1961,
	3, 2, 2, 2, 1962, 1963, 3, 2, 2, 2, 1963, 1964, 3, 2, 2, 2, 1964, 1965,
	5, 428, 215, 2, 1965, 1966, 5, 8, 5, 2, 1966, 411, 3, 2, 2, 2, 1967, 1969,
	5, 394, 198, 2, 1968, 1970, 5, 204, 103, 2, 1969, 1968, 3, 2, 2, 2, 1969,
	1970, 3, 2, 2, 2, 1970, 1972, 3, 2, 2, 2, 1971, 1973, 5, 368, 185, 2, 1972,
	1971, 3, 2, 2, 2, 1972, 1973, 3, 2, 2, 2, 1973, 1974, 3, 2, 2, 2, 1974,
	1975, 5, 426, 214, 2, 1975, 1976, 5, 8, 5, 2, 1976, 413, 3, 2, 2, 2, 1977,
	1978, 5, 396, 199, 2, 1978, 1979, 5, 430, 216, 2, 1979, 1980, 5, 8, 5,
	2, 1980, 415, 3, 2, 2, 2, 1981, 1983, 5, 398, 200, 2, 1982, 1984, 5, 368,
	185, 2, 1983, 1982, 3, 2, 2, 2, 1983, 1984, 3, 2, 2, 2, 1984, 1985, 3,
	2, 2, 2, 1985, 1986, 5, 432, 217, 2, 1986, 1987, 5, 8, 5, 2, 1987, 417,
	3, 2, 2, 2, 1988, 1989, 5, 466, 234, 2, 1989, 1990, 5, 434, 218, 2, 1990,
	419, 3, 2, 2, 2, 1991, 1992, 5, 468, 235, 2, 1992, 1993, 5, 436, 219, 2,
	1993, 421, 3, 2, 2, 2, 1994, 1995, 5, 470, 236, 2, 1995, 1996, 5, 438,
	220, 2, 1996, 423, 3, 2, 2, 2, 1997, 1998, 5, 472, 237, 2, 1998, 1999,
	5, 440, 221, 2, 1999, 425, 3, 2, 2, 2, 2000, 2001, 5, 474, 238, 2, 2001,
	2002, 5, 442, 222, 2, 2002, 427, 3, 2, 2, 2, 2003, 2004, 5, 476, 239, 2,
	2004, 2005, 5, 444, 223, 2, 2005, 429, 3, 2, 2, 2, 2006, 2007, 5, 478,
	240, 2, 2007, 2008, 5, 446, 224, 2, 2008, 431, 3, 2, 2, 2, 2009, 2010,
	5, 480, 241, 2, 2010, 2011, 5, 448, 225, 2, 2011, 433, 3, 2, 2, 2, 2012,
	2014, 5, 450, 226, 2, 2013, 2012, 3, 2, 2, 2, 2014, 2017, 3, 2, 2, 2, 2015,
	2013, 3, 2, 2, 2, 2015, 2016, 3, 2, 2, 2, 2016, 435, 3, 2, 2, 2, 2017,
	2015, 3, 2, 2, 2, 2018, 2020, 5, 452, 227, 2, 2019, 2018, 3, 2, 2, 2, 2020,
	2023, 3, 2, 2, 2, 2021, 2019, 3, 2, 2, 2, 2021, 2022, 3, 2, 2, 2, 2022,
	437, 3, 2, 2, 2, 2023, 2021, 3, 2, 2, 2, 2024, 2026, 5, 454, 228, 2, 2025,
	2024, 3, 2, 2, 2, 2026, 2029, 3, 2, 2, 2, 2027, 2025, 3, 2, 2, 2, 2027,
	2028, 3, 2, 2, 2, 2028, 439, 3, 2, 2, 2, 2029, 2027, 3, 2, 2, 2, 2030,
	2032, 5, 456, 229, 2, 2031, 2030, 3, 2, 2, 2, 2032, 2035, 3, 2, 2, 2, 2033,
	2031, 3, 2, 2, 2, 2033, 2034, 3, 2, 2, 2, 2034, 441, 3, 2, 2, 2, 2035,
	2033, 3, 2, 2, 2, 2036, 2038, 5, 458, 230, 2, 2037, 2036, 3, 2, 2, 2, 2038,
	2041, 3, 2, 2, 2, 2039, 2037, 3, 2, 2, 2, 2039, 2040, 3, 2, 2, 2, 2040,
	443, 3, 2, 2, 2, 2041, 2039, 3, 2, 2, 2, 2042, 2044, 5, 460, 231, 2, 2043,
	2042, 3, 2, 2, 2, 2044, 2047, 3, 2, 2, 2, 2045, 2043, 3, 2, 2, 2, 2045,
	2046, 3, 2, 2, 2, 2046, 445, 3, 2, 2, 2, 2047, 2045, 3, 2, 2, 2, 2048,
	2050, 5, 462, 232, 2, 2049, 2048, 3, 2, 2, 2, 2050, 2053, 3, 2, 2, 2, 2051,
	2049, 3, 2, 2, 2, 2051, 2052, 3, 2, 2, 2, 2052, 447, 3, 2, 2, 2, 2053,
	2051, 3, 2, 2, 2, 2054, 2056, 5, 464, 233, 2, 2055, 2054, 3, 2, 2, 2, 2056,
	2059, 3, 2, 2, 2, 2057, 2055, 3, 2, 2, 2, 2057, 2058, 3, 2, 2, 2, 2058,
	449, 3, 2, 2, 2, 2059, 2057, 3, 2, 2, 2, 2060, 2061, 7, 210, 2, 2, 2061,
	2062, 5, 466, 234, 2, 2062, 451, 3, 2, 2, 2, 2063, 2064, 7, 210, 2, 2,
	2064, 2065, 5, 468, 235, 2, 2065, 453, 3, 2, 2, 2, 2066, 2067, 7, 210,
	2, 2, 2067, 2068, 5, 470, 236, 2, 2068, 455, 3, 2, 2, 2, 2069, 2070, 7,
	210, 2, 2, 2070, 2071, 5, 472, 237, 2, 2071, 457, 3, 2, 2, 2, 2072, 2073,
	7, 210, 2, 2, 2073, 2074, 5, 474, 238, 2, 2074, 459, 3, 2, 2, 2, 2075,
	2076, 7, 210, 2, 2, 2076, 2077, 5, 476, 239, 2, 2077, 461, 3, 2, 2, 2,
	2078, 2079, 7, 210, 2, 2, 2079, 2080, 5, 478, 240, 2, 2080, 463, 3, 2,
	2, 2, 2081, 2082, 7, 210, 2, 2, 2082, 2083, 5, 480, 241, 2, 2083, 465,
	3, 2, 2, 2, 2084, 2086, 5, 382, 192, 2, 2085, 2084, 3, 2, 2, 2, 2085, 2086,
	3, 2, 2, 2, 2086, 2087, 3, 2, 2, 2, 2087, 2088, 5, 482, 242, 2, 2088, 467,
	3, 2, 2, 2, 2089, 2091, 5, 382, 192, 2, 2090, 2089, 3, 2, 2, 2, 2090, 2091,
	3, 2, 2, 2, 2091, 2092, 3, 2, 2, 2, 2092, 2093, 5, 484, 243, 2, 2093, 469,
	3, 2, 2, 2, 2094, 2096, 5, 382, 192, 2, 2095, 2094, 3, 2, 2, 2, 2095, 2096,
	3, 2, 2, 2, 2096, 2097, 3, 2, 2, 2, 2097, 2098, 5, 486, 244, 2, 2098, 471,
	3, 2, 2, 2, 2099, 2101, 5, 382, 192, 2, 2100, 2099, 3, 2, 2, 2, 2100, 2101,
	3, 2, 2, 2, 2101, 2102, 3, 2, 2, 2, 2102, 2103, 5, 488, 245, 2, 2103, 473,
	3, 2, 2, 2, 2104, 2106, 5, 382, 192, 2, 2105, 2104, 3, 2, 2, 2, 2105, 2106,
	3, 2, 2, 2, 2106, 2107, 3, 2, 2, 2, 2107, 2108, 5, 490, 246, 2, 2108, 475,
	3, 2, 2, 2, 2109, 2111, 5, 382, 192, 2, 2110, 2109, 3, 2, 2, 2, 2110, 2111,
	3, 2, 2, 2, 2111, 2112, 3, 2, 2, 2, 2112, 2113, 5, 492, 247, 2, 2113, 477,
	3, 2, 2, 2, 2114, 2116, 5, 382, 192, 2, 2115, 2114, 3, 2, 2, 2, 2115, 2116,
	3, 2, 2, 2, 2116, 2117, 3, 2, 2, 2, 2117, 2118, 5, 494, 248, 2, 2118, 479,
	3, 2, 2, 2, 2119, 2121, 5, 382, 192, 2, 2120, 2119, 3, 2, 2, 2, 2120, 2121,
	3, 2, 2, 2, 2121, 2122, 3, 2, 2, 2, 2122, 2123, 5, 496, 249, 2, 2123, 481,
	3, 2, 2, 2, 2124, 2125, 7, 223, 2, 2, 2125, 2126, 5, 518, 260, 2, 2126,
	2127, 7, 208, 2, 2, 2127, 483, 3, 2, 2, 2, 2128, 2129, 7, 223, 2, 2, 2129,
	2130, 5, 518, 260, 2, 2130, 2131, 7, 210, 2, 2, 2131, 2132, 5, 512, 257,
	2, 2132, 2133, 7, 210, 2, 2, 2133, 2134, 5, 510, 256, 2, 2134, 2135, 7,
	208, 2, 2, 2135, 485, 3, 2, 2, 2, 2136, 2137, 7, 223, 2, 2, 2137, 2138,
	5, 518, 260, 2, 2138, 2139, 7, 210, 2, 2, 2139, 2140, 5, 512, 257, 2, 2140,
	2141, 7, 210, 2, 2, 2141, 2142, 5, 510, 256, 2, 2142, 2143, 7, 208, 2,
	2, 2143, 487, 3, 2, 2, 2, 2144, 2145, 7, 223, 2, 2, 2145, 2146, 5, 518,
	260, 2, 2146, 2147, 7, 210, 2, 2, 2147, 2148, 5, 512, 257, 2, 2148, 2149,
	7, 210, 2, 2, 2149, 2150, 5, 516, 259, 2, 2150, 2151, 7, 210, 2, 2, 2151,
	2152, 5, 520, 261, 2, 2152, 2153, 7, 208, 2, 2, 2153, 489, 3, 2, 2, 2,
	2154, 2155, 7, 223, 2, 2, 2155, 2156, 5, 518, 260, 2, 2156, 2157, 7, 210,
	2, 2, 2157, 2158, 5, 498, 250, 2, 2158, 2159, 7, 208, 2, 2, 2159, 491,
	3, 2, 2, 2, 2160, 2161, 7, 223, 2, 2, 2161, 2162, 5, 500, 251, 2, 2162,
	2163, 7, 210, 2, 2, 2163, 2164, 5, 512, 257, 2, 2164, 2165, 7, 208, 2,
	2, 2165, 493, 3, 2, 2, 2, 2166, 2167, 7, 223, 2, 2, 2167, 2168, 5, 514,
	258, 2, 2168, 2169, 7, 210, 2, 2, 2169, 2170, 5, 514, 258, 2, 2170, 2171,
	7, 208, 2, 2, 2171, 495, 3, 2, 2, 2, 2172, 2173, 7, 223, 2, 2, 2173, 2174,
	5, 514, 258, 2, 2174, 2175, 7, 210, 2, 2, 2175, 2176, 5, 514, 258, 2, 2176,
	2177, 7, 210, 2, 2, 2177, 2178, 5, 510, 256, 2, 2178, 2179, 7, 208, 2,
	2, 2179, 497, 3, 2, 2, 2, 2180, 2181, 5, 512, 257, 2, 2181, 2182, 5, 502,
	252, 2, 2182, 499, 3, 2, 2, 2, 2183, 2184, 5, 518, 260, 2, 2184, 2185,
	5, 504, 253, 2, 2185, 501, 3, 2, 2, 2, 2186, 2188, 5, 506, 254, 2, 2187,
	2186, 3, 2, 2, 2, 2188, 2191, 3, 2, 2, 2, 2189, 2187, 3, 2, 2, 2, 2189,
	2190, 3, 2, 2, 2, 2190, 503, 3, 2, 2, 2, 2191, 2189, 3, 2, 2, 2, 2192,
	2194, 5, 508, 255, 2, 2193, 2192, 3, 2, 2, 2, 2194, 2197, 3, 2, 2, 2, 2195,
	2193, 3, 2, 2, 2, 2195, 2196, 3, 2, 2, 2, 2196, 505, 3, 2, 2, 2, 2197,
	2195, 3, 2, 2, 2, 2198, 2199, 7, 210, 2, 2, 2199, 2200, 5, 512, 257, 2,
	2200, 507, 3, 2, 2, 2, 2201, 2202, 7, 210, 2, 2, 2202, 2203, 5, 518, 260,
	2, 2203, 509, 3, 2, 2, 2, 2204, 2205, 5, 734, 368, 2, 2205, 511, 3, 2,
	2, 2, 2206, 2207, 5, 734, 368, 2, 2207, 513, 3, 2, 2, 2, 2208, 2209, 5,
	734, 368, 2, 2209, 515, 3, 2, 2, 2, 2210, 2211, 5, 734, 368, 2, 2211, 517,
	3, 2, 2, 2, 2212, 2213, 5, 734, 368, 2, 2213, 519, 3, 2, 2, 2, 2214, 2215,
	5, 734, 368, 2, 2215, 521, 3, 2, 2, 2, 2216, 2218, 5, 524, 263, 2, 2217,
	2216, 3, 2, 2, 2, 2218, 2221, 3, 2, 2, 2, 2219, 2217, 3, 2, 2, 2, 2219,
	2220, 3, 2, 2, 2, 2220, 523, 3, 2, 2, 2, 2221, 2219, 3, 2, 2, 2, 2222,
	2223, 5, 858, 430, 2, 2223, 2225, 5, 526, 264, 2, 2224, 2226, 5, 8, 5,
	2, 2225, 2224, 3, 2, 2, 2, 2225, 2226, 3, 2, 2, 2, 2226, 2229, 3, 2, 2,
	2, 2227, 2229, 5, 546, 274, 2, 2228, 2222, 3, 2, 2, 2, 2228, 2227, 3, 2,
	2, 2, 2229, 525, 3, 2, 2, 2, 2230, 2239, 5, 528, 265, 2, 2231, 2239, 5,
	530, 266, 2, 2232, 2239, 5, 532, 267, 2, 2233, 2239, 5, 534, 268, 2, 2234,
	2239, 5, 536, 269, 2, 2235, 2239, 5, 538, 270, 2, 2236, 2239, 5, 540, 271,
	2, 2237, 2239, 5, 542, 272, 2, 2238, 2230, 3, 2, 2, 2, 2238, 2231, 3, 2,
	2, 2, 2238, 2232, 3, 2, 2, 2, 2238, 2233, 3, 2, 2, 2, 2238, 2234, 3, 2,
	2, 2, 2238, 2235, 3, 2, 2, 2, 2238, 2236, 3, 2, 2, 2, 2238, 2237, 3, 2,
	2, 2, 2239, 527, 3, 2, 2, 2, 2240, 2247, 5, 596, 299, 2, 2241, 2247, 5,
	598, 300, 2, 2242, 2247, 5, 600, 301, 2, 2243, 2247, 5, 602, 302, 2, 2244,
	2247, 5, 604, 303, 2, 2245, 2247, 5, 606, 304, 2, 2246, 2240, 3, 2, 2,
	2, 2246, 2241, 3, 2, 2, 2, 2246, 2242, 3, 2, 2, 2, 2246, 2243, 3, 2, 2,
	2, 2246, 2244, 3, 2, 2, 2, 2246, 2245, 3, 2, 2, 2, 2247, 529, 3, 2, 2,
	2, 2248, 2252, 5, 718, 360, 2, 2249, 2252, 5, 692, 347, 2, 2250, 2252,
	5, 700, 351, 2, 2251, 2248, 3, 2, 2, 2, 2251, 2249, 3, 2, 2, 2, 2251, 2250,
	3, 2, 2, 2, 2252, 531, 3, 2, 2, 2, 2253, 2256, 5, 824, 413, 2, 2254, 2256,
	5, 826, 414, 2, 2255, 2253, 3, 2, 2, 2, 2255, 2254, 3, 2, 2, 2, 2256, 533,
	3, 2, 2, 2, 2257, 2261, 5, 578, 290, 2, 2258, 2261, 5, 572, 287, 2, 2259,
	2261, 5, 582, 292, 2, 2260, 2257, 3, 2, 2, 2, 2260, 2258, 3, 2, 2, 2, 2260,
	2259, 3, 2, 2, 2, 2261, 535, 3, 2, 2, 2, 2262, 2265, 5, 642, 322, 2, 2263,
	2265, 5, 648, 325, 2, 2264, 2262, 3, 2, 2, 2, 2264, 2263, 3, 2, 2, 2, 2265,
	537, 3, 2, 2, 2, 2266, 2271, 5, 548, 275, 2, 2267, 2271, 5, 558, 280, 2,
	2268, 2271, 5, 566, 284, 2, 2269, 2271, 5, 560, 281, 2, 2270, 2266, 3,
	2, 2, 2, 2270, 2267, 3, 2, 2, 2, 2270, 2268, 3, 2, 2, 2, 2270, 2269, 3,
	2, 2, 2, 2271, 539, 3, 2, 2, 2, 2272, 2273, 5, 734, 368, 2, 2273, 541,
	3, 2, 2, 2, 2274, 2275, 5, 544, 273, 2, 2275, 543, 3, 2, 2, 2, 2276, 2277,
	7, 155, 2, 2, 2277, 2280, 5, 734, 368, 2, 2278, 2280, 7, 155, 2, 2, 2279,
	2276, 3, 2, 2, 2, 2279, 2278, 3, 2, 2, 2, 2280, 545, 3, 2, 2, 2, 2281,
	2282, 5, 8, 5, 2, 2282, 547, 3, 2, 2, 2, 2283, 2288, 5, 550, 276, 2, 2284,
	2288, 5, 552, 277, 2, 2285, 2288, 5, 554, 278, 2, 2286, 2288, 5, 556, 279,
	2, 2287, 2283, 3, 2, 2, 2, 2287, 2284, 3, 2, 2, 2, 2287, 2285, 3, 2, 2,
	2, 2287, 2286, 3, 2, 2, 2, 2288, 549, 3, 2, 2, 2, 2289, 2290, 7, 56, 2,
	2, 2290, 2291, 5, 528, 265, 2, 2291, 551, 3, 2, 2, 2, 2292, 2293, 7, 71,
	2, 2, 2293, 2294, 5, 586, 294, 2, 2294, 553, 3, 2, 2, 2, 2295, 2296, 7,
	94, 2, 2, 2296, 2297, 5, 528, 265, 2, 2297, 555, 3, 2, 2, 2, 2298, 2299,
	7, 153, 2, 2, 2299, 2300, 5, 586, 294, 2, 2300, 557, 3, 2, 2, 2, 2301,
	2302, 5, 608, 305, 2, 2302, 2303, 5, 524, 263, 2, 2303, 559, 3, 2, 2, 2,
	2304, 2305, 5, 562, 282, 2, 2305, 561, 3, 2, 2, 2, 2306, 2307, 7, 76, 2,
	2, 2307, 2308, 7, 103, 2, 2, 2308, 2309, 7, 223, 2, 2, 2309, 2310, 5, 734,
	368, 2, 2310, 2311, 7, 208, 2, 2, 2311, 2312, 5, 564, 283, 2, 2312, 563,
	3, 2, 2, 2, 2313, 2314, 5, 734, 368, 2, 2314, 565, 3, 2, 2, 2, 2315, 2317,
	5, 570, 286, 2, 2316, 2318, 5, 568, 285, 2, 2317, 2316, 3, 2, 2, 2, 2317,
	2318, 3, 2, 2, 2, 2318, 567, 3, 2, 2, 2, 2319, 2320, 7, 79, 2, 2, 2320,
	2321, 5, 526, 264, 2, 2321, 569, 3, 2, 2, 2, 2322, 2323, 5, 870, 436, 2,
	2323, 2324, 7, 209, 2, 2, 2324, 2326, 3, 2, 2, 2, 2325, 2322, 3, 2, 2,
	2, 2325, 2326, 3, 2, 2, 2, 2326, 2327, 3, 2, 2, 2, 2327, 2328, 7, 55, 2,
	2, 2328, 2329, 7, 223, 2, 2, 2329, 2330, 5, 734, 368, 2, 2330, 2331, 7,
	208, 2, 2, 2331, 571, 3, 2, 2, 2, 2332, 2334, 5, 574, 288, 2, 2333, 2335,
	5, 576, 289, 2, 2334, 2333, 3, 2, 2, 2, 2334, 2335, 3, 2, 2, 2, 2335, 573,
	3, 2, 2, 2, 2336, 2337, 7, 203, 2, 2, 2337, 575, 3, 2, 2, 2, 2338, 2340,
	7, 223, 2, 2, 2339, 2341, 5, 332, 167, 2, 2340, 2339, 3, 2, 2, 2, 2340,
	2341, 3, 2, 2, 2, 2341, 2342, 3, 2, 2, 2, 2342, 2343, 7, 208, 2, 2, 2343,
	577, 3, 2, 2, 2, 2344, 2346, 5, 580, 291, 2, 2345, 2347, 5, 576, 289, 2,
	2346, 2345, 3, 2, 2, 2, 2346, 2347, 3, 2, 2, 2, 2347, 579, 3, 2, 2, 2,
	2348, 2349, 5, 870, 436, 2, 2349, 581, 3, 2, 2, 2, 2350, 2351, 7, 76, 2,
	2, 2351, 2355, 5, 580, 291, 2, 2352, 2353, 7, 76, 2, 2, 2353, 2355, 5,
	584, 293, 2, 2354, 2350, 3, 2, 2, 2, 2354, 2352, 3, 2, 2, 2, 2355, 583,
	3, 2, 2, 2, 2356, 2357, 5, 870, 436, 2, 2357, 585, 3, 2, 2, 2, 2358, 2361,
	5, 588, 295, 2, 2359, 2361, 5, 590, 296, 2, 2360, 2358, 3, 2, 2, 2, 2360,
	2359, 3, 2, 2, 2, 2361, 587, 3, 2, 2, 2, 2362, 2363, 5, 796, 399, 2, 2363,
	589, 3, 2, 2, 2, 2364, 2365, 7, 221, 2, 2, 2365, 2366, 5, 592, 297, 2,
	2366, 2367, 5, 594, 298, 2, 2367, 2368, 7, 228, 2, 2, 2368, 591, 3, 2,
	2, 2, 2369, 2372, 5, 796, 399, 2, 2370, 2372, 5, 590, 296, 2, 2371, 2369,
	3, 2, 2, 2, 2371, 2370, 3, 2, 2, 2, 2372, 593, 3, 2, 2, 2, 2373, 2374,
	7, 210, 2, 2, 2374, 2376, 5, 592, 297, 2, 2375, 2373, 3, 2, 2, 2, 2376,
	2379, 3, 2, 2, 2, 2377, 2375, 3, 2, 2, 2, 2377, 2378, 3, 2, 2, 2, 2378,
	595, 3, 2, 2, 2, 2379, 2377, 3, 2, 2, 2, 2380, 2381, 5, 586, 294, 2, 2381,
	2383, 7, 215, 2, 2, 2382, 2384, 5, 608, 305, 2, 2383, 2382, 3, 2, 2, 2,
	2383, 2384, 3, 2, 2, 2, 2384, 2385, 3, 2, 2, 2, 2385, 2386, 5, 734, 368,
	2, 2386, 597, 3, 2, 2, 2, 2387, 2388, 5, 586, 294, 2, 2388, 2390, 7, 219,
	2, 2, 2389, 2391, 5, 608, 305, 2, 2390, 2389, 3, 2, 2, 2, 2390, 2391, 3,
	2, 2, 2, 2391, 2392, 3, 2, 2, 2, 2392, 2393, 5, 734, 368, 2, 2393, 599,
	3, 2, 2, 2, 2394, 2395, 5, 14, 8, 2, 2395, 2396, 5, 586, 294, 2, 2396,
	601, 3, 2, 2, 2, 2397, 2398, 5, 586, 294, 2, 2398, 2399, 5, 14, 8, 2, 2399,
	603, 3, 2, 2, 2, 2400, 2401, 5, 586, 294, 2, 2401, 2402, 5, 16, 9, 2, 2402,
	2403, 5, 734, 368, 2, 2403, 605, 3, 2, 2, 2, 2404, 2411, 5, 244, 123, 2,
	2405, 2411, 5, 246, 124, 2, 2406, 2411, 5, 250, 126, 2, 2407, 2411, 5,
	252, 127, 2, 2408, 2411, 5, 254, 128, 2, 2409, 2411, 5, 264, 133, 2, 2410,
	2404, 3, 2, 2, 2, 2410, 2405, 3, 2, 2, 2, 2410, 2406, 3, 2, 2, 2, 2410,
	2407, 3, 2, 2, 2, 2410, 2408, 3, 2, 2, 2, 2410, 2409, 3, 2, 2, 2, 2411,
	607, 3, 2, 2, 2, 2412, 2416, 5, 610, 306, 2, 2413, 2416, 5, 612, 307, 2,
	2414, 2416, 5, 640, 321, 2, 2415, 2412, 3, 2, 2, 2, 2415, 2413, 3, 2, 2,
	2, 2415, 2414, 3, 2, 2, 2, 2416, 609, 3, 2, 2, 2, 2417, 2418, 7, 218, 2,
	2, 2418, 2430, 5, 376, 189, 2, 2419, 2420, 7, 218, 2, 2, 2420, 2421, 7,
	223, 2, 2, 2421, 2422, 5, 376, 189, 2, 2422, 2423, 7, 208, 2, 2, 2423,
	2430, 3, 2, 2, 2, 2424, 2425, 7, 218, 2, 2, 2425, 2426, 7, 223, 2, 2, 2426,
	2427, 5, 752, 377, 2, 2427, 2428, 7, 208, 2, 2, 2428, 2430, 3, 2, 2, 2,
	2429, 2417, 3, 2, 2, 2, 2429, 2419, 3, 2, 2, 2, 2429, 2424, 3, 2, 2, 2,
	2430, 611, 3, 2, 2, 2, 2431, 2435, 5, 614, 308, 2, 2432, 2435, 5, 616,
	309, 2, 2433, 2435, 5, 638, 320, 2, 2434, 2431, 3, 2, 2, 2, 2434, 2432,
	3, 2, 2, 2, 2434, 2433, 3, 2, 2, 2, 2435, 613, 3, 2, 2, 2, 2436, 2437,
	7, 207, 2, 2, 2437, 2438, 5, 646, 324, 2, 2438, 615, 3, 2, 2, 2, 2439,
	2440, 7, 207, 2, 2, 2440, 2441, 7, 223, 2, 2, 2441, 2442, 5, 618, 310,
	2, 2442, 2443, 7, 208, 2, 2, 2443, 617, 3, 2, 2, 2, 2444, 2447, 5, 620,
	311, 2, 2445, 2447, 5, 624, 313, 2, 2446, 2444, 3, 2, 2, 2, 2446, 2445,
	3, 2, 2, 2, 2447, 619, 3, 2, 2, 2, 2448, 2454, 5, 734, 368, 2, 2449, 2454,
	5, 870, 436, 2, 2450, 2451, 5, 622, 312, 2, 2451, 2452, 5, 734, 368, 2,
	2452, 2454, 3, 2, 2, 2, 2453, 2448, 3, 2, 2, 2, 2453, 2449, 3, 2, 2, 2,
	2453, 2450, 3, 2, 2, 2, 2454, 621, 3, 2, 2, 2, 2455, 2456, 9, 24, 2, 2,
	2456, 623, 3, 2, 2, 2, 2457, 2460, 5, 626, 314, 2, 2458, 2460, 5, 632,
	317, 2, 2459, 2457, 3, 2, 2, 2, 2459, 2458, 3, 2, 2, 2, 2460, 625, 3, 2,
	2, 2, 2461, 2462, 5, 620, 311, 2, 2462, 2463, 5, 628, 315, 2, 2463, 627,
	3, 2, 2, 2, 2464, 2466, 5, 630, 316, 2, 2465, 2464, 3, 2, 2, 2, 2466, 2469,
	3, 2, 2, 2, 2467, 2465, 3, 2, 2, 2, 2467, 2468, 3, 2, 2, 2, 2468, 629,
	3, 2, 2, 2, 2469, 2467, 3, 2, 2, 2, 2470, 2471, 7, 210, 2, 2, 2471, 2472,
	5, 620, 311, 2, 2472, 631, 3, 2, 2, 2, 2473, 2474, 5, 620, 311, 2, 2474,
	2475, 5, 634, 318, 2, 2475, 633, 3, 2, 2, 2, 2476, 2478, 5, 636, 319, 2,
	2477, 2476, 3, 2, 2, 2, 2478, 2481, 3, 2, 2, 2, 2479, 2477, 3, 2, 2, 2,
	2479, 2480, 3, 2, 2, 2, 2480, 635, 3, 2, 2, 2, 2481, 2479, 3, 2, 2, 2,
	2482, 2483, 7, 133, 2, 2, 2483, 2484, 5, 620, 311, 2, 2484, 637, 3, 2,
	2, 2, 2485, 2486, 7, 207, 2, 2, 2486, 2492, 7, 230, 2, 2, 2487, 2488, 7,
	207, 2, 2, 2488, 2489, 7, 223, 2, 2, 2489, 2490, 7, 230, 2, 2, 2490, 2492,
	7, 208, 2, 2, 2491, 2485, 3, 2, 2, 2, 2491, 2487, 3, 2, 2, 2, 2492, 639,
	3, 2, 2, 2, 2493, 2494, 7, 154, 2, 2, 2494, 2495, 7, 223, 2, 2, 2495, 2496,
	5, 734, 368, 2, 2496, 2497, 7, 208, 2, 2, 2497, 2498, 5, 612, 307, 2, 2498,
	641, 3, 2, 2, 2, 2499, 2500, 7, 211, 2, 2, 2500, 2501, 5, 644, 323, 2,
	2501, 643, 3, 2, 2, 2, 2502, 2503, 5, 870, 436, 2, 2503, 645, 3, 2, 2,
	2, 2504, 2505, 5, 868, 435, 2, 2505, 647, 3, 2, 2, 2, 2506, 2507, 7, 194,
	2, 2, 2507, 2508, 7, 223, 2, 2, 2508, 2509, 5, 734, 368, 2, 2509, 2510,
	7, 208, 2, 2, 2510, 2511, 5, 524, 263, 2, 2511, 649, 3, 2, 2, 2, 2512,
	2513, 5, 858, 430, 2, 2513, 2514, 5, 652, 327, 2, 2514, 651, 3, 2, 2, 2,
	2515, 2516, 7, 98, 2, 2, 2516, 2517, 5, 654, 328, 2, 2517, 2519, 7, 84,
	2, 2, 2518, 2520, 5, 8, 5, 2, 2519, 2518, 3, 2, 2, 2, 2519, 2520, 3, 2,
	2, 2, 2520, 653, 3, 2, 2, 2, 2521, 2523, 5, 656, 329, 2, 2522, 2521, 3,
	2, 2, 2, 2523, 2526, 3, 2, 2, 2, 2524, 2522, 3, 2, 2, 2, 2524, 2525, 3,
	2, 2, 2, 2525, 655, 3, 2, 2, 2, 2526, 2524, 3, 2, 2, 2, 2527, 2538, 5,
	668, 335, 2, 2528, 2538, 5, 686, 344, 2, 2529, 2538, 5, 674, 338, 2, 2530,
	2538, 5, 658, 330, 2, 2531, 2538, 5, 60, 31, 2, 2532, 2538, 5, 66, 34,
	2, 2533, 2538, 5, 70, 36, 2, 2534, 2538, 5, 74, 38, 2, 2535, 2538, 5, 78,
	40, 2, 2536, 2538, 5, 86, 44, 2, 2537, 2527, 3, 2, 2, 2, 2537, 2528, 3,
	2, 2, 2, 2537, 2529, 3, 2, 2, 2, 2537, 2530, 3, 2, 2, 2, 2537, 2531, 3,
	2, 2, 2, 2537, 2532, 3, 2, 2, 2, 2537, 2533, 3, 2, 2, 2, 2537, 2534, 3,
	2, 2, 2, 2537, 2535, 3, 2, 2, 2, 2537, 2536, 3, 2, 2, 2, 2538, 657, 3,
	2, 2, 2, 2539, 2541, 7, 58, 2, 2, 2540, 2542, 5, 660, 331, 2, 2541, 2540,
	3, 2, 2, 2, 2541, 2542, 3, 2, 2, 2, 2542, 2543, 3, 2, 2, 2, 2543, 2544,
	5, 654, 328, 2, 2544, 2546, 7, 80, 2, 2, 2545, 2547, 5, 662, 332, 2, 2546,
	2545, 3, 2, 2, 2, 2546, 2547, 3, 2, 2, 2, 2547, 2549, 3, 2, 2, 2, 2548,
	2550, 5, 8, 5, 2, 2549, 2548, 3, 2, 2, 2, 2549, 2550, 3, 2, 2, 2, 2550,
	659, 3, 2, 2, 2, 2551, 2552, 5, 664, 333, 2, 2552, 661, 3, 2, 2, 2, 2553,
	2554, 5, 664, 333, 2, 2554, 663, 3, 2, 2, 2, 2555, 2556, 7, 209, 2, 2,
	2556, 2557, 5, 666, 334, 2, 2557, 665, 3, 2, 2, 2, 2558, 2559, 5, 868,
	435, 2, 2559, 667, 3, 2, 2, 2, 2560, 2562, 5, 670, 336, 2, 2561, 2563,
	5, 672, 337, 2, 2562, 2561, 3, 2, 2, 2, 2562, 2563, 3, 2, 2, 2, 2563, 669,
	3, 2, 2, 2, 2564, 2565, 7, 102, 2, 2, 2565, 2566, 7, 223, 2, 2, 2566, 2567,
	5, 698, 350, 2, 2567, 2568, 7, 208, 2, 2, 2568, 2569, 5, 656, 329, 2, 2569,
	671, 3, 2, 2, 2, 2570, 2571, 7, 79, 2, 2, 2571, 2572, 5, 656, 329, 2, 2572,
	673, 3, 2, 2, 2, 2573, 2579, 5, 676, 339, 2, 2574, 2579, 5, 678, 340, 2,
	2575, 2579, 5, 680, 341, 2, 2576, 2579, 5, 682, 342, 2, 2577, 2579, 5,
	684, 343, 2, 2578, 2573, 3, 2, 2, 2, 2578, 2574, 3, 2, 2, 2, 2578, 2575,
	3, 2, 2, 2, 2578, 2576, 3, 2, 2, 2, 2578, 2577, 3, 2, 2, 2, 2579, 675,
	3, 2, 2, 2, 2580, 2581, 7, 95, 2, 2, 2581, 2582, 5, 656, 329, 2, 2582,
	677, 3, 2, 2, 2, 2583, 2584, 7, 154, 2, 2, 2584, 2585, 7, 223, 2, 2, 2585,
	2586, 5, 714, 358, 2, 2586, 2587, 7, 208, 2, 2, 2587, 2588, 5, 656, 329,
	2, 2588, 679, 3, 2, 2, 2, 2589, 2590, 7, 198, 2, 2, 2590, 2591, 7, 223,
	2, 2, 2591, 2592, 5, 714, 358, 2, 2592, 2593, 7, 208, 2, 2, 2593, 2594,
	5, 656, 329, 2, 2594, 681, 3, 2, 2, 2, 2595, 2596, 7, 77, 2, 2, 2596, 2597,
	5, 656, 329, 2, 2597, 2598, 7, 198, 2, 2, 2598, 2599, 7, 223, 2, 2, 2599,
	2600, 5, 714, 358, 2, 2600, 2601, 7, 208, 2, 2, 2601, 2602, 5, 8, 5, 2,
	2602, 683, 3, 2, 2, 2, 2603, 2604, 7, 93, 2, 2, 2604, 2605, 7, 223, 2,
	2, 2605, 2606, 5, 712, 357, 2, 2606, 2607, 5, 8, 5, 2, 2607, 2608, 5, 714,
	358, 2, 2608, 2610, 5, 8, 5, 2, 2609, 2611, 5, 716, 359, 2, 2610, 2609,
	3, 2, 2, 2, 2610, 2611, 3, 2, 2, 2, 2611, 2612, 3, 2, 2, 2, 2612, 2613,
	7, 208, 2, 2, 2613, 2614, 5, 656, 329, 2, 2614, 685, 3, 2, 2, 2, 2615,
	2616, 5, 6, 4, 2, 2616, 2617, 7, 223, 2, 2, 2617, 2618, 5, 724, 363, 2,
	2618, 2619, 7, 208, 2, 2, 2619, 2620, 5, 688, 345, 2, 2620, 2621, 7, 81,
	2, 2, 2621, 687, 3, 2, 2, 2, 2622, 2624, 5, 690, 346, 2, 2623, 2622, 3,
	2, 2, 2, 2624, 2627, 3, 2, 2, 2, 2625, 2623, 3, 2, 2, 2, 2625, 2626, 3,
	2, 2, 2, 2626, 689, 3, 2, 2, 2, 2627, 2625, 3, 2, 2, 2, 2628, 2629, 5,
	726, 364, 2, 2629, 2630, 7, 209, 2, 2, 2630, 2631, 5, 656, 329, 2, 2631,
	2638, 3, 2, 2, 2, 2632, 2634, 7, 72, 2, 2, 2633, 2635, 7, 209, 2, 2, 2634,
	2633, 3, 2, 2, 2, 2634, 2635, 3, 2, 2, 2, 2635, 2636, 3, 2, 2, 2, 2636,
	2638, 5, 656, 329, 2, 2637, 2628, 3, 2, 2, 2, 2637, 2632, 3, 2, 2, 2, 2638,
	691, 3, 2, 2, 2, 2639, 2641, 5, 694, 348, 2, 2640, 2642, 5, 696, 349, 2,
	2641, 2640, 3, 2, 2, 2, 2641, 2642, 3, 2, 2, 2, 2642, 693, 3, 2, 2, 2,
	2643, 2644, 7, 102, 2, 2, 2644, 2645, 7, 223, 2, 2, 2645, 2646, 5, 698,
	350, 2, 2646, 2647, 7, 208, 2, 2, 2647, 2648, 5, 524, 263, 2, 2648, 695,
	3, 2, 2, 2, 2649, 2650, 7, 79, 2, 2, 2650, 2651, 5, 524, 263, 2, 2651,
	697, 3, 2, 2, 2, 2652, 2653, 5, 734, 368, 2, 2653, 699, 3, 2, 2, 2, 2654,
	2660, 5, 702, 352, 2, 2655, 2660, 5, 704, 353, 2, 2656, 2660, 5, 706, 354,
	2, 2657, 2660, 5, 708, 355, 2, 2658, 2660, 5, 710, 356, 2, 2659, 2654,
	3, 2, 2, 2, 2659, 2655, 3, 2, 2, 2, 2659, 2656, 3, 2, 2, 2, 2659, 2657,
	3, 2, 2, 2, 2659, 2658, 3, 2, 2, 2, 2660, 701, 3, 2, 2, 2, 2661, 2662,
	7, 95, 2, 2, 2662, 2663, 5, 524, 263, 2, 2663, 703, 3, 2, 2, 2, 2664, 2665,
	7, 154, 2, 2, 2665, 2666, 7, 223, 2, 2, 2666, 2667, 5, 714, 358, 2, 2667,
	2668, 7, 208, 2, 2, 2668, 2669, 5, 524, 263, 2, 2669, 705, 3, 2, 2, 2,
	2670, 2671, 7, 198, 2, 2, 2671, 2672, 7, 223, 2, 2, 2672, 2673, 5, 714,
	358, 2, 2673, 2674, 7, 208, 2, 2, 2674, 2675, 5, 524, 263, 2, 2675, 707,
	3, 2, 2, 2, 2676, 2677, 7, 77, 2, 2, 2677, 2678, 5, 524, 263, 2, 2678,
	2679, 7, 198, 2, 2, 2679, 2680, 7, 223, 2, 2, 2680, 2681, 5, 714, 358,
	2, 2681, 2682, 7, 208, 2, 2, 2682, 2683, 5, 8, 5, 2, 2683, 709, 3, 2, 2,
	2, 2684, 2685, 7, 93, 2, 2, 2685, 2686, 7, 223, 2, 2, 2686, 2687, 5, 712,
	357, 2, 2687, 2688, 5, 8, 5, 2, 2688, 2689, 5, 714, 358, 2, 2689, 2691,
	5, 8, 5, 2, 2690, 2692, 5, 716, 359, 2, 2691, 2690, 3, 2, 2, 2, 2691, 2692,
	3, 2, 2, 2, 2692, 2693, 3, 2, 2, 2, 2693, 2694, 7, 208, 2, 2, 2694, 2695,
	5, 524, 263, 2, 2695, 711, 3, 2, 2, 2, 2696, 2699, 5, 606, 304, 2, 2697,
	2699, 5, 596, 299, 2, 2698, 2696, 3, 2, 2, 2, 2698, 2697, 3, 2, 2, 2, 2699,
	713, 3, 2, 2, 2, 2700, 2701, 5, 734, 368, 2, 2701, 715, 3, 2, 2, 2, 2702,
	2707, 5, 596, 299, 2, 2703, 2707, 5, 602, 302, 2, 2704, 2707, 5, 600, 301,
	2, 2705, 2707, 5, 604, 303, 2, 2706, 2702, 3, 2, 2, 2, 2706, 2703, 3, 2,
	2, 2, 2706, 2704, 3, 2, 2, 2, 2706, 2705, 3, 2, 2, 2, 2707, 717, 3, 2,
	2, 2, 2708, 2709, 5, 6, 4, 2, 2709, 2710, 7, 223, 2, 2, 2710, 2711, 5,
	724, 363, 2, 2711, 2712, 7, 208, 2, 2, 2712, 2713, 5, 720, 361, 2, 2713,
	2714, 7, 81, 2, 2, 2714, 719, 3, 2, 2, 2, 2715, 2717, 5, 722, 362, 2, 2716,
	2715, 3, 2, 2, 2, 2717, 2720, 3, 2, 2, 2, 2718, 2716, 3, 2, 2, 2, 2718,
	2719, 3, 2, 2, 2, 2719, 721, 3, 2, 2, 2, 2720, 2718, 3, 2, 2, 2, 2721,
	2722, 5, 726, 364, 2, 2722, 2723, 7, 209, 2, 2, 2723, 2724, 5, 524, 263,
	2, 2724, 2731, 3, 2, 2, 2, 2725, 2727, 7, 72, 2, 2, 2726, 2728, 7, 209,
	2, 2, 2727, 2726, 3, 2, 2, 2, 2727, 2728, 3, 2, 2, 2, 2728, 2729, 3, 2,
	2, 2, 2729, 2731, 5, 524, 263, 2, 2730, 2721, 3, 2, 2, 2, 2730, 2725, 3,
	2, 2, 2, 2731, 723, 3, 2, 2, 2, 2732, 2733, 5, 734, 368, 2, 2733, 725,
	3, 2, 2, 2, 2734, 2735, 5, 728, 365, 2, 2735, 2736, 5, 732, 367, 2, 2736,
	727, 3, 2, 2, 2, 2737, 2738, 5, 734, 368, 2, 2738, 729, 3, 2, 2, 2, 2739,
	2740, 7, 210, 2, 2, 2740, 2741, 5, 728, 365, 2, 2741, 731, 3, 2, 2, 2,
	2742, 2744, 5, 730, 366, 2, 2743, 2742, 3, 2, 2, 2, 2744, 2747, 3, 2, 2,
	2, 2745, 2743, 3, 2, 2, 2, 2745, 2746, 3, 2, 2, 2, 2746, 733, 3, 2, 2,
	2, 2747, 2745, 3, 2, 2, 2, 2748, 2756, 5, 742, 372, 2, 2749, 2756, 5, 744,
	373, 2, 2750, 2756, 5, 746, 374, 2, 2751, 2756, 5, 748, 375, 2, 2752, 2756,
	5, 750, 376, 2, 2753, 2756, 5, 752, 377, 2, 2754, 2756, 5, 736, 369, 2,
	2755, 2748, 3, 2, 2, 2, 2755, 2749, 3, 2, 2, 2, 2755, 2750, 3, 2, 2, 2,
	2755, 2751, 3, 2, 2, 2, 2755, 2752, 3, 2, 2, 2, 2755, 2753, 3, 2, 2, 2,
	2755, 2754, 3, 2, 2, 2, 2756, 735, 3, 2, 2, 2, 2757, 2762, 7, 206, 2, 2,
	2758, 2762, 5, 740, 371, 2, 2759, 2762, 5, 756, 379, 2, 2760, 2762, 5,
	754, 378, 2, 2761, 2757, 3, 2, 2, 2, 2761, 2758, 3, 2, 2, 2, 2761, 2759,
	3, 2, 2, 2, 2761, 2760, 3, 2, 2, 2, 2762, 737, 3, 2, 2, 2, 2763, 2764,
	5, 740, 371, 2, 2764, 2765, 5, 188, 95, 2, 2765, 739, 3, 2, 2, 2, 2766,
	2778, 5, 886, 444, 2, 2767, 2778, 5, 804, 403, 2, 2768, 2778, 5, 806, 404,
	2, 2769, 2778, 5, 780, 391, 2, 2770, 2778, 5, 786, 394, 2, 2771, 2778,
	5, 790, 396, 2, 2772, 2778, 5, 792, 397, 2, 2773, 2778, 5, 798, 400, 2,
	2774, 2778, 5, 796, 399, 2, 2775, 2778, 5, 778, 390, 2, 2776, 2778, 5,
	802, 402, 2, 2777, 2766, 3, 2, 2, 2, 2777, 2767, 3, 2, 2, 2, 2777, 2768,
	3, 2, 2, 2, 2777, 2769, 3, 2, 2, 2, 2777, 2770, 3, 2, 2, 2, 2777, 2771,
	3, 2, 2, 2, 2777, 2772, 3, 2, 2, 2, 2777, 2773, 3, 2, 2, 2, 2777, 2774,
	3, 2, 2, 2, 2777, 2775, 3, 2, 2, 2, 2777, 2776, 3, 2, 2, 2, 2778, 741,
	3, 2, 2, 2, 2779, 2780, 5, 10, 6, 2, 2780, 2781, 5, 734, 368, 2, 2781,
	743, 3, 2, 2, 2, 2782, 2783, 5, 736, 369, 2, 2783, 2784, 5, 14, 8, 2, 2784,
	745, 3, 2, 2, 2, 2785, 2786, 5, 14, 8, 2, 2786, 2787, 5, 736, 369, 2, 2787,
	747, 3, 2, 2, 2, 2788, 2789, 5, 736, 369, 2, 2789, 2790, 5, 12, 7, 2, 2790,
	2791, 5, 734, 368, 2, 2791, 749, 3, 2, 2, 2, 2792, 2793, 5, 736, 369, 2,
	2793, 2794, 7, 225, 2, 2, 2794, 2795, 5, 734, 368, 2, 2795, 2796, 7, 209,
	2, 2, 2796, 2797, 5, 734, 368, 2, 2797, 751, 3, 2, 2, 2, 2798, 2799, 5,
	736, 369, 2, 2799, 2800, 7, 209, 2, 2, 2800, 2801, 5, 734, 368, 2, 2801,
	2802, 7, 209, 2, 2, 2802, 2803, 5, 734, 368, 2, 2803, 753, 3, 2, 2, 2,
	2804, 2805, 7, 226, 2, 2, 2805, 2806, 7, 221, 2, 2, 2806, 2811, 5, 734,
	368, 2, 2807, 2808, 7, 210, 2, 2, 2808, 2810, 5, 734, 368, 2, 2809, 2807,
	3, 2, 2, 2, 2810, 2813, 3, 2, 2, 2, 2811, 2809, 3, 2, 2, 2, 2811, 2812,
	3, 2, 2, 2, 2812, 2814, 3, 2, 2, 2, 2813, 2811, 3, 2, 2, 2, 2814, 2815,
	7, 228, 2, 2, 2815, 2824, 3, 2, 2, 2, 2816, 2817, 7, 226, 2, 2, 2817, 2818,
	7, 221, 2, 2, 2818, 2819, 5, 734, 368, 2, 2819, 2820, 7, 228, 2, 2, 2820,
	2824, 3, 2, 2, 2, 2821, 2822, 7, 221, 2, 2, 2822, 2824, 7, 228, 2, 2, 2823,
	2804, 3, 2, 2, 2, 2823, 2816, 3, 2, 2, 2, 2823, 2821, 3, 2, 2, 2, 2824,
	755, 3, 2, 2, 2, 2825, 2826, 7, 226, 2, 2, 2826, 2827, 7, 221, 2, 2, 2827,
	2828, 5, 764, 383, 2, 2828, 2829, 7, 228, 2, 2, 2829, 757, 3, 2, 2, 2,
	2830, 2831, 7, 72, 2, 2, 2831, 2832, 7, 209, 2, 2, 2832, 2838, 5, 734,
	368, 2, 2833, 2834, 5, 870, 436, 2, 2834, 2835, 7, 209, 2, 2, 2835, 2836,
	5, 734, 368, 2, 2836, 2838, 3, 2, 2, 2, 2837, 2830, 3, 2, 2, 2, 2837, 2833,
	3, 2, 2, 2, 2838, 759, 3, 2, 2, 2, 2839, 2840, 7, 210, 2, 2, 2840, 2841,
	5, 758, 380, 2, 2841, 761, 3, 2, 2, 2, 2842, 2844, 5, 760, 381, 2, 2843,
	2842, 3, 2, 2, 2, 2844, 2847, 3, 2, 2, 2, 2845, 2843, 3, 2, 2, 2, 2845,
	2846, 3, 2, 2, 2, 2846, 763, 3, 2, 2, 2, 2847, 2845, 3, 2, 2, 2, 2848,
	2849, 5, 758, 380, 2, 2849, 2850, 5, 762, 382, 2, 2850, 765, 3, 2, 2, 2,
	2851, 2852, 5, 774, 388, 2, 2852, 2853, 7, 226, 2, 2, 2853, 2854, 5, 734,
	368, 2, 2854, 767, 3, 2, 2, 2, 2855, 2856, 5, 886, 444, 2, 2856, 2857,
	7, 226, 2, 2, 2857, 2858, 5, 734, 368, 2, 2858, 769, 3, 2, 2, 2, 2859,
	2860, 9, 9, 2, 2, 2860, 2861, 7, 226, 2, 2, 2861, 2862, 5, 734, 368, 2,
	2862, 771, 3, 2, 2, 2, 2863, 2864, 7, 226, 2, 2, 2864, 2865, 5, 734, 368,
	2, 2865, 773, 3, 2, 2, 2, 2866, 2869, 7, 111, 2, 2, 2867, 2869, 5, 180,
	91, 2, 2868, 2866, 3, 2, 2, 2, 2868, 2867, 3, 2, 2, 2, 2869, 775, 3, 2,
	2, 2, 2870, 2871, 5, 868, 435, 2, 2871, 777, 3, 2, 2, 2, 2872, 2877, 5,
	766, 384, 2, 2873, 2877, 5, 768, 385, 2, 2874, 2877, 5, 770, 386, 2, 2875,
	2877, 5, 772, 387, 2, 2876, 2872, 3, 2, 2, 2, 2876, 2873, 3, 2, 2, 2, 2876,
	2874, 3, 2, 2, 2, 2876, 2875, 3, 2, 2, 2, 2877, 779, 3, 2, 2, 2, 2878,
	2879, 5, 782, 392, 2, 2879, 2880, 5, 858, 430, 2, 2880, 2881, 5, 784, 393,
	2, 2881, 781, 3, 2, 2, 2, 2882, 2883, 5, 870, 436, 2, 2883, 783, 3, 2,
	2, 2, 2884, 2886, 7, 223, 2, 2, 2885, 2887, 5, 332, 167, 2, 2886, 2885,
	3, 2, 2, 2, 2886, 2887, 3, 2, 2, 2, 2887, 2888, 3, 2, 2, 2, 2888, 2889,
	7, 208, 2, 2, 2889, 785, 3, 2, 2, 2, 2890, 2892, 5, 788, 395, 2, 2891,
	2893, 5, 784, 393, 2, 2892, 2891, 3, 2, 2, 2, 2892, 2893, 3, 2, 2, 2, 2893,
	787, 3, 2, 2, 2, 2894, 2895, 7, 203, 2, 2, 2895, 789, 3, 2, 2, 2, 2896,
	2897, 5, 780, 391, 2, 2897, 791, 3, 2, 2, 2, 2898, 2899, 5, 794, 398, 2,
	2899, 2900, 5, 858, 430, 2, 2900, 2901, 5, 784, 393, 2, 2901, 793, 3, 2,
	2, 2, 2902, 2903, 5, 800, 401, 2, 2903, 795, 3, 2, 2, 2, 2904, 2906, 5,
	870, 436, 2, 2905, 2907, 5, 184, 93, 2, 2906, 2905, 3, 2, 2, 2, 2906, 2907,
	3, 2, 2, 2, 2907, 797, 3, 2, 2, 2, 2908, 2910, 5, 800, 401, 2, 2909, 2911,
	5, 184, 93, 2, 2910, 2909, 3, 2, 2, 2, 2910, 2911, 3, 2, 2, 2, 2911, 799,
	3, 2, 2, 2, 2912, 2913, 5, 868, 435, 2, 2913, 2914, 7, 214, 2, 2, 2914,
	2915, 5, 870, 436, 2, 2915, 801, 3, 2, 2, 2, 2916, 2917, 7, 223, 2, 2,
	2917, 2918, 5, 734, 368, 2, 2918, 2919, 7, 208, 2, 2, 2919, 803, 3, 2,
	2, 2, 2920, 2921, 7, 221, 2, 2, 2921, 2922, 5, 734, 368, 2, 2922, 2923,
	5, 810, 406, 2, 2923, 2924, 7, 228, 2, 2, 2924, 805, 3, 2, 2, 2, 2925,
	2926, 7, 221, 2, 2, 2926, 2927, 5, 734, 368, 2, 2927, 2928, 5, 804, 403,
	2, 2928, 2929, 7, 228, 2, 2, 2929, 807, 3, 2, 2, 2, 2930, 2931, 7, 210,
	2, 2, 2931, 2933, 5, 734, 368, 2, 2932, 2930, 3, 2, 2, 2, 2933, 2934, 3,
	2, 2, 2, 2934, 2932, 3, 2, 2, 2, 2934, 2935, 3, 2, 2, 2, 2935, 809, 3,
	2, 2, 2, 2936, 2937, 7, 210, 2, 2, 2937, 2939, 5, 734, 368, 2, 2938, 2936,
	3, 2, 2, 2, 2939, 2942, 3, 2, 2, 2, 2940, 2938, 3, 2, 2, 2, 2940, 2941,
	3, 2, 2, 2, 2941, 811, 3, 2, 2, 2, 2942, 2940, 3, 2, 2, 2, 2943, 2944,
	7, 188, 2, 2, 2944, 2945, 5, 816, 409, 2, 2945, 2946, 5, 814, 408, 2, 2946,
	813, 3, 2, 2, 2, 2947, 2948, 5, 868, 435, 2, 2948, 815, 3, 2, 2, 2, 2949,
	2953, 5, 818, 410, 2, 2950, 2953, 5, 326, 164, 2, 2951, 2953, 5, 312, 157,
	2, 2952, 2949, 3, 2, 2, 2, 2952, 2950, 3, 2, 2, 2, 2952, 2951, 3, 2, 2,
	2, 2953, 817, 3, 2, 2, 2, 2954, 2957, 5, 820, 411, 2, 2955, 2957, 5, 822,
	412, 2, 2956, 2954, 3, 2, 2, 2, 2956, 2955, 3, 2, 2, 2, 2957, 819, 3, 2,
	2, 2, 2958, 2960, 5, 822, 412, 2, 2959, 2961, 9, 9, 2, 2, 2960, 2959, 3,
	2, 2, 2, 2960, 2961, 3, 2, 2, 2, 2961, 2963, 3, 2, 2, 2, 2962, 2964, 5,
	184, 93, 2, 2963, 2962, 3, 2, 2, 2, 2963, 2964, 3, 2, 2, 2, 2964, 821,
	3, 2, 2, 2, 2965, 2971, 7, 152, 2, 2, 2966, 2971, 7, 120, 2, 2, 2967, 2971,
	5, 248, 125, 2, 2968, 2971, 5, 202, 102, 2, 2969, 2971, 5, 180, 91, 2,
	2970, 2965, 3, 2, 2, 2, 2970, 2966, 3, 2, 2, 2, 2970, 2967, 3, 2, 2, 2,
	2970, 2968, 3, 2, 2, 2, 2970, 2969, 3, 2, 2, 2, 2971, 823, 3, 2, 2, 2,
	2972, 2975, 7, 96, 2, 2, 2973, 2974, 7, 209, 2, 2, 2974, 2976, 5, 828,
	415, 2, 2975, 2973, 3, 2, 2, 2, 2975, 2976, 3, 2, 2, 2, 2976, 2977, 3,
	2, 2, 2, 2977, 2978, 5, 832, 417, 2, 2978, 2979, 5, 522, 262, 2, 2979,
	2981, 5, 838, 420, 2, 2980, 2982, 5, 830, 416, 2, 2981, 2980, 3, 2, 2,
	2, 2981, 2982, 3, 2, 2, 2, 2982, 825, 3, 2, 2, 2, 2983, 2986, 7, 58, 2,
	2, 2984, 2985, 7, 209, 2, 2, 2985, 2987, 5, 828, 415, 2, 2986, 2984, 3,
	2, 2, 2, 2986, 2987, 3, 2, 2, 2, 2987, 2988, 3, 2, 2, 2, 2988, 2989, 5,
	832, 417, 2, 2989, 2990, 5, 522, 262, 2, 2990, 2992, 7, 80, 2, 2, 2991,
	2993, 5, 830, 416, 2, 2992, 2991, 3, 2, 2, 2, 2992, 2993, 3, 2, 2, 2, 2993,
	827, 3, 2, 2, 2, 2994, 2995, 5, 868, 435, 2, 2995, 829, 3, 2, 2, 2, 2996,
	2997, 7, 209, 2, 2, 2997, 2998, 5, 828, 415, 2, 2998, 831, 3, 2, 2, 2,
	2999, 3001, 5, 834, 418, 2, 3000, 2999, 3, 2, 2, 2, 3001, 3004, 3, 2, 2,
	2, 3002, 3000, 3, 2, 2, 2, 3002, 3003, 3, 2, 2, 2, 3003, 833, 3, 2, 2,
	2, 3004, 3002, 3, 2, 2, 2, 3005, 3006, 5, 836, 419, 2, 3006, 3007, 5, 8,
	5, 2, 3007, 835, 3, 2, 2, 2, 3008, 3022, 5, 244, 123, 2, 3009, 3022, 5,
	262, 132, 2, 3010, 3022, 5, 246, 124, 2, 3011, 3022, 5, 250, 126, 2, 3012,
	3022, 5, 252, 127, 2, 3013, 3022, 5, 254, 128, 2, 3014, 3022, 5, 104, 53,
	2, 3015, 3022, 5, 102, 52, 2, 3016, 3022, 5, 256, 129, 2, 3017, 3022, 5,
	260, 131, 2, 3018, 3022, 5, 258, 130, 2, 3019, 3022, 5, 268, 135, 2, 3020,
	3022, 5, 266, 134, 2, 3021, 3008, 3, 2, 2, 2, 3021, 3009, 3, 2, 2, 2, 3021,
	3010, 3, 2, 2, 2, 3021, 3011, 3, 2, 2, 2, 3021, 3012, 3, 2, 2, 2, 3021,
	3013, 3, 2, 2, 2, 3021, 3014, 3, 2, 2, 2, 3021, 3015, 3, 2, 2, 2, 3021,
	3016, 3, 2, 2, 2, 3021, 3017, 3, 2, 2, 2, 3021, 3018, 3, 2, 2, 2, 3021,
	3019, 3, 2, 2, 2, 3021, 3020, 3, 2, 2, 2, 3022, 837, 3, 2, 2, 2, 3023,
	3024, 9, 25, 2, 2, 3024, 839, 3, 2, 2, 2, 3025, 3027, 7, 56, 2, 2, 3026,
	3028, 5, 204, 103, 2, 3027, 3026, 3, 2, 2, 2, 3027, 3028, 3, 2, 2, 2, 3028,
	3030, 3, 2, 2, 2, 3029, 3031, 5, 368, 185, 2, 3030, 3029, 3, 2, 2, 2, 3030,
	3031, 3, 2, 2, 2, 3031, 3032, 3, 2, 2, 2, 3032, 3033, 5, 842, 422, 2, 3033,
	3034, 5, 8, 5, 2, 3034, 841, 3, 2, 2, 2, 3035, 3036, 5, 848, 425, 2, 3036,
	3037, 5, 844, 423, 2, 3037, 843, 3, 2, 2, 2, 3038, 3040, 5, 846, 424, 2,
	3039, 3038, 3, 2, 2, 2, 3040, 3043, 3, 2, 2, 2, 3041, 3039, 3, 2, 2, 2,
	3041, 3042, 3, 2, 2, 2, 3042, 845, 3, 2, 2, 2, 3043, 3041, 3, 2, 2, 2,
	3044, 3045, 7, 210, 2, 2, 3045, 3046, 5, 848, 425, 2, 3046, 847, 3, 2,
	2, 2, 3047, 3048, 5, 586, 294, 2, 3048, 3049, 7, 215, 2, 2, 3049, 3050,
	5, 734, 368, 2, 3050, 849, 3, 2, 2, 2, 3051, 3052, 7, 107, 2, 2, 3052,
	3053, 5, 524, 263, 2, 3053, 851, 3, 2, 2, 2, 3054, 3055, 7, 92, 2, 2, 3055,
	3056, 5, 524, 263, 2, 3056, 853, 3, 2, 2, 2, 3057, 3058, 9, 26, 2, 2, 3058,
	855, 3, 2, 2, 2, 3059, 3060, 5, 854, 428, 2, 3060, 3061, 5, 524, 263, 2,
	3061, 857, 3, 2, 2, 2, 3062, 3064, 5, 860, 431, 2, 3063, 3062, 3, 2, 2,
	2, 3064, 3067, 3, 2, 2, 2, 3065, 3063, 3, 2, 2, 2, 3065, 3066, 3, 2, 2,
	2, 3066, 859, 3, 2, 2, 2, 3067, 3065, 3, 2, 2, 2, 3068, 3069, 7, 223, 2,
	2, 3069, 3070, 7, 230, 2, 2, 3070, 3071, 5, 864, 433, 2, 3071, 3072, 5,
	862, 432, 2, 3072, 3073, 7, 230, 2, 2, 3073, 3074, 7, 208, 2, 2, 3074,
	861, 3, 2, 2, 2, 3075, 3076, 7, 210, 2, 2, 3076, 3078, 5, 864, 433, 2,
	3077, 3075, 3, 2, 2, 2, 3078, 3081, 3, 2, 2, 2, 3079, 3077, 3, 2, 2, 2,
	3079, 3080, 3, 2, 2, 2, 3080, 863, 3, 2, 2, 2, 3081, 3079, 3, 2, 2, 2,
	3082, 3083, 5, 866, 434, 2, 3083, 3084, 7, 215, 2, 2, 3084, 3085, 5, 734,
	368, 2, 3085, 3088, 3, 2, 2, 2, 3086, 3088, 5, 866, 434, 2, 3087, 3082,
	3, 2, 2, 2, 3087, 3086, 3, 2, 2, 2, 3088, 865, 3, 2, 2, 2, 3089, 3090,
	5, 868, 435, 2, 3090, 867, 3, 2, 2, 2, 3091, 3092, 9, 27, 2, 2, 3092, 869,
	3, 2, 2, 2, 3093, 3094, 5, 876, 439, 2, 3094, 3095, 5, 872, 437, 2, 3095,
	871, 3, 2, 2, 2, 3096, 3098, 5, 874, 438, 2, 3097, 3096, 3, 2, 2, 2, 3098,
	3101, 3, 2, 2, 2, 3099, 3097, 3, 2, 2, 2, 3099, 3100, 3, 2, 2, 2, 3100,
	873, 3, 2, 2, 2, 3101, 3099, 3, 2, 2, 2, 3102, 3103, 7, 212, 2, 2, 3103,
	3104, 5, 876, 439, 2, 3104, 875, 3, 2, 2, 2, 3105, 3107, 5, 868, 435, 2,
	3106, 3108, 5, 184, 93, 2, 3107, 3106, 3, 2, 2, 2, 3107, 3108, 3, 2, 2,
	2, 3108, 877, 3, 2, 2, 2, 3109, 3110, 7, 175, 2, 2, 3110, 3111, 7, 233,
	2, 2, 3111, 3112, 7, 217, 2, 2, 3112, 3113, 7, 233, 2, 2, 3113, 879, 3,
	2, 2, 2, 3114, 3115, 7, 178, 2, 2, 3115, 3116, 7, 233, 2, 2, 3116, 881,
	3, 2, 2, 2, 3117, 3118, 7, 177, 2, 2, 3118, 3119, 7, 233, 2, 2, 3119, 883,
	3, 2, 2, 2, 3120, 3121, 7, 73, 2, 2, 3121, 3122, 5, 202, 102, 2, 3122,
	885, 3, 2, 2, 2, 3123, 3126, 5, 888, 445, 2, 3124, 3126, 5, 890, 446, 2,
	3125, 3123, 3, 2, 2, 2, 3125, 3124, 3, 2, 2, 2, 3126, 887, 3, 2, 2, 2,
	3127, 3128, 9, 28, 2, 2, 3128, 889, 3, 2, 2, 2, 3129, 3130, 9, 29, 2, 2,
	3130, 891, 3, 2, 2, 2, 250, 902, 918, 924, 930, 935, 939, 943, 947, 951,
	953, 963, 968, 971, 976, 982, 989, 1002, 1014, 1024, 1034, 1048, 1058,
	1083, 1087, 1091, 1100, 1107, 1116, 1122, 1128, 1136, 1145, 1148, 1161,
	1174, 1178, 1186, 1197, 1202, 1216, 1220, 1225, 1230, 1240, 1248, 1259,
	1264, 1277, 1280, 1283, 1289, 1302, 1312, 1322, 1335, 1356, 1361, 1372,
	1377, 1405, 1411, 1433, 1441, 1445, 1455, 1463, 1467, 1473, 1476, 1479,
	1482, 1485, 1488, 1491, 1497, 1500, 1506, 1509, 1517, 1520, 1525, 1529,
	1534, 1538, 1558, 1562, 1577, 1580, 1583, 1586, 1590, 1597, 1609, 1615,
	1622, 1630, 1639, 1643, 1654, 1663, 1668, 1679, 1688, 1692, 1702, 1712,
	1719, 1727, 1730, 1733, 1741, 1749, 1755, 1763, 1768, 1778, 1788, 1791,
	1795, 1803, 1811, 1817, 1821, 1825, 1829, 1840, 1848, 1872, 1890, 1903,
	1921, 1928, 1935, 1938, 1945, 1952, 1959, 1962, 1969, 1972, 1983, 2015,
	2021, 2027, 2033, 2039, 2045, 2051, 2057, 2085, 2090, 2095, 2100, 2105,
	2110, 2115, 2120, 2189, 2195, 2219, 2225, 2228, 2238, 2246, 2251, 2255,
	2260, 2264, 2270, 2279, 2287, 2317, 2325, 2334, 2340, 2346, 2354, 2360,
	2371, 2377, 2383, 2390, 2410, 2415, 2429, 2434, 2446, 2453, 2459, 2467,
	2479, 2491, 2519, 2524, 2537, 2541, 2546, 2549, 2562, 2578, 2610, 2625,
	2634, 2637, 2641, 2659, 2691, 2698, 2706, 2718, 2727, 2730, 2745, 2755,
	2761, 2777, 2811, 2823, 2837, 2845, 2868, 2876, 2886, 2892, 2906, 2910,
	2934, 2940, 2952, 2956, 2960, 2963, 2970, 2975, 2981, 2986, 2992, 3002,
	3021, 3027, 3030, 3041, 3065, 3079, 3087, 3099, 3107, 3125,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "';;'", "'+'", "'-'", "'!'", "'&'", "'~&'", "'|'", "'~|'", "'^'", "'~^'",
	"'^~'", "'%'", "'=='", "'!='", "'==='", "'!=='", "'&&'", "'||'", "'**'",
	"'<'", "'>'", "'>='", "'>>'", "'<<'", "'>>>'", "'<<<'", "'++'", "'--'",
	"'+='", "'-='", "'&='", "'|='", "'\r'", "'//'", "'/*'", "'\n'", "'*/'",
	"", "", "", "", "", "", "", "", "", "", "", "'always'", "'always_comb'",
	"'always_ff'", "'and'", "'assert'", "'assign'", "'automatic'", "'begin'",
	"'bit'", "'buf'", "'bufif0'", "'bufif1'", "'byte'", "'case'", "'casez'",
	"'casex'", "'cell'", "'cmos'", "'config'", "'const'", "'deassign'", "'default'",
	"'`default_nettype'", "'defparam'", "'design'", "'disable'", "'do'", "'edge'",
	"'else'", "'end'", "'endcase'", "'endconfig'", "'endfunction'", "'endgenerate'",
	"'endmodule'", "'endpackage'", "'endproperty'", "'endspecify'", "'endtask'",
	"'enum'", "'event'", "'final'", "'for'", "'force'", "'forever'", "'fork'",
	"'function'", "'generate'", "'genvar'", "'highz0'", "'highz1'", "'if'",
	"'iff'", "'ifnone'", "'import'", "'-incdir'", "'initial'", "'inout'", "'input'",
	"'instance'", "'int'", "'integer'", "'join'", "'join_any'", "'join_none'",
	"'large'", "'liblist'", "'`library'", "'localparam'", "'logic'", "'macromodule'",
	"'medium'", "'module'", "'nand'", "'negedge'", "'nmos'", "'none'", "'nor'",
	"'not'", "'notif0'", "'notif1'", "'noshowcancelled'", "'or '", "'output'",
	"'parameter'", "'PATHPULSE$'", "'posedge'", "'package'", "'packed'", "'pmos'",
	"'property'", "'pull0'", "'pull1'", "'pullup'", "'pulldown'", "'pulsestyle_ondetect'",
	"'pulsestyle_onevent'", "'rcmos'", "'real'", "'realtime'", "'ref'", "'reg'",
	"'release'", "'repeat'", "'return'", "'rnmos'", "'rpmos'", "'rtran'", "'rtranif0'",
	"'rtranif1'", "'scalared'", "'showcancelled'", "'signed'", "'small'", "'specify'",
	"'specparam'", "'static'", "'string'", "'strong0'", "'strong1'", "'struct'",
	"'supply0'", "'supply1'", "'task'", "'`timescale'", "'time'", "'timeprecision'",
	"'timeunit'", "'tran'", "'tranif0'", "'tranif1'", "'tri'", "'triand'",
	"'trior'", "'trireg'", "'tri0'", "'tri1'", "'typedef'", "'union'", "'unsigned'",
	"'use'", "'uwire'", "'vectored'", "'wait'", "'wand'", "'weak0'", "'weak1'",
	"'while'", "'wire'", "'wor'", "'xnor'", "'xor'", "", "", "", "", "'@'",
	"')'", "':'", "','", "'->'", "'.'", "'$'", "'::'", "'='", "'=>'", "'/'",
	"'#'", "'<='", "'['", "'{'", "'-:'", "'('", "'+:'", "'?'", "'''", "']'",
	"'}'", "';'", "'*'", "'*>'", "'~'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Carriage_return",
	"Forward_slash_forward_slash", "Forward_slash_star", "New_line", "Star_forward_slash",
	"Block_comment", "Line_directive", "One_line_comment", "WHITE_SPACE", "Binary_number",
	"Decimal_number", "Fixed_point_number", "Hex_number", "Octal_number", "Real_exp_form",
	"Unbased_unsized_literal", "Always", "Always_comb", "Always_ff", "And",
	"Assert", "Assign", "Automatic", "Begin", "Bit", "Buf", "Bufif0", "Bufif1",
	"Byte", "Case_keyword", "Casez", "Casex", "Cell", "Cmos", "Config", "Const",
	"Deassign", "Default", "Default_nettype", "Defparam", "Design", "Disable",
	"Do", "Edge", "Else", "End", "Endcase", "Endconfig", "Endfunction", "Endgenerate",
	"Endmodule", "Endpackage", "Endproperty", "Endspecify", "Endtask", "Enum",
	"Event_keyword", "Final", "For", "Force", "Forever", "Fork", "Function",
	"Generate", "Genvar", "Highz0", "Highz1", "If", "Iff", "Ifnone", "Import",
	"Incdir", "Initial", "Inout", "Input", "Instance", "Int", "Integer", "Join",
	"Join_any", "Join_none", "Large", "Liblist", "Library", "Localparam", "Logic",
	"Macromodule", "Medium", "Module_keyword_only", "Nand", "Negedge", "Nmos",
	"NONE", "Nor", "Not", "Notif0", "Notif1", "Noshowcancelled", "Or", "Output",
	"Parameter", "Path_pulse_dollar", "Posedge", "Package", "Packed", "Pmos",
	"Property", "Pull0", "Pull1", "Pullup", "Pulldown", "Pulsestyle_ondetect",
	"Pulsestyle_onevent", "Rcmos", "Real", "Realtime", "Ref", "Reg", "Release",
	"Repeat", "Return", "Rnmos", "Rpmos", "Rtran", "Rtranif0", "Rtranif1",
	"Scalared", "Showcancelled", "Signed", "Small", "Specify", "Specparam",
	"Static", "SVString", "Strong0", "Strong1", "Struct", "Supply0", "Supply1",
	"Task", "Tick_timescale", "Time", "Timeprecision", "Timeunit", "Tran",
	"Tranif0", "Tranif1", "Tri", "Tri_and", "Tri_or", "Tri_reg", "Tri0", "Tri1",
	"Typedef", "UnionStruct", "Unsigned", "Use", "Uwire", "Vectored", "Wait",
	"Wand", "Weak0", "Weak1", "While", "Wire", "Wor", "Xnor", "Xor", "Dollar_Identifier",
	"Escaped_identifier", "Simple_identifier", "String_literal", "At", "Close_parenthesis",
	"Colon", "Comma", "Dash_right_angle", "Dot", "Dollar", "Double_colon",
	"Equal", "Equals_right_angle", "Forward_slash", "Hash", "Left_angle_equals",
	"Left_bracket", "Left_curly_bracket", "Minus_colon", "Open_parenthesis",
	"Plus_colon", "Question_mark", "Quote", "Right_bracket", "Right_curly_bracket",
	"Semicolon", "Star", "Star_right_angle", "Tilde", "Time_literal", "Edge_control_specifier",
}

var ruleNames = []string{
	"module_keyword", "struct_keyword", "any_case_keyword", "semicolon", "unary_operator",
	"binary_operator", "unary_assign_operator", "binary_assign_operator", "source_text",
	"description_star", "header_text", "design_attribute", "compiler_directive",
	"description", "module_declaration", "module_identifier", "module_interface",
	"module_parameter_interface", "module_port_interface", "module_item_star",
	"module_item", "colon_module_identifier", "package_declaration", "package_identifier",
	"colon_package_identifier", "package_item_star", "package_item", "import_package",
	"package_item_identifier", "parameter_item_semicolon", "parameter_item",
	"attr_port_item_semicolon", "attr_variable_item_semicolon", "variable_item",
	"subroutine_item_semicolon", "subroutine_item", "attr_construct_item",
	"construct_item", "attr_component_item", "component_item", "compiler_item",
	"type_item", "null_item", "list_of_interface_parameters", "list_of_parameter_declarations",
	"comma_parameter_declaration_star", "comma_parameter_declaration", "list_of_parameter_descriptions",
	"param_declaration", "param_description", "parameter_declaration", "local_parameter_declaration",
	"parameter_override", "list_of_tf_interface_ports", "list_of_tf_port_declarations",
	"list_of_tf_port_declarations_comma", "comma_attr_tf_port_declaration_star",
	"comma_attr_tf_port_declaration", "list_of_tf_port_declarations_semicolon",
	"attr_tf_port_declaration_semicolon_plus", "attr_tf_port_declaration_semicolon_star",
	"attr_tf_port_declaration_semicolon", "attr_tf_port_declaration", "tf_port_declaration",
	"list_of_interface_ports", "list_of_port_identifiers", "comma_port_identifier_star",
	"comma_port_identifier", "port_identifier", "list_of_port_declarations",
	"list_of_port_declarations_comma", "comma_attr_port_declaration_star",
	"comma_attr_port_declaration", "list_of_port_declarations_semicolon", "attr_port_declaration_semicolon_plus",
	"attr_port_declaration_semicolon_star", "attr_port_declaration_semicolon",
	"attr_port_declaration", "port_declaration", "port_description", "inout_description",
	"input_description", "output_description", "ref_description", "tf_declaration",
	"inout_declaration", "input_declaration", "output_declaration", "ref_declaration",
	"user_type", "user_type_identifer", "dimension_plus", "dimension_star",
	"dimension", "range_expression", "index_expression", "sb_range", "base_increment_range",
	"base_decrement_range", "base_expression", "net_type", "drive_strength",
	"drive_strength_value_0", "drive_strength_value_1", "strength0", "strength1",
	"highz0", "highz1", "charge_strength", "charge_size", "list_of_variable_descriptions",
	"comma_variable_description_star", "comma_variable_description", "variable_description",
	"variable_identifier", "list_of_hierarchical_variable_descriptions", "comma_hierarchical_variable_description_star",
	"comma_hierarchical_variable_description", "hierarchical_variable_description",
	"hierarchical_variable_identifier", "net_declaration", "reg_declaration",
	"logic_declaration", "bits_type", "bits_declaration", "integer_declaration",
	"int_declaration", "real_declaration", "time_declaration", "realtime_declaration",
	"event_declaration", "genvar_declaration", "usertype_variable_declaration",
	"string_declaration", "struct_declaration", "enum_declaration", "function_declaration",
	"function_type", "function_identifier", "function_interface", "function_item_declaration_star",
	"function_item_declaration_semicolon", "function_item_declaration", "function_statement",
	"colon_function_identifier", "task_declaration", "task_identifier", "task_interface",
	"task_item_declaration_semicolon", "task_item_declaration", "task_item_declaration_star",
	"task_statement", "struct_item_semicolon", "struct_item_star", "struct_item",
	"struct_type", "enum_type", "list_of_enum_items", "enum_item", "enum_identifier",
	"comma_enum_item_star", "comma_enum_item", "enumerated_type", "module_instantiation",
	"parameter_interface_assignments", "list_of_interface_assignments", "list_of_ordered_interface_assignments",
	"comma_ordered_interface_assignment_star", "comma_ordered_interface_assignment",
	"ordered_interface_assignment", "list_of_named_interface_assignments",
	"comma_named_interface_assignment_star", "comma_named_interface_assignment",
	"named_interface_assignment", "list_of_module_instances", "comma_module_instance_star",
	"comma_module_instance", "module_instance", "module_instance_identifier",
	"arrayed_identifier", "simple_arrayed_identifier", "escaped_arrayed_identifier",
	"port_interface_assignments", "delay", "list_of_delay_values", "comma_delay_value_star",
	"comma_delay_value", "delay_value", "pulldown_strength", "pullup_strength",
	"gate_instance_identifier", "gate_instantiation", "enable_gatetype", "mos_switchtype",
	"cmos_switchtype", "n_output_gatetype", "n_input_gatetype", "pass_switchtype",
	"pass_enable_switchtype", "pulldown_instantiation", "pullup_instantiation",
	"enable_instantiation", "mos_instantiation", "cmos_instantiation", "n_output_instantiation",
	"n_input_instantiation", "pass_instantiation", "pass_enable_instantiation",
	"list_of_pull_gate_instance", "list_of_enable_gate_instance", "list_of_mos_switch_instance",
	"list_of_cmos_switch_instance", "list_of_n_input_gate_instance", "list_of_n_output_gate_instance",
	"list_of_pass_switch_instance", "list_of_pass_enable_switch_instance",
	"comma_pull_gate_instance_star", "comma_enable_gate_instance_star", "comma_mos_switch_instance_star",
	"comma_cmos_switch_instance_star", "comma_n_input_gate_instance_star",
	"comma_n_output_gate_instance_star", "comma_pass_switch_instance_star",
	"comma_pass_enable_switch_instance_star", "comma_pull_gate_instance", "comma_enable_gate_instance",
	"comma_mos_switch_instance", "comma_cmos_switch_instance", "comma_n_input_gate_instance",
	"comma_n_output_gate_instance", "comma_pass_switch_instance", "comma_pass_enable_switch_instance",
	"pull_gate_instance", "enable_gate_instance", "mos_switch_instance", "cmos_switch_instance",
	"n_input_gate_instance", "n_output_gate_instance", "pass_switch_instance",
	"pass_enable_switch_instance", "pull_gate_interface", "enable_gate_interface",
	"mos_switch_interface", "cmos_switch_interface", "n_input_gate_interface",
	"n_output_gate_interface", "pass_switch_interface", "pass_enable_switch_interface",
	"list_of_input_terminals", "list_of_output_terminals", "comma_input_terminal_star",
	"comma_output_terminal_star", "comma_input_terminal", "comma_output_terminal",
	"enable_terminal", "input_terminal", "inout_terminal", "ncontrol_terminal",
	"output_terminal", "pcontrol_terminal", "statement_star", "statement_semicolon",
	"statement", "assignment_statement", "flow_control_statement", "block_statement",
	"task_call_statement", "event_statement", "procedural_statement", "expression_statement",
	"subroutine_statement", "return_statement", "null_statement", "procedural_continuous_assignments",
	"assign_statement", "deassign_statement", "force_statement", "release_statement",
	"procedural_timing_control_statement", "property_statement", "disable_condition_statement",
	"property_expression", "procedural_assertion_statement", "assert_else_statement",
	"assert_statement", "system_task_enable", "system_task_identifier", "task_interface_assignments",
	"task_enable", "hierarchical_task_identifier", "disable_statement", "hierarchical_block_identifier",
	"variable_lvalue", "hierarchical_variable_lvalue", "variable_concatenation",
	"variable_concatenation_value", "comma_vcv_star", "blocking_assignment",
	"nonblocking_assignment", "prefix_assignment", "postfix_assignment", "operator_assignment",
	"declarative_assignment", "delay_or_event_control", "delay_control", "event_control",
	"event_control_identifier", "event_control_expression", "event_expression",
	"single_event_expression", "event_expression_edgespec", "event_expression_or",
	"list_of_event_expression_comma", "comma_event_expression_star", "comma_event_expression",
	"list_of_event_expression_or", "or_event_expression_star", "or_event_expression",
	"event_control_wildcard", "repeat_event_control", "event_trigger", "hierarchical_event_identifier",
	"event_identifier", "wait_statement", "attr_generated_instantiation", "generated_instantiation",
	"generate_item_star", "generate_item", "generate_block", "generate_colon_block_identifier0",
	"generate_colon_block_identifier1", "generate_colon_block_identifier",
	"generate_block_identifier", "generate_conditional_statement", "generate_if_statement",
	"generate_else_statement", "generate_loop_statement", "generate_forever_loop_statement",
	"generate_repeat_loop_statement", "generate_while_loop_statement", "generate_do_loop_statement",
	"generate_for_loop_statement", "generate_case_statement", "generate_case_item_star",
	"generate_case_item", "conditional_statement", "if_statement", "else_statement",
	"conditional_expression", "loop_statement", "forever_loop_statement", "repeat_loop_statement",
	"while_loop_statement", "do_loop_statement", "for_loop_statement", "loop_init_assignment",
	"loop_terminate_expression", "loop_step_assignment", "case_statement",
	"case_item_star", "case_item", "case_switch", "case_item_key", "case_item_key_expression",
	"comma_case_item_key_expression", "comma_case_item_key_expression_star",
	"expression", "single_expression", "primary_range", "primary", "unary_expression",
	"unary_post_assign_expression", "unary_pre_assign_expression", "binary_expression",
	"ternary_expression", "mintypmax_expression", "structured_value", "arrayed_structured_value",
	"arrayed_structure_item", "comma_arrayed_structure_item", "comma_arrayed_structure_item_star",
	"arrayed_structure_item_plus", "variable_type_cast", "width_type_cast",
	"sign_type_cast", "null_type_cast", "variable_type", "type_cast_identifier",
	"type_cast_expression", "function_call", "hierarchical_function_identifier",
	"function_interface_assignments", "system_function_call", "system_function_identifier",
	"constant_function_call", "imported_function_call", "imported_function_hierarchical_identifier",
	"primary_hierarchical_identifier", "primary_imported_hierarchical_identifier",
	"imported_hierarchical_identifier", "parenthesis_expression", "concatenation",
	"multiple_concatenation", "comma_expression_plus", "comma_expression_star",
	"typedef_declaration", "typedef_identifier", "typedef_definition", "typedef_definition_type",
	"complex_type", "typedef_type", "par_block", "seq_block", "block_identifier",
	"colon_block_identifier", "block_item_declaration_star", "block_item_declaration_semicolon",
	"block_item_declaration", "join_keyword", "continuous_assign", "list_of_variable_assignments",
	"comma_variable_assignment_star", "comma_variable_assignment", "variable_assignment",
	"initial_construct", "final_construct", "always_keyword", "always_construct",
	"attribute_instance_star", "attribute_instance", "attr_spec_star", "attr_spec",
	"attr_name", "identifier", "hierarchical_identifier", "dot_hierarchical_identifier_branch_item_star",
	"dot_hierarchical_identifier_branch_item", "hierarchical_identifier_branch_item",
	"timescale_compiler_directive", "timeunit_directive", "timeprecision_directive",
	"default_nettype_statement", "number", "integral_number", "real_number",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type SysVerilogHDLParser struct {
	*antlr.BaseParser
}

func NewSysVerilogHDLParser(input antlr.TokenStream) *SysVerilogHDLParser {
	this := new(SysVerilogHDLParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "SysVerilogHDL.g4"

	return this
}

// SysVerilogHDLParser tokens.
const (
	SysVerilogHDLParserEOF                         = antlr.TokenEOF
	SysVerilogHDLParserT__0                        = 1
	SysVerilogHDLParserT__1                        = 2
	SysVerilogHDLParserT__2                        = 3
	SysVerilogHDLParserT__3                        = 4
	SysVerilogHDLParserT__4                        = 5
	SysVerilogHDLParserT__5                        = 6
	SysVerilogHDLParserT__6                        = 7
	SysVerilogHDLParserT__7                        = 8
	SysVerilogHDLParserT__8                        = 9
	SysVerilogHDLParserT__9                        = 10
	SysVerilogHDLParserT__10                       = 11
	SysVerilogHDLParserT__11                       = 12
	SysVerilogHDLParserT__12                       = 13
	SysVerilogHDLParserT__13                       = 14
	SysVerilogHDLParserT__14                       = 15
	SysVerilogHDLParserT__15                       = 16
	SysVerilogHDLParserT__16                       = 17
	SysVerilogHDLParserT__17                       = 18
	SysVerilogHDLParserT__18                       = 19
	SysVerilogHDLParserT__19                       = 20
	SysVerilogHDLParserT__20                       = 21
	SysVerilogHDLParserT__21                       = 22
	SysVerilogHDLParserT__22                       = 23
	SysVerilogHDLParserT__23                       = 24
	SysVerilogHDLParserT__24                       = 25
	SysVerilogHDLParserT__25                       = 26
	SysVerilogHDLParserT__26                       = 27
	SysVerilogHDLParserT__27                       = 28
	SysVerilogHDLParserT__28                       = 29
	SysVerilogHDLParserT__29                       = 30
	SysVerilogHDLParserT__30                       = 31
	SysVerilogHDLParserT__31                       = 32
	SysVerilogHDLParserCarriage_return             = 33
	SysVerilogHDLParserForward_slash_forward_slash = 34
	SysVerilogHDLParserForward_slash_star          = 35
	SysVerilogHDLParserNew_line                    = 36
	SysVerilogHDLParserStar_forward_slash          = 37
	SysVerilogHDLParserBlock_comment               = 38
	SysVerilogHDLParserLine_directive              = 39
	SysVerilogHDLParserOne_line_comment            = 40
	SysVerilogHDLParserWHITE_SPACE                 = 41
	SysVerilogHDLParserBinary_number               = 42
	SysVerilogHDLParserDecimal_number              = 43
	SysVerilogHDLParserFixed_point_number          = 44
	SysVerilogHDLParserHex_number                  = 45
	SysVerilogHDLParserOctal_number                = 46
	SysVerilogHDLParserReal_exp_form               = 47
	SysVerilogHDLParserUnbased_unsized_literal     = 48
	SysVerilogHDLParserAlways                      = 49
	SysVerilogHDLParserAlways_comb                 = 50
	SysVerilogHDLParserAlways_ff                   = 51
	SysVerilogHDLParserAnd                         = 52
	SysVerilogHDLParserAssert                      = 53
	SysVerilogHDLParserAssign                      = 54
	SysVerilogHDLParserAutomatic                   = 55
	SysVerilogHDLParserBegin                       = 56
	SysVerilogHDLParserBit                         = 57
	SysVerilogHDLParserBuf                         = 58
	SysVerilogHDLParserBufif0                      = 59
	SysVerilogHDLParserBufif1                      = 60
	SysVerilogHDLParserByte                        = 61
	SysVerilogHDLParserCase_keyword                = 62
	SysVerilogHDLParserCasez                       = 63
	SysVerilogHDLParserCasex                       = 64
	SysVerilogHDLParserCell                        = 65
	SysVerilogHDLParserCmos                        = 66
	SysVerilogHDLParserConfig                      = 67
	SysVerilogHDLParserConst                       = 68
	SysVerilogHDLParserDeassign                    = 69
	SysVerilogHDLParserDefault                     = 70
	SysVerilogHDLParserDefault_nettype             = 71
	SysVerilogHDLParserDefparam                    = 72
	SysVerilogHDLParserDesign                      = 73
	SysVerilogHDLParserDisable                     = 74
	SysVerilogHDLParserDo                          = 75
	SysVerilogHDLParserEdge                        = 76
	SysVerilogHDLParserElse                        = 77
	SysVerilogHDLParserEnd                         = 78
	SysVerilogHDLParserEndcase                     = 79
	SysVerilogHDLParserEndconfig                   = 80
	SysVerilogHDLParserEndfunction                 = 81
	SysVerilogHDLParserEndgenerate                 = 82
	SysVerilogHDLParserEndmodule                   = 83
	SysVerilogHDLParserEndpackage                  = 84
	SysVerilogHDLParserEndproperty                 = 85
	SysVerilogHDLParserEndspecify                  = 86
	SysVerilogHDLParserEndtask                     = 87
	SysVerilogHDLParserEnum                        = 88
	SysVerilogHDLParserEvent_keyword               = 89
	SysVerilogHDLParserFinal                       = 90
	SysVerilogHDLParserFor                         = 91
	SysVerilogHDLParserForce                       = 92
	SysVerilogHDLParserForever                     = 93
	SysVerilogHDLParserFork                        = 94
	SysVerilogHDLParserFunction                    = 95
	SysVerilogHDLParserGenerate                    = 96
	SysVerilogHDLParserGenvar                      = 97
	SysVerilogHDLParserHighz0                      = 98
	SysVerilogHDLParserHighz1                      = 99
	SysVerilogHDLParserIf                          = 100
	SysVerilogHDLParserIff                         = 101
	SysVerilogHDLParserIfnone                      = 102
	SysVerilogHDLParserImport                      = 103
	SysVerilogHDLParserIncdir                      = 104
	SysVerilogHDLParserInitial                     = 105
	SysVerilogHDLParserInout                       = 106
	SysVerilogHDLParserInput                       = 107
	SysVerilogHDLParserInstance                    = 108
	SysVerilogHDLParserInt                         = 109
	SysVerilogHDLParserInteger                     = 110
	SysVerilogHDLParserJoin                        = 111
	SysVerilogHDLParserJoin_any                    = 112
	SysVerilogHDLParserJoin_none                   = 113
	SysVerilogHDLParserLarge                       = 114
	SysVerilogHDLParserLiblist                     = 115
	SysVerilogHDLParserLibrary                     = 116
	SysVerilogHDLParserLocalparam                  = 117
	SysVerilogHDLParserLogic                       = 118
	SysVerilogHDLParserMacromodule                 = 119
	SysVerilogHDLParserMedium                      = 120
	SysVerilogHDLParserModule_keyword_only         = 121
	SysVerilogHDLParserNand                        = 122
	SysVerilogHDLParserNegedge                     = 123
	SysVerilogHDLParserNmos                        = 124
	SysVerilogHDLParserNONE                        = 125
	SysVerilogHDLParserNor                         = 126
	SysVerilogHDLParserNot                         = 127
	SysVerilogHDLParserNotif0                      = 128
	SysVerilogHDLParserNotif1                      = 129
	SysVerilogHDLParserNoshowcancelled             = 130
	SysVerilogHDLParserOr                          = 131
	SysVerilogHDLParserOutput                      = 132
	SysVerilogHDLParserParameter                   = 133
	SysVerilogHDLParserPath_pulse_dollar           = 134
	SysVerilogHDLParserPosedge                     = 135
	SysVerilogHDLParserPackage                     = 136
	SysVerilogHDLParserPacked                      = 137
	SysVerilogHDLParserPmos                        = 138
	SysVerilogHDLParserProperty                    = 139
	SysVerilogHDLParserPull0                       = 140
	SysVerilogHDLParserPull1                       = 141
	SysVerilogHDLParserPullup                      = 142
	SysVerilogHDLParserPulldown                    = 143
	SysVerilogHDLParserPulsestyle_ondetect         = 144
	SysVerilogHDLParserPulsestyle_onevent          = 145
	SysVerilogHDLParserRcmos                       = 146
	SysVerilogHDLParserReal                        = 147
	SysVerilogHDLParserRealtime                    = 148
	SysVerilogHDLParserRef                         = 149
	SysVerilogHDLParserReg                         = 150
	SysVerilogHDLParserRelease                     = 151
	SysVerilogHDLParserRepeat                      = 152
	SysVerilogHDLParserReturn                      = 153
	SysVerilogHDLParserRnmos                       = 154
	SysVerilogHDLParserRpmos                       = 155
	SysVerilogHDLParserRtran                       = 156
	SysVerilogHDLParserRtranif0                    = 157
	SysVerilogHDLParserRtranif1                    = 158
	SysVerilogHDLParserScalared                    = 159
	SysVerilogHDLParserShowcancelled               = 160
	SysVerilogHDLParserSigned                      = 161
	SysVerilogHDLParserSmall                       = 162
	SysVerilogHDLParserSpecify                     = 163
	SysVerilogHDLParserSpecparam                   = 164
	SysVerilogHDLParserStatic                      = 165
	SysVerilogHDLParserSVString                    = 166
	SysVerilogHDLParserStrong0                     = 167
	SysVerilogHDLParserStrong1                     = 168
	SysVerilogHDLParserStruct                      = 169
	SysVerilogHDLParserSupply0                     = 170
	SysVerilogHDLParserSupply1                     = 171
	SysVerilogHDLParserTask                        = 172
	SysVerilogHDLParserTick_timescale              = 173
	SysVerilogHDLParserTime                        = 174
	SysVerilogHDLParserTimeprecision               = 175
	SysVerilogHDLParserTimeunit                    = 176
	SysVerilogHDLParserTran                        = 177
	SysVerilogHDLParserTranif0                     = 178
	SysVerilogHDLParserTranif1                     = 179
	SysVerilogHDLParserTri                         = 180
	SysVerilogHDLParserTri_and                     = 181
	SysVerilogHDLParserTri_or                      = 182
	SysVerilogHDLParserTri_reg                     = 183
	SysVerilogHDLParserTri0                        = 184
	SysVerilogHDLParserTri1                        = 185
	SysVerilogHDLParserTypedef                     = 186
	SysVerilogHDLParserUnionStruct                 = 187
	SysVerilogHDLParserUnsigned                    = 188
	SysVerilogHDLParserUse                         = 189
	SysVerilogHDLParserUwire                       = 190
	SysVerilogHDLParserVectored                    = 191
	SysVerilogHDLParserWait                        = 192
	SysVerilogHDLParserWand                        = 193
	SysVerilogHDLParserWeak0                       = 194
	SysVerilogHDLParserWeak1                       = 195
	SysVerilogHDLParserWhile                       = 196
	SysVerilogHDLParserWire                        = 197
	SysVerilogHDLParserWor                         = 198
	SysVerilogHDLParserXnor                        = 199
	SysVerilogHDLParserXor                         = 200
	SysVerilogHDLParserDollar_Identifier           = 201
	SysVerilogHDLParserEscaped_identifier          = 202
	SysVerilogHDLParserSimple_identifier           = 203
	SysVerilogHDLParserString_literal              = 204
	SysVerilogHDLParserAt                          = 205
	SysVerilogHDLParserClose_parenthesis           = 206
	SysVerilogHDLParserColon                       = 207
	SysVerilogHDLParserComma                       = 208
	SysVerilogHDLParserDash_right_angle            = 209
	SysVerilogHDLParserDot                         = 210
	SysVerilogHDLParserDollar                      = 211
	SysVerilogHDLParserDouble_colon                = 212
	SysVerilogHDLParserEqual                       = 213
	SysVerilogHDLParserEquals_right_angle          = 214
	SysVerilogHDLParserForward_slash               = 215
	SysVerilogHDLParserHash                        = 216
	SysVerilogHDLParserLeft_angle_equals           = 217
	SysVerilogHDLParserLeft_bracket                = 218
	SysVerilogHDLParserLeft_curly_bracket          = 219
	SysVerilogHDLParserMinus_colon                 = 220
	SysVerilogHDLParserOpen_parenthesis            = 221
	SysVerilogHDLParserPlus_colon                  = 222
	SysVerilogHDLParserQuestion_mark               = 223
	SysVerilogHDLParserQuote                       = 224
	SysVerilogHDLParserRight_bracket               = 225
	SysVerilogHDLParserRight_curly_bracket         = 226
	SysVerilogHDLParserSemicolon                   = 227
	SysVerilogHDLParserStar                        = 228
	SysVerilogHDLParserStar_right_angle            = 229
	SysVerilogHDLParserTilde                       = 230
	SysVerilogHDLParserTime_literal                = 231
	SysVerilogHDLParserEdge_control_specifier      = 232
)

// SysVerilogHDLParser rules.
const (
	SysVerilogHDLParserRULE_module_keyword                               = 0
	SysVerilogHDLParserRULE_struct_keyword                               = 1
	SysVerilogHDLParserRULE_any_case_keyword                             = 2
	SysVerilogHDLParserRULE_semicolon                                    = 3
	SysVerilogHDLParserRULE_unary_operator                               = 4
	SysVerilogHDLParserRULE_binary_operator                              = 5
	SysVerilogHDLParserRULE_unary_assign_operator                        = 6
	SysVerilogHDLParserRULE_binary_assign_operator                       = 7
	SysVerilogHDLParserRULE_source_text                                  = 8
	SysVerilogHDLParserRULE_description_star                             = 9
	SysVerilogHDLParserRULE_header_text                                  = 10
	SysVerilogHDLParserRULE_design_attribute                             = 11
	SysVerilogHDLParserRULE_compiler_directive                           = 12
	SysVerilogHDLParserRULE_description                                  = 13
	SysVerilogHDLParserRULE_module_declaration                           = 14
	SysVerilogHDLParserRULE_module_identifier                            = 15
	SysVerilogHDLParserRULE_module_interface                             = 16
	SysVerilogHDLParserRULE_module_parameter_interface                   = 17
	SysVerilogHDLParserRULE_module_port_interface                        = 18
	SysVerilogHDLParserRULE_module_item_star                             = 19
	SysVerilogHDLParserRULE_module_item                                  = 20
	SysVerilogHDLParserRULE_colon_module_identifier                      = 21
	SysVerilogHDLParserRULE_package_declaration                          = 22
	SysVerilogHDLParserRULE_package_identifier                           = 23
	SysVerilogHDLParserRULE_colon_package_identifier                     = 24
	SysVerilogHDLParserRULE_package_item_star                            = 25
	SysVerilogHDLParserRULE_package_item                                 = 26
	SysVerilogHDLParserRULE_import_package                               = 27
	SysVerilogHDLParserRULE_package_item_identifier                      = 28
	SysVerilogHDLParserRULE_parameter_item_semicolon                     = 29
	SysVerilogHDLParserRULE_parameter_item                               = 30
	SysVerilogHDLParserRULE_attr_port_item_semicolon                     = 31
	SysVerilogHDLParserRULE_attr_variable_item_semicolon                 = 32
	SysVerilogHDLParserRULE_variable_item                                = 33
	SysVerilogHDLParserRULE_subroutine_item_semicolon                    = 34
	SysVerilogHDLParserRULE_subroutine_item                              = 35
	SysVerilogHDLParserRULE_attr_construct_item                          = 36
	SysVerilogHDLParserRULE_construct_item                               = 37
	SysVerilogHDLParserRULE_attr_component_item                          = 38
	SysVerilogHDLParserRULE_component_item                               = 39
	SysVerilogHDLParserRULE_compiler_item                                = 40
	SysVerilogHDLParserRULE_type_item                                    = 41
	SysVerilogHDLParserRULE_null_item                                    = 42
	SysVerilogHDLParserRULE_list_of_interface_parameters                 = 43
	SysVerilogHDLParserRULE_list_of_parameter_declarations               = 44
	SysVerilogHDLParserRULE_comma_parameter_declaration_star             = 45
	SysVerilogHDLParserRULE_comma_parameter_declaration                  = 46
	SysVerilogHDLParserRULE_list_of_parameter_descriptions               = 47
	SysVerilogHDLParserRULE_param_declaration                            = 48
	SysVerilogHDLParserRULE_param_description                            = 49
	SysVerilogHDLParserRULE_parameter_declaration                        = 50
	SysVerilogHDLParserRULE_local_parameter_declaration                  = 51
	SysVerilogHDLParserRULE_parameter_override                           = 52
	SysVerilogHDLParserRULE_list_of_tf_interface_ports                   = 53
	SysVerilogHDLParserRULE_list_of_tf_port_declarations                 = 54
	SysVerilogHDLParserRULE_list_of_tf_port_declarations_comma           = 55
	SysVerilogHDLParserRULE_comma_attr_tf_port_declaration_star          = 56
	SysVerilogHDLParserRULE_comma_attr_tf_port_declaration               = 57
	SysVerilogHDLParserRULE_list_of_tf_port_declarations_semicolon       = 58
	SysVerilogHDLParserRULE_attr_tf_port_declaration_semicolon_plus      = 59
	SysVerilogHDLParserRULE_attr_tf_port_declaration_semicolon_star      = 60
	SysVerilogHDLParserRULE_attr_tf_port_declaration_semicolon           = 61
	SysVerilogHDLParserRULE_attr_tf_port_declaration                     = 62
	SysVerilogHDLParserRULE_tf_port_declaration                          = 63
	SysVerilogHDLParserRULE_list_of_interface_ports                      = 64
	SysVerilogHDLParserRULE_list_of_port_identifiers                     = 65
	SysVerilogHDLParserRULE_comma_port_identifier_star                   = 66
	SysVerilogHDLParserRULE_comma_port_identifier                        = 67
	SysVerilogHDLParserRULE_port_identifier                              = 68
	SysVerilogHDLParserRULE_list_of_port_declarations                    = 69
	SysVerilogHDLParserRULE_list_of_port_declarations_comma              = 70
	SysVerilogHDLParserRULE_comma_attr_port_declaration_star             = 71
	SysVerilogHDLParserRULE_comma_attr_port_declaration                  = 72
	SysVerilogHDLParserRULE_list_of_port_declarations_semicolon          = 73
	SysVerilogHDLParserRULE_attr_port_declaration_semicolon_plus         = 74
	SysVerilogHDLParserRULE_attr_port_declaration_semicolon_star         = 75
	SysVerilogHDLParserRULE_attr_port_declaration_semicolon              = 76
	SysVerilogHDLParserRULE_attr_port_declaration                        = 77
	SysVerilogHDLParserRULE_port_declaration                             = 78
	SysVerilogHDLParserRULE_port_description                             = 79
	SysVerilogHDLParserRULE_inout_description                            = 80
	SysVerilogHDLParserRULE_input_description                            = 81
	SysVerilogHDLParserRULE_output_description                           = 82
	SysVerilogHDLParserRULE_ref_description                              = 83
	SysVerilogHDLParserRULE_tf_declaration                               = 84
	SysVerilogHDLParserRULE_inout_declaration                            = 85
	SysVerilogHDLParserRULE_input_declaration                            = 86
	SysVerilogHDLParserRULE_output_declaration                           = 87
	SysVerilogHDLParserRULE_ref_declaration                              = 88
	SysVerilogHDLParserRULE_user_type                                    = 89
	SysVerilogHDLParserRULE_user_type_identifer                          = 90
	SysVerilogHDLParserRULE_dimension_plus                               = 91
	SysVerilogHDLParserRULE_dimension_star                               = 92
	SysVerilogHDLParserRULE_dimension                                    = 93
	SysVerilogHDLParserRULE_range_expression                             = 94
	SysVerilogHDLParserRULE_index_expression                             = 95
	SysVerilogHDLParserRULE_sb_range                                     = 96
	SysVerilogHDLParserRULE_base_increment_range                         = 97
	SysVerilogHDLParserRULE_base_decrement_range                         = 98
	SysVerilogHDLParserRULE_base_expression                              = 99
	SysVerilogHDLParserRULE_net_type                                     = 100
	SysVerilogHDLParserRULE_drive_strength                               = 101
	SysVerilogHDLParserRULE_drive_strength_value_0                       = 102
	SysVerilogHDLParserRULE_drive_strength_value_1                       = 103
	SysVerilogHDLParserRULE_strength0                                    = 104
	SysVerilogHDLParserRULE_strength1                                    = 105
	SysVerilogHDLParserRULE_highz0                                       = 106
	SysVerilogHDLParserRULE_highz1                                       = 107
	SysVerilogHDLParserRULE_charge_strength                              = 108
	SysVerilogHDLParserRULE_charge_size                                  = 109
	SysVerilogHDLParserRULE_list_of_variable_descriptions                = 110
	SysVerilogHDLParserRULE_comma_variable_description_star              = 111
	SysVerilogHDLParserRULE_comma_variable_description                   = 112
	SysVerilogHDLParserRULE_variable_description                         = 113
	SysVerilogHDLParserRULE_variable_identifier                          = 114
	SysVerilogHDLParserRULE_list_of_hierarchical_variable_descriptions   = 115
	SysVerilogHDLParserRULE_comma_hierarchical_variable_description_star = 116
	SysVerilogHDLParserRULE_comma_hierarchical_variable_description      = 117
	SysVerilogHDLParserRULE_hierarchical_variable_description            = 118
	SysVerilogHDLParserRULE_hierarchical_variable_identifier             = 119
	SysVerilogHDLParserRULE_net_declaration                              = 120
	SysVerilogHDLParserRULE_reg_declaration                              = 121
	SysVerilogHDLParserRULE_logic_declaration                            = 122
	SysVerilogHDLParserRULE_bits_type                                    = 123
	SysVerilogHDLParserRULE_bits_declaration                             = 124
	SysVerilogHDLParserRULE_integer_declaration                          = 125
	SysVerilogHDLParserRULE_int_declaration                              = 126
	SysVerilogHDLParserRULE_real_declaration                             = 127
	SysVerilogHDLParserRULE_time_declaration                             = 128
	SysVerilogHDLParserRULE_realtime_declaration                         = 129
	SysVerilogHDLParserRULE_event_declaration                            = 130
	SysVerilogHDLParserRULE_genvar_declaration                           = 131
	SysVerilogHDLParserRULE_usertype_variable_declaration                = 132
	SysVerilogHDLParserRULE_string_declaration                           = 133
	SysVerilogHDLParserRULE_struct_declaration                           = 134
	SysVerilogHDLParserRULE_enum_declaration                             = 135
	SysVerilogHDLParserRULE_function_declaration                         = 136
	SysVerilogHDLParserRULE_function_type                                = 137
	SysVerilogHDLParserRULE_function_identifier                          = 138
	SysVerilogHDLParserRULE_function_interface                           = 139
	SysVerilogHDLParserRULE_function_item_declaration_star               = 140
	SysVerilogHDLParserRULE_function_item_declaration_semicolon          = 141
	SysVerilogHDLParserRULE_function_item_declaration                    = 142
	SysVerilogHDLParserRULE_function_statement                           = 143
	SysVerilogHDLParserRULE_colon_function_identifier                    = 144
	SysVerilogHDLParserRULE_task_declaration                             = 145
	SysVerilogHDLParserRULE_task_identifier                              = 146
	SysVerilogHDLParserRULE_task_interface                               = 147
	SysVerilogHDLParserRULE_task_item_declaration_semicolon              = 148
	SysVerilogHDLParserRULE_task_item_declaration                        = 149
	SysVerilogHDLParserRULE_task_item_declaration_star                   = 150
	SysVerilogHDLParserRULE_task_statement                               = 151
	SysVerilogHDLParserRULE_struct_item_semicolon                        = 152
	SysVerilogHDLParserRULE_struct_item_star                             = 153
	SysVerilogHDLParserRULE_struct_item                                  = 154
	SysVerilogHDLParserRULE_struct_type                                  = 155
	SysVerilogHDLParserRULE_enum_type                                    = 156
	SysVerilogHDLParserRULE_list_of_enum_items                           = 157
	SysVerilogHDLParserRULE_enum_item                                    = 158
	SysVerilogHDLParserRULE_enum_identifier                              = 159
	SysVerilogHDLParserRULE_comma_enum_item_star                         = 160
	SysVerilogHDLParserRULE_comma_enum_item                              = 161
	SysVerilogHDLParserRULE_enumerated_type                              = 162
	SysVerilogHDLParserRULE_module_instantiation                         = 163
	SysVerilogHDLParserRULE_parameter_interface_assignments              = 164
	SysVerilogHDLParserRULE_list_of_interface_assignments                = 165
	SysVerilogHDLParserRULE_list_of_ordered_interface_assignments        = 166
	SysVerilogHDLParserRULE_comma_ordered_interface_assignment_star      = 167
	SysVerilogHDLParserRULE_comma_ordered_interface_assignment           = 168
	SysVerilogHDLParserRULE_ordered_interface_assignment                 = 169
	SysVerilogHDLParserRULE_list_of_named_interface_assignments          = 170
	SysVerilogHDLParserRULE_comma_named_interface_assignment_star        = 171
	SysVerilogHDLParserRULE_comma_named_interface_assignment             = 172
	SysVerilogHDLParserRULE_named_interface_assignment                   = 173
	SysVerilogHDLParserRULE_list_of_module_instances                     = 174
	SysVerilogHDLParserRULE_comma_module_instance_star                   = 175
	SysVerilogHDLParserRULE_comma_module_instance                        = 176
	SysVerilogHDLParserRULE_module_instance                              = 177
	SysVerilogHDLParserRULE_module_instance_identifier                   = 178
	SysVerilogHDLParserRULE_arrayed_identifier                           = 179
	SysVerilogHDLParserRULE_simple_arrayed_identifier                    = 180
	SysVerilogHDLParserRULE_escaped_arrayed_identifier                   = 181
	SysVerilogHDLParserRULE_port_interface_assignments                   = 182
	SysVerilogHDLParserRULE_delay                                        = 183
	SysVerilogHDLParserRULE_list_of_delay_values                         = 184
	SysVerilogHDLParserRULE_comma_delay_value_star                       = 185
	SysVerilogHDLParserRULE_comma_delay_value                            = 186
	SysVerilogHDLParserRULE_delay_value                                  = 187
	SysVerilogHDLParserRULE_pulldown_strength                            = 188
	SysVerilogHDLParserRULE_pullup_strength                              = 189
	SysVerilogHDLParserRULE_gate_instance_identifier                     = 190
	SysVerilogHDLParserRULE_gate_instantiation                           = 191
	SysVerilogHDLParserRULE_enable_gatetype                              = 192
	SysVerilogHDLParserRULE_mos_switchtype                               = 193
	SysVerilogHDLParserRULE_cmos_switchtype                              = 194
	SysVerilogHDLParserRULE_n_output_gatetype                            = 195
	SysVerilogHDLParserRULE_n_input_gatetype                             = 196
	SysVerilogHDLParserRULE_pass_switchtype                              = 197
	SysVerilogHDLParserRULE_pass_enable_switchtype                       = 198
	SysVerilogHDLParserRULE_pulldown_instantiation                       = 199
	SysVerilogHDLParserRULE_pullup_instantiation                         = 200
	SysVerilogHDLParserRULE_enable_instantiation                         = 201
	SysVerilogHDLParserRULE_mos_instantiation                            = 202
	SysVerilogHDLParserRULE_cmos_instantiation                           = 203
	SysVerilogHDLParserRULE_n_output_instantiation                       = 204
	SysVerilogHDLParserRULE_n_input_instantiation                        = 205
	SysVerilogHDLParserRULE_pass_instantiation                           = 206
	SysVerilogHDLParserRULE_pass_enable_instantiation                    = 207
	SysVerilogHDLParserRULE_list_of_pull_gate_instance                   = 208
	SysVerilogHDLParserRULE_list_of_enable_gate_instance                 = 209
	SysVerilogHDLParserRULE_list_of_mos_switch_instance                  = 210
	SysVerilogHDLParserRULE_list_of_cmos_switch_instance                 = 211
	SysVerilogHDLParserRULE_list_of_n_input_gate_instance                = 212
	SysVerilogHDLParserRULE_list_of_n_output_gate_instance               = 213
	SysVerilogHDLParserRULE_list_of_pass_switch_instance                 = 214
	SysVerilogHDLParserRULE_list_of_pass_enable_switch_instance          = 215
	SysVerilogHDLParserRULE_comma_pull_gate_instance_star                = 216
	SysVerilogHDLParserRULE_comma_enable_gate_instance_star              = 217
	SysVerilogHDLParserRULE_comma_mos_switch_instance_star               = 218
	SysVerilogHDLParserRULE_comma_cmos_switch_instance_star              = 219
	SysVerilogHDLParserRULE_comma_n_input_gate_instance_star             = 220
	SysVerilogHDLParserRULE_comma_n_output_gate_instance_star            = 221
	SysVerilogHDLParserRULE_comma_pass_switch_instance_star              = 222
	SysVerilogHDLParserRULE_comma_pass_enable_switch_instance_star       = 223
	SysVerilogHDLParserRULE_comma_pull_gate_instance                     = 224
	SysVerilogHDLParserRULE_comma_enable_gate_instance                   = 225
	SysVerilogHDLParserRULE_comma_mos_switch_instance                    = 226
	SysVerilogHDLParserRULE_comma_cmos_switch_instance                   = 227
	SysVerilogHDLParserRULE_comma_n_input_gate_instance                  = 228
	SysVerilogHDLParserRULE_comma_n_output_gate_instance                 = 229
	SysVerilogHDLParserRULE_comma_pass_switch_instance                   = 230
	SysVerilogHDLParserRULE_comma_pass_enable_switch_instance            = 231
	SysVerilogHDLParserRULE_pull_gate_instance                           = 232
	SysVerilogHDLParserRULE_enable_gate_instance                         = 233
	SysVerilogHDLParserRULE_mos_switch_instance                          = 234
	SysVerilogHDLParserRULE_cmos_switch_instance                         = 235
	SysVerilogHDLParserRULE_n_input_gate_instance                        = 236
	SysVerilogHDLParserRULE_n_output_gate_instance                       = 237
	SysVerilogHDLParserRULE_pass_switch_instance                         = 238
	SysVerilogHDLParserRULE_pass_enable_switch_instance                  = 239
	SysVerilogHDLParserRULE_pull_gate_interface                          = 240
	SysVerilogHDLParserRULE_enable_gate_interface                        = 241
	SysVerilogHDLParserRULE_mos_switch_interface                         = 242
	SysVerilogHDLParserRULE_cmos_switch_interface                        = 243
	SysVerilogHDLParserRULE_n_input_gate_interface                       = 244
	SysVerilogHDLParserRULE_n_output_gate_interface                      = 245
	SysVerilogHDLParserRULE_pass_switch_interface                        = 246
	SysVerilogHDLParserRULE_pass_enable_switch_interface                 = 247
	SysVerilogHDLParserRULE_list_of_input_terminals                      = 248
	SysVerilogHDLParserRULE_list_of_output_terminals                     = 249
	SysVerilogHDLParserRULE_comma_input_terminal_star                    = 250
	SysVerilogHDLParserRULE_comma_output_terminal_star                   = 251
	SysVerilogHDLParserRULE_comma_input_terminal                         = 252
	SysVerilogHDLParserRULE_comma_output_terminal                        = 253
	SysVerilogHDLParserRULE_enable_terminal                              = 254
	SysVerilogHDLParserRULE_input_terminal                               = 255
	SysVerilogHDLParserRULE_inout_terminal                               = 256
	SysVerilogHDLParserRULE_ncontrol_terminal                            = 257
	SysVerilogHDLParserRULE_output_terminal                              = 258
	SysVerilogHDLParserRULE_pcontrol_terminal                            = 259
	SysVerilogHDLParserRULE_statement_star                               = 260
	SysVerilogHDLParserRULE_statement_semicolon                          = 261
	SysVerilogHDLParserRULE_statement                                    = 262
	SysVerilogHDLParserRULE_assignment_statement                         = 263
	SysVerilogHDLParserRULE_flow_control_statement                       = 264
	SysVerilogHDLParserRULE_block_statement                              = 265
	SysVerilogHDLParserRULE_task_call_statement                          = 266
	SysVerilogHDLParserRULE_event_statement                              = 267
	SysVerilogHDLParserRULE_procedural_statement                         = 268
	SysVerilogHDLParserRULE_expression_statement                         = 269
	SysVerilogHDLParserRULE_subroutine_statement                         = 270
	SysVerilogHDLParserRULE_return_statement                             = 271
	SysVerilogHDLParserRULE_null_statement                               = 272
	SysVerilogHDLParserRULE_procedural_continuous_assignments            = 273
	SysVerilogHDLParserRULE_assign_statement                             = 274
	SysVerilogHDLParserRULE_deassign_statement                           = 275
	SysVerilogHDLParserRULE_force_statement                              = 276
	SysVerilogHDLParserRULE_release_statement                            = 277
	SysVerilogHDLParserRULE_procedural_timing_control_statement          = 278
	SysVerilogHDLParserRULE_property_statement                           = 279
	SysVerilogHDLParserRULE_disable_condition_statement                  = 280
	SysVerilogHDLParserRULE_property_expression                          = 281
	SysVerilogHDLParserRULE_procedural_assertion_statement               = 282
	SysVerilogHDLParserRULE_assert_else_statement                        = 283
	SysVerilogHDLParserRULE_assert_statement                             = 284
	SysVerilogHDLParserRULE_system_task_enable                           = 285
	SysVerilogHDLParserRULE_system_task_identifier                       = 286
	SysVerilogHDLParserRULE_task_interface_assignments                   = 287
	SysVerilogHDLParserRULE_task_enable                                  = 288
	SysVerilogHDLParserRULE_hierarchical_task_identifier                 = 289
	SysVerilogHDLParserRULE_disable_statement                            = 290
	SysVerilogHDLParserRULE_hierarchical_block_identifier                = 291
	SysVerilogHDLParserRULE_variable_lvalue                              = 292
	SysVerilogHDLParserRULE_hierarchical_variable_lvalue                 = 293
	SysVerilogHDLParserRULE_variable_concatenation                       = 294
	SysVerilogHDLParserRULE_variable_concatenation_value                 = 295
	SysVerilogHDLParserRULE_comma_vcv_star                               = 296
	SysVerilogHDLParserRULE_blocking_assignment                          = 297
	SysVerilogHDLParserRULE_nonblocking_assignment                       = 298
	SysVerilogHDLParserRULE_prefix_assignment                            = 299
	SysVerilogHDLParserRULE_postfix_assignment                           = 300
	SysVerilogHDLParserRULE_operator_assignment                          = 301
	SysVerilogHDLParserRULE_declarative_assignment                       = 302
	SysVerilogHDLParserRULE_delay_or_event_control                       = 303
	SysVerilogHDLParserRULE_delay_control                                = 304
	SysVerilogHDLParserRULE_event_control                                = 305
	SysVerilogHDLParserRULE_event_control_identifier                     = 306
	SysVerilogHDLParserRULE_event_control_expression                     = 307
	SysVerilogHDLParserRULE_event_expression                             = 308
	SysVerilogHDLParserRULE_single_event_expression                      = 309
	SysVerilogHDLParserRULE_event_expression_edgespec                    = 310
	SysVerilogHDLParserRULE_event_expression_or                          = 311
	SysVerilogHDLParserRULE_list_of_event_expression_comma               = 312
	SysVerilogHDLParserRULE_comma_event_expression_star                  = 313
	SysVerilogHDLParserRULE_comma_event_expression                       = 314
	SysVerilogHDLParserRULE_list_of_event_expression_or                  = 315
	SysVerilogHDLParserRULE_or_event_expression_star                     = 316
	SysVerilogHDLParserRULE_or_event_expression                          = 317
	SysVerilogHDLParserRULE_event_control_wildcard                       = 318
	SysVerilogHDLParserRULE_repeat_event_control                         = 319
	SysVerilogHDLParserRULE_event_trigger                                = 320
	SysVerilogHDLParserRULE_hierarchical_event_identifier                = 321
	SysVerilogHDLParserRULE_event_identifier                             = 322
	SysVerilogHDLParserRULE_wait_statement                               = 323
	SysVerilogHDLParserRULE_attr_generated_instantiation                 = 324
	SysVerilogHDLParserRULE_generated_instantiation                      = 325
	SysVerilogHDLParserRULE_generate_item_star                           = 326
	SysVerilogHDLParserRULE_generate_item                                = 327
	SysVerilogHDLParserRULE_generate_block                               = 328
	SysVerilogHDLParserRULE_generate_colon_block_identifier0             = 329
	SysVerilogHDLParserRULE_generate_colon_block_identifier1             = 330
	SysVerilogHDLParserRULE_generate_colon_block_identifier              = 331
	SysVerilogHDLParserRULE_generate_block_identifier                    = 332
	SysVerilogHDLParserRULE_generate_conditional_statement               = 333
	SysVerilogHDLParserRULE_generate_if_statement                        = 334
	SysVerilogHDLParserRULE_generate_else_statement                      = 335
	SysVerilogHDLParserRULE_generate_loop_statement                      = 336
	SysVerilogHDLParserRULE_generate_forever_loop_statement              = 337
	SysVerilogHDLParserRULE_generate_repeat_loop_statement               = 338
	SysVerilogHDLParserRULE_generate_while_loop_statement                = 339
	SysVerilogHDLParserRULE_generate_do_loop_statement                   = 340
	SysVerilogHDLParserRULE_generate_for_loop_statement                  = 341
	SysVerilogHDLParserRULE_generate_case_statement                      = 342
	SysVerilogHDLParserRULE_generate_case_item_star                      = 343
	SysVerilogHDLParserRULE_generate_case_item                           = 344
	SysVerilogHDLParserRULE_conditional_statement                        = 345
	SysVerilogHDLParserRULE_if_statement                                 = 346
	SysVerilogHDLParserRULE_else_statement                               = 347
	SysVerilogHDLParserRULE_conditional_expression                       = 348
	SysVerilogHDLParserRULE_loop_statement                               = 349
	SysVerilogHDLParserRULE_forever_loop_statement                       = 350
	SysVerilogHDLParserRULE_repeat_loop_statement                        = 351
	SysVerilogHDLParserRULE_while_loop_statement                         = 352
	SysVerilogHDLParserRULE_do_loop_statement                            = 353
	SysVerilogHDLParserRULE_for_loop_statement                           = 354
	SysVerilogHDLParserRULE_loop_init_assignment                         = 355
	SysVerilogHDLParserRULE_loop_terminate_expression                    = 356
	SysVerilogHDLParserRULE_loop_step_assignment                         = 357
	SysVerilogHDLParserRULE_case_statement                               = 358
	SysVerilogHDLParserRULE_case_item_star                               = 359
	SysVerilogHDLParserRULE_case_item                                    = 360
	SysVerilogHDLParserRULE_case_switch                                  = 361
	SysVerilogHDLParserRULE_case_item_key                                = 362
	SysVerilogHDLParserRULE_case_item_key_expression                     = 363
	SysVerilogHDLParserRULE_comma_case_item_key_expression               = 364
	SysVerilogHDLParserRULE_comma_case_item_key_expression_star          = 365
	SysVerilogHDLParserRULE_expression                                   = 366
	SysVerilogHDLParserRULE_single_expression                            = 367
	SysVerilogHDLParserRULE_primary_range                                = 368
	SysVerilogHDLParserRULE_primary                                      = 369
	SysVerilogHDLParserRULE_unary_expression                             = 370
	SysVerilogHDLParserRULE_unary_post_assign_expression                 = 371
	SysVerilogHDLParserRULE_unary_pre_assign_expression                  = 372
	SysVerilogHDLParserRULE_binary_expression                            = 373
	SysVerilogHDLParserRULE_ternary_expression                           = 374
	SysVerilogHDLParserRULE_mintypmax_expression                         = 375
	SysVerilogHDLParserRULE_structured_value                             = 376
	SysVerilogHDLParserRULE_arrayed_structured_value                     = 377
	SysVerilogHDLParserRULE_arrayed_structure_item                       = 378
	SysVerilogHDLParserRULE_comma_arrayed_structure_item                 = 379
	SysVerilogHDLParserRULE_comma_arrayed_structure_item_star            = 380
	SysVerilogHDLParserRULE_arrayed_structure_item_plus                  = 381
	SysVerilogHDLParserRULE_variable_type_cast                           = 382
	SysVerilogHDLParserRULE_width_type_cast                              = 383
	SysVerilogHDLParserRULE_sign_type_cast                               = 384
	SysVerilogHDLParserRULE_null_type_cast                               = 385
	SysVerilogHDLParserRULE_variable_type                                = 386
	SysVerilogHDLParserRULE_type_cast_identifier                         = 387
	SysVerilogHDLParserRULE_type_cast_expression                         = 388
	SysVerilogHDLParserRULE_function_call                                = 389
	SysVerilogHDLParserRULE_hierarchical_function_identifier             = 390
	SysVerilogHDLParserRULE_function_interface_assignments               = 391
	SysVerilogHDLParserRULE_system_function_call                         = 392
	SysVerilogHDLParserRULE_system_function_identifier                   = 393
	SysVerilogHDLParserRULE_constant_function_call                       = 394
	SysVerilogHDLParserRULE_imported_function_call                       = 395
	SysVerilogHDLParserRULE_imported_function_hierarchical_identifier    = 396
	SysVerilogHDLParserRULE_primary_hierarchical_identifier              = 397
	SysVerilogHDLParserRULE_primary_imported_hierarchical_identifier     = 398
	SysVerilogHDLParserRULE_imported_hierarchical_identifier             = 399
	SysVerilogHDLParserRULE_parenthesis_expression                       = 400
	SysVerilogHDLParserRULE_concatenation                                = 401
	SysVerilogHDLParserRULE_multiple_concatenation                       = 402
	SysVerilogHDLParserRULE_comma_expression_plus                        = 403
	SysVerilogHDLParserRULE_comma_expression_star                        = 404
	SysVerilogHDLParserRULE_typedef_declaration                          = 405
	SysVerilogHDLParserRULE_typedef_identifier                           = 406
	SysVerilogHDLParserRULE_typedef_definition                           = 407
	SysVerilogHDLParserRULE_typedef_definition_type                      = 408
	SysVerilogHDLParserRULE_complex_type                                 = 409
	SysVerilogHDLParserRULE_typedef_type                                 = 410
	SysVerilogHDLParserRULE_par_block                                    = 411
	SysVerilogHDLParserRULE_seq_block                                    = 412
	SysVerilogHDLParserRULE_block_identifier                             = 413
	SysVerilogHDLParserRULE_colon_block_identifier                       = 414
	SysVerilogHDLParserRULE_block_item_declaration_star                  = 415
	SysVerilogHDLParserRULE_block_item_declaration_semicolon             = 416
	SysVerilogHDLParserRULE_block_item_declaration                       = 417
	SysVerilogHDLParserRULE_join_keyword                                 = 418
	SysVerilogHDLParserRULE_continuous_assign                            = 419
	SysVerilogHDLParserRULE_list_of_variable_assignments                 = 420
	SysVerilogHDLParserRULE_comma_variable_assignment_star               = 421
	SysVerilogHDLParserRULE_comma_variable_assignment                    = 422
	SysVerilogHDLParserRULE_variable_assignment                          = 423
	SysVerilogHDLParserRULE_initial_construct                            = 424
	SysVerilogHDLParserRULE_final_construct                              = 425
	SysVerilogHDLParserRULE_always_keyword                               = 426
	SysVerilogHDLParserRULE_always_construct                             = 427
	SysVerilogHDLParserRULE_attribute_instance_star                      = 428
	SysVerilogHDLParserRULE_attribute_instance                           = 429
	SysVerilogHDLParserRULE_attr_spec_star                               = 430
	SysVerilogHDLParserRULE_attr_spec                                    = 431
	SysVerilogHDLParserRULE_attr_name                                    = 432
	SysVerilogHDLParserRULE_identifier                                   = 433
	SysVerilogHDLParserRULE_hierarchical_identifier                      = 434
	SysVerilogHDLParserRULE_dot_hierarchical_identifier_branch_item_star = 435
	SysVerilogHDLParserRULE_dot_hierarchical_identifier_branch_item      = 436
	SysVerilogHDLParserRULE_hierarchical_identifier_branch_item          = 437
	SysVerilogHDLParserRULE_timescale_compiler_directive                 = 438
	SysVerilogHDLParserRULE_timeunit_directive                           = 439
	SysVerilogHDLParserRULE_timeprecision_directive                      = 440
	SysVerilogHDLParserRULE_default_nettype_statement                    = 441
	SysVerilogHDLParserRULE_number                                       = 442
	SysVerilogHDLParserRULE_integral_number                              = 443
	SysVerilogHDLParserRULE_real_number                                  = 444
)

// IModule_keywordContext is an interface to support dynamic dispatch.
type IModule_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_keywordContext differentiates from other interfaces.
	IsModule_keywordContext()
}

type Module_keywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_keywordContext() *Module_keywordContext {
	var p = new(Module_keywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_module_keyword
	return p
}

func (*Module_keywordContext) IsModule_keywordContext() {}

func NewModule_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_keywordContext {
	var p = new(Module_keywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_module_keyword

	return p
}

func (s *Module_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_keywordContext) Module_keyword_only() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserModule_keyword_only, 0)
}

func (s *Module_keywordContext) Macromodule() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserMacromodule, 0)
}

func (s *Module_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterModule_keyword(s)
	}
}

func (s *Module_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitModule_keyword(s)
	}
}

func (p *SysVerilogHDLParser) Module_keyword() (localctx IModule_keywordContext) {
	localctx = NewModule_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SysVerilogHDLParserRULE_module_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(890)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SysVerilogHDLParserMacromodule || _la == SysVerilogHDLParserModule_keyword_only) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStruct_keywordContext is an interface to support dynamic dispatch.
type IStruct_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_keywordContext differentiates from other interfaces.
	IsStruct_keywordContext()
}

type Struct_keywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_keywordContext() *Struct_keywordContext {
	var p = new(Struct_keywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_struct_keyword
	return p
}

func (*Struct_keywordContext) IsStruct_keywordContext() {}

func NewStruct_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_keywordContext {
	var p = new(Struct_keywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_struct_keyword

	return p
}

func (s *Struct_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_keywordContext) Struct() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserStruct, 0)
}

func (s *Struct_keywordContext) UnionStruct() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserUnionStruct, 0)
}

func (s *Struct_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterStruct_keyword(s)
	}
}

func (s *Struct_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitStruct_keyword(s)
	}
}

func (p *SysVerilogHDLParser) Struct_keyword() (localctx IStruct_keywordContext) {
	localctx = NewStruct_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SysVerilogHDLParserRULE_struct_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(892)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SysVerilogHDLParserStruct || _la == SysVerilogHDLParserUnionStruct) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAny_case_keywordContext is an interface to support dynamic dispatch.
type IAny_case_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAny_case_keywordContext differentiates from other interfaces.
	IsAny_case_keywordContext()
}

type Any_case_keywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAny_case_keywordContext() *Any_case_keywordContext {
	var p = new(Any_case_keywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_any_case_keyword
	return p
}

func (*Any_case_keywordContext) IsAny_case_keywordContext() {}

func NewAny_case_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Any_case_keywordContext {
	var p = new(Any_case_keywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_any_case_keyword

	return p
}

func (s *Any_case_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Any_case_keywordContext) Case_keyword() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserCase_keyword, 0)
}

func (s *Any_case_keywordContext) Casez() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserCasez, 0)
}

func (s *Any_case_keywordContext) Casex() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserCasex, 0)
}

func (s *Any_case_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Any_case_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Any_case_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAny_case_keyword(s)
	}
}

func (s *Any_case_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAny_case_keyword(s)
	}
}

func (p *SysVerilogHDLParser) Any_case_keyword() (localctx IAny_case_keywordContext) {
	localctx = NewAny_case_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SysVerilogHDLParserRULE_any_case_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(894)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(SysVerilogHDLParserCase_keyword-62))|(1<<(SysVerilogHDLParserCasez-62))|(1<<(SysVerilogHDLParserCasex-62)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISemicolonContext is an interface to support dynamic dispatch.
type ISemicolonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSemicolonContext differentiates from other interfaces.
	IsSemicolonContext()
}

type SemicolonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySemicolonContext() *SemicolonContext {
	var p = new(SemicolonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_semicolon
	return p
}

func (*SemicolonContext) IsSemicolonContext() {}

func NewSemicolonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SemicolonContext {
	var p = new(SemicolonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_semicolon

	return p
}

func (s *SemicolonContext) GetParser() antlr.Parser { return s.parser }

func (s *SemicolonContext) AllSemicolon() []antlr.TerminalNode {
	return s.GetTokens(SysVerilogHDLParserSemicolon)
}

func (s *SemicolonContext) Semicolon(i int) antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSemicolon, i)
}

func (s *SemicolonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SemicolonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SemicolonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterSemicolon(s)
	}
}

func (s *SemicolonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitSemicolon(s)
	}
}

func (p *SysVerilogHDLParser) Semicolon() (localctx ISemicolonContext) {
	localctx = NewSemicolonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SysVerilogHDLParserRULE_semicolon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(900)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(896)
			p.Match(SysVerilogHDLParserSemicolon)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(897)
			p.Match(SysVerilogHDLParserT__0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(898)
			p.Match(SysVerilogHDLParserSemicolon)
		}
		{
			p.SetState(899)
			p.Match(SysVerilogHDLParserSemicolon)
		}

	}

	return localctx
}

// IUnary_operatorContext is an interface to support dynamic dispatch.
type IUnary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_operatorContext differentiates from other interfaces.
	IsUnary_operatorContext()
}

type Unary_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_operatorContext() *Unary_operatorContext {
	var p = new(Unary_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_unary_operator
	return p
}

func (*Unary_operatorContext) IsUnary_operatorContext() {}

func NewUnary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_operatorContext {
	var p = new(Unary_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_unary_operator

	return p
}

func (s *Unary_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_operatorContext) Tilde() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTilde, 0)
}

func (s *Unary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterUnary_operator(s)
	}
}

func (s *Unary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitUnary_operator(s)
	}
}

func (p *SysVerilogHDLParser) Unary_operator() (localctx IUnary_operatorContext) {
	localctx = NewUnary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SysVerilogHDLParserRULE_unary_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(902)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SysVerilogHDLParserT__1)|(1<<SysVerilogHDLParserT__2)|(1<<SysVerilogHDLParserT__3)|(1<<SysVerilogHDLParserT__4)|(1<<SysVerilogHDLParserT__5)|(1<<SysVerilogHDLParserT__6)|(1<<SysVerilogHDLParserT__7)|(1<<SysVerilogHDLParserT__8)|(1<<SysVerilogHDLParserT__9)|(1<<SysVerilogHDLParserT__10))) != 0) || _la == SysVerilogHDLParserTilde) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBinary_operatorContext is an interface to support dynamic dispatch.
type IBinary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinary_operatorContext differentiates from other interfaces.
	IsBinary_operatorContext()
}

type Binary_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinary_operatorContext() *Binary_operatorContext {
	var p = new(Binary_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_binary_operator
	return p
}

func (*Binary_operatorContext) IsBinary_operatorContext() {}

func NewBinary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Binary_operatorContext {
	var p = new(Binary_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_binary_operator

	return p
}

func (s *Binary_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Binary_operatorContext) Star() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserStar, 0)
}

func (s *Binary_operatorContext) Forward_slash() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserForward_slash, 0)
}

func (s *Binary_operatorContext) Left_angle_equals() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserLeft_angle_equals, 0)
}

func (s *Binary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Binary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Binary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterBinary_operator(s)
	}
}

func (s *Binary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitBinary_operator(s)
	}
}

func (p *SysVerilogHDLParser) Binary_operator() (localctx IBinary_operatorContext) {
	localctx = NewBinary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SysVerilogHDLParserRULE_binary_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(904)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SysVerilogHDLParserT__1)|(1<<SysVerilogHDLParserT__2)|(1<<SysVerilogHDLParserT__4)|(1<<SysVerilogHDLParserT__6)|(1<<SysVerilogHDLParserT__8)|(1<<SysVerilogHDLParserT__9)|(1<<SysVerilogHDLParserT__10)|(1<<SysVerilogHDLParserT__11)|(1<<SysVerilogHDLParserT__12)|(1<<SysVerilogHDLParserT__13)|(1<<SysVerilogHDLParserT__14)|(1<<SysVerilogHDLParserT__15)|(1<<SysVerilogHDLParserT__16)|(1<<SysVerilogHDLParserT__17)|(1<<SysVerilogHDLParserT__18)|(1<<SysVerilogHDLParserT__19)|(1<<SysVerilogHDLParserT__20)|(1<<SysVerilogHDLParserT__21)|(1<<SysVerilogHDLParserT__22)|(1<<SysVerilogHDLParserT__23)|(1<<SysVerilogHDLParserT__24)|(1<<SysVerilogHDLParserT__25))) != 0) || (((_la-215)&-(0x1f+1)) == 0 && ((1<<uint((_la-215)))&((1<<(SysVerilogHDLParserForward_slash-215))|(1<<(SysVerilogHDLParserLeft_angle_equals-215))|(1<<(SysVerilogHDLParserStar-215)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUnary_assign_operatorContext is an interface to support dynamic dispatch.
type IUnary_assign_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_assign_operatorContext differentiates from other interfaces.
	IsUnary_assign_operatorContext()
}

type Unary_assign_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_assign_operatorContext() *Unary_assign_operatorContext {
	var p = new(Unary_assign_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_unary_assign_operator
	return p
}

func (*Unary_assign_operatorContext) IsUnary_assign_operatorContext() {}

func NewUnary_assign_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_assign_operatorContext {
	var p = new(Unary_assign_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_unary_assign_operator

	return p
}

func (s *Unary_assign_operatorContext) GetParser() antlr.Parser { return s.parser }
func (s *Unary_assign_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_assign_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_assign_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterUnary_assign_operator(s)
	}
}

func (s *Unary_assign_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitUnary_assign_operator(s)
	}
}

func (p *SysVerilogHDLParser) Unary_assign_operator() (localctx IUnary_assign_operatorContext) {
	localctx = NewUnary_assign_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SysVerilogHDLParserRULE_unary_assign_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(906)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SysVerilogHDLParserT__26 || _la == SysVerilogHDLParserT__27) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBinary_assign_operatorContext is an interface to support dynamic dispatch.
type IBinary_assign_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinary_assign_operatorContext differentiates from other interfaces.
	IsBinary_assign_operatorContext()
}

type Binary_assign_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinary_assign_operatorContext() *Binary_assign_operatorContext {
	var p = new(Binary_assign_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_binary_assign_operator
	return p
}

func (*Binary_assign_operatorContext) IsBinary_assign_operatorContext() {}

func NewBinary_assign_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Binary_assign_operatorContext {
	var p = new(Binary_assign_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_binary_assign_operator

	return p
}

func (s *Binary_assign_operatorContext) GetParser() antlr.Parser { return s.parser }
func (s *Binary_assign_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Binary_assign_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Binary_assign_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterBinary_assign_operator(s)
	}
}

func (s *Binary_assign_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitBinary_assign_operator(s)
	}
}

func (p *SysVerilogHDLParser) Binary_assign_operator() (localctx IBinary_assign_operatorContext) {
	localctx = NewBinary_assign_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SysVerilogHDLParserRULE_binary_assign_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(908)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-29)&-(0x1f+1)) == 0 && ((1<<uint((_la-29)))&((1<<(SysVerilogHDLParserT__28-29))|(1<<(SysVerilogHDLParserT__29-29))|(1<<(SysVerilogHDLParserT__30-29))|(1<<(SysVerilogHDLParserT__31-29)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISource_textContext is an interface to support dynamic dispatch.
type ISource_textContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSource_textContext differentiates from other interfaces.
	IsSource_textContext()
}

type Source_textContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySource_textContext() *Source_textContext {
	var p = new(Source_textContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_source_text
	return p
}

func (*Source_textContext) IsSource_textContext() {}

func NewSource_textContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Source_textContext {
	var p = new(Source_textContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_source_text

	return p
}

func (s *Source_textContext) GetParser() antlr.Parser { return s.parser }

func (s *Source_textContext) Description_star() IDescription_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDescription_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDescription_starContext)
}

func (s *Source_textContext) EOF() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEOF, 0)
}

func (s *Source_textContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Source_textContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Source_textContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterSource_text(s)
	}
}

func (s *Source_textContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitSource_text(s)
	}
}

func (p *SysVerilogHDLParser) Source_text() (localctx ISource_textContext) {
	localctx = NewSource_textContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SysVerilogHDLParserRULE_source_text)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(910)
		p.Description_star()
	}
	{
		p.SetState(911)
		p.Match(SysVerilogHDLParserEOF)
	}

	return localctx
}

// IDescription_starContext is an interface to support dynamic dispatch.
type IDescription_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDescription_starContext differentiates from other interfaces.
	IsDescription_starContext()
}

type Description_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescription_starContext() *Description_starContext {
	var p = new(Description_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_description_star
	return p
}

func (*Description_starContext) IsDescription_starContext() {}

func NewDescription_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Description_starContext {
	var p = new(Description_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_description_star

	return p
}

func (s *Description_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Description_starContext) AllDescription() []IDescriptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDescriptionContext)(nil)).Elem())
	var tst = make([]IDescriptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDescriptionContext)
		}
	}

	return tst
}

func (s *Description_starContext) Description(i int) IDescriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDescriptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *Description_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Description_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Description_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDescription_star(s)
	}
}

func (s *Description_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDescription_star(s)
	}
}

func (p *SysVerilogHDLParser) Description_star() (localctx IDescription_starContext) {
	localctx = NewDescription_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SysVerilogHDLParserRULE_description_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(916)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(SysVerilogHDLParserDefault_nettype-71))|(1<<(SysVerilogHDLParserEnum-71))|(1<<(SysVerilogHDLParserFunction-71)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(SysVerilogHDLParserImport-103))|(1<<(SysVerilogHDLParserMacromodule-103))|(1<<(SysVerilogHDLParserModule_keyword_only-103)))) != 0) || _la == SysVerilogHDLParserPackage || _la == SysVerilogHDLParserTick_timescale || _la == SysVerilogHDLParserTypedef || _la == SysVerilogHDLParserOpen_parenthesis {
		{
			p.SetState(913)
			p.Description()
		}

		p.SetState(918)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IHeader_textContext is an interface to support dynamic dispatch.
type IHeader_textContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHeader_textContext differentiates from other interfaces.
	IsHeader_textContext()
}

type Header_textContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHeader_textContext() *Header_textContext {
	var p = new(Header_textContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_header_text
	return p
}

func (*Header_textContext) IsHeader_textContext() {}

func NewHeader_textContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Header_textContext {
	var p = new(Header_textContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_header_text

	return p
}

func (s *Header_textContext) GetParser() antlr.Parser { return s.parser }

func (s *Header_textContext) Compiler_directive() ICompiler_directiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompiler_directiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompiler_directiveContext)
}

func (s *Header_textContext) Design_attribute() IDesign_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesign_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesign_attributeContext)
}

func (s *Header_textContext) Import_package() IImport_packageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_packageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_packageContext)
}

func (s *Header_textContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Header_textContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Header_textContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterHeader_text(s)
	}
}

func (s *Header_textContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitHeader_text(s)
	}
}

func (p *SysVerilogHDLParser) Header_text() (localctx IHeader_textContext) {
	localctx = NewHeader_textContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SysVerilogHDLParserRULE_header_text)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(922)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserDefault_nettype, SysVerilogHDLParserTick_timescale:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(919)
			p.Compiler_directive()
		}

	case SysVerilogHDLParserOpen_parenthesis:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(920)
			p.Design_attribute()
		}

	case SysVerilogHDLParserImport:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(921)
			p.Import_package()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDesign_attributeContext is an interface to support dynamic dispatch.
type IDesign_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesign_attributeContext differentiates from other interfaces.
	IsDesign_attributeContext()
}

type Design_attributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesign_attributeContext() *Design_attributeContext {
	var p = new(Design_attributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_design_attribute
	return p
}

func (*Design_attributeContext) IsDesign_attributeContext() {}

func NewDesign_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Design_attributeContext {
	var p = new(Design_attributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_design_attribute

	return p
}

func (s *Design_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Design_attributeContext) Attribute_instance() IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Design_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Design_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Design_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDesign_attribute(s)
	}
}

func (s *Design_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDesign_attribute(s)
	}
}

func (p *SysVerilogHDLParser) Design_attribute() (localctx IDesign_attributeContext) {
	localctx = NewDesign_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SysVerilogHDLParserRULE_design_attribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(924)
		p.Attribute_instance()
	}

	return localctx
}

// ICompiler_directiveContext is an interface to support dynamic dispatch.
type ICompiler_directiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompiler_directiveContext differentiates from other interfaces.
	IsCompiler_directiveContext()
}

type Compiler_directiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompiler_directiveContext() *Compiler_directiveContext {
	var p = new(Compiler_directiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_compiler_directive
	return p
}

func (*Compiler_directiveContext) IsCompiler_directiveContext() {}

func NewCompiler_directiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compiler_directiveContext {
	var p = new(Compiler_directiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_compiler_directive

	return p
}

func (s *Compiler_directiveContext) GetParser() antlr.Parser { return s.parser }

func (s *Compiler_directiveContext) Timescale_compiler_directive() ITimescale_compiler_directiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimescale_compiler_directiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimescale_compiler_directiveContext)
}

func (s *Compiler_directiveContext) Default_nettype_statement() IDefault_nettype_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefault_nettype_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefault_nettype_statementContext)
}

func (s *Compiler_directiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compiler_directiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compiler_directiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterCompiler_directive(s)
	}
}

func (s *Compiler_directiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitCompiler_directive(s)
	}
}

func (p *SysVerilogHDLParser) Compiler_directive() (localctx ICompiler_directiveContext) {
	localctx = NewCompiler_directiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SysVerilogHDLParserRULE_compiler_directive)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(928)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserTick_timescale:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(926)
			p.Timescale_compiler_directive()
		}

	case SysVerilogHDLParserDefault_nettype:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(927)
			p.Default_nettype_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDescriptionContext is an interface to support dynamic dispatch.
type IDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDescriptionContext differentiates from other interfaces.
	IsDescriptionContext()
}

type DescriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescriptionContext() *DescriptionContext {
	var p = new(DescriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_description
	return p
}

func (*DescriptionContext) IsDescriptionContext() {}

func NewDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescriptionContext {
	var p = new(DescriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_description

	return p
}

func (s *DescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DescriptionContext) Header_text() IHeader_textContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHeader_textContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHeader_textContext)
}

func (s *DescriptionContext) Package_declaration() IPackage_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_declarationContext)
}

func (s *DescriptionContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *DescriptionContext) Module_declaration() IModule_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_declarationContext)
}

func (s *DescriptionContext) Function_declaration() IFunction_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_declarationContext)
}

func (s *DescriptionContext) Enum_declaration() IEnum_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_declarationContext)
}

func (s *DescriptionContext) Typedef_declaration() ITypedef_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedef_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedef_declarationContext)
}

func (s *DescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDescription(s)
	}
}

func (s *DescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDescription(s)
	}
}

func (p *SysVerilogHDLParser) Description() (localctx IDescriptionContext) {
	localctx = NewDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SysVerilogHDLParserRULE_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(951)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(930)
			p.Header_text()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(931)
			p.Package_declaration()
		}
		p.SetState(933)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SysVerilogHDLParserT__0 || _la == SysVerilogHDLParserSemicolon {
			{
				p.SetState(932)
				p.Semicolon()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(935)
			p.Module_declaration()
		}
		p.SetState(937)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SysVerilogHDLParserT__0 || _la == SysVerilogHDLParserSemicolon {
			{
				p.SetState(936)
				p.Semicolon()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(939)
			p.Function_declaration()
		}
		p.SetState(941)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SysVerilogHDLParserT__0 || _la == SysVerilogHDLParserSemicolon {
			{
				p.SetState(940)
				p.Semicolon()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(943)
			p.Enum_declaration()
		}
		p.SetState(945)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SysVerilogHDLParserT__0 || _la == SysVerilogHDLParserSemicolon {
			{
				p.SetState(944)
				p.Semicolon()
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(947)
			p.Typedef_declaration()
		}
		p.SetState(949)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SysVerilogHDLParserT__0 || _la == SysVerilogHDLParserSemicolon {
			{
				p.SetState(948)
				p.Semicolon()
			}

		}

	}

	return localctx
}

// IModule_declarationContext is an interface to support dynamic dispatch.
type IModule_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_declarationContext differentiates from other interfaces.
	IsModule_declarationContext()
}

type Module_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_declarationContext() *Module_declarationContext {
	var p = new(Module_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_module_declaration
	return p
}

func (*Module_declarationContext) IsModule_declarationContext() {}

func NewModule_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_declarationContext {
	var p = new(Module_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_module_declaration

	return p
}

func (s *Module_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_declarationContext) Attribute_instance_star() IAttribute_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instance_starContext)
}

func (s *Module_declarationContext) Module_keyword() IModule_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_keywordContext)
}

func (s *Module_declarationContext) Module_identifier() IModule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_identifierContext)
}

func (s *Module_declarationContext) Module_interface() IModule_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_interfaceContext)
}

func (s *Module_declarationContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Module_declarationContext) Module_item_star() IModule_item_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_item_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_item_starContext)
}

func (s *Module_declarationContext) Endmodule() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEndmodule, 0)
}

func (s *Module_declarationContext) Colon_module_identifier() IColon_module_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColon_module_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColon_module_identifierContext)
}

func (s *Module_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterModule_declaration(s)
	}
}

func (s *Module_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitModule_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Module_declaration() (localctx IModule_declarationContext) {
	localctx = NewModule_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SysVerilogHDLParserRULE_module_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(953)
		p.Attribute_instance_star()
	}
	{
		p.SetState(954)
		p.Module_keyword()
	}
	{
		p.SetState(955)
		p.Module_identifier()
	}
	{
		p.SetState(956)
		p.Module_interface()
	}
	{
		p.SetState(957)
		p.Semicolon()
	}
	{
		p.SetState(958)
		p.Module_item_star()
	}
	{
		p.SetState(959)
		p.Match(SysVerilogHDLParserEndmodule)
	}
	p.SetState(961)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserColon {
		{
			p.SetState(960)
			p.Colon_module_identifier()
		}

	}

	return localctx
}

// IModule_identifierContext is an interface to support dynamic dispatch.
type IModule_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_identifierContext differentiates from other interfaces.
	IsModule_identifierContext()
}

type Module_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_identifierContext() *Module_identifierContext {
	var p = new(Module_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_module_identifier
	return p
}

func (*Module_identifierContext) IsModule_identifierContext() {}

func NewModule_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_identifierContext {
	var p = new(Module_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_module_identifier

	return p
}

func (s *Module_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Module_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterModule_identifier(s)
	}
}

func (s *Module_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitModule_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Module_identifier() (localctx IModule_identifierContext) {
	localctx = NewModule_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SysVerilogHDLParserRULE_module_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(963)
		p.Identifier()
	}

	return localctx
}

// IModule_interfaceContext is an interface to support dynamic dispatch.
type IModule_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_interfaceContext differentiates from other interfaces.
	IsModule_interfaceContext()
}

type Module_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_interfaceContext() *Module_interfaceContext {
	var p = new(Module_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_module_interface
	return p
}

func (*Module_interfaceContext) IsModule_interfaceContext() {}

func NewModule_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_interfaceContext {
	var p = new(Module_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_module_interface

	return p
}

func (s *Module_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_interfaceContext) Module_parameter_interface() IModule_parameter_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_parameter_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_parameter_interfaceContext)
}

func (s *Module_interfaceContext) Module_port_interface() IModule_port_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_port_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_port_interfaceContext)
}

func (s *Module_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterModule_interface(s)
	}
}

func (s *Module_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitModule_interface(s)
	}
}

func (p *SysVerilogHDLParser) Module_interface() (localctx IModule_interfaceContext) {
	localctx = NewModule_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SysVerilogHDLParserRULE_module_interface)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(966)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserHash {
		{
			p.SetState(965)
			p.Module_parameter_interface()
		}

	}
	p.SetState(969)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserOpen_parenthesis {
		{
			p.SetState(968)
			p.Module_port_interface()
		}

	}

	return localctx
}

// IModule_parameter_interfaceContext is an interface to support dynamic dispatch.
type IModule_parameter_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_parameter_interfaceContext differentiates from other interfaces.
	IsModule_parameter_interfaceContext()
}

type Module_parameter_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_parameter_interfaceContext() *Module_parameter_interfaceContext {
	var p = new(Module_parameter_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_module_parameter_interface
	return p
}

func (*Module_parameter_interfaceContext) IsModule_parameter_interfaceContext() {}

func NewModule_parameter_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_parameter_interfaceContext {
	var p = new(Module_parameter_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_module_parameter_interface

	return p
}

func (s *Module_parameter_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_parameter_interfaceContext) Hash() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserHash, 0)
}

func (s *Module_parameter_interfaceContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Module_parameter_interfaceContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Module_parameter_interfaceContext) List_of_interface_parameters() IList_of_interface_parametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_interface_parametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_interface_parametersContext)
}

func (s *Module_parameter_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_parameter_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_parameter_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterModule_parameter_interface(s)
	}
}

func (s *Module_parameter_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitModule_parameter_interface(s)
	}
}

func (p *SysVerilogHDLParser) Module_parameter_interface() (localctx IModule_parameter_interfaceContext) {
	localctx = NewModule_parameter_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SysVerilogHDLParserRULE_module_parameter_interface)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(971)
		p.Match(SysVerilogHDLParserHash)
	}
	{
		p.SetState(972)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	p.SetState(974)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserParameter || _la == SysVerilogHDLParserEscaped_identifier || _la == SysVerilogHDLParserSimple_identifier {
		{
			p.SetState(973)
			p.List_of_interface_parameters()
		}

	}
	{
		p.SetState(976)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// IModule_port_interfaceContext is an interface to support dynamic dispatch.
type IModule_port_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_port_interfaceContext differentiates from other interfaces.
	IsModule_port_interfaceContext()
}

type Module_port_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_port_interfaceContext() *Module_port_interfaceContext {
	var p = new(Module_port_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_module_port_interface
	return p
}

func (*Module_port_interfaceContext) IsModule_port_interfaceContext() {}

func NewModule_port_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_port_interfaceContext {
	var p = new(Module_port_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_module_port_interface

	return p
}

func (s *Module_port_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_port_interfaceContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Module_port_interfaceContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Module_port_interfaceContext) List_of_interface_ports() IList_of_interface_portsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_interface_portsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_interface_portsContext)
}

func (s *Module_port_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_port_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_port_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterModule_port_interface(s)
	}
}

func (s *Module_port_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitModule_port_interface(s)
	}
}

func (p *SysVerilogHDLParser) Module_port_interface() (localctx IModule_port_interfaceContext) {
	localctx = NewModule_port_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SysVerilogHDLParserRULE_module_port_interface)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(978)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	p.SetState(980)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(SysVerilogHDLParserInout-106))|(1<<(SysVerilogHDLParserInput-106))|(1<<(SysVerilogHDLParserOutput-106)))) != 0) || _la == SysVerilogHDLParserRef || (((_la-202)&-(0x1f+1)) == 0 && ((1<<uint((_la-202)))&((1<<(SysVerilogHDLParserEscaped_identifier-202))|(1<<(SysVerilogHDLParserSimple_identifier-202))|(1<<(SysVerilogHDLParserOpen_parenthesis-202)))) != 0) {
		{
			p.SetState(979)
			p.List_of_interface_ports()
		}

	}
	{
		p.SetState(982)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// IModule_item_starContext is an interface to support dynamic dispatch.
type IModule_item_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_item_starContext differentiates from other interfaces.
	IsModule_item_starContext()
}

type Module_item_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_item_starContext() *Module_item_starContext {
	var p = new(Module_item_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_module_item_star
	return p
}

func (*Module_item_starContext) IsModule_item_starContext() {}

func NewModule_item_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_item_starContext {
	var p = new(Module_item_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_module_item_star

	return p
}

func (s *Module_item_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_item_starContext) AllModule_item() []IModule_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_itemContext)(nil)).Elem())
	var tst = make([]IModule_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_itemContext)
		}
	}

	return tst
}

func (s *Module_item_starContext) Module_item(i int) IModule_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_itemContext)
}

func (s *Module_item_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_item_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_item_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterModule_item_star(s)
	}
}

func (s *Module_item_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitModule_item_star(s)
	}
}

func (p *SysVerilogHDLParser) Module_item_star() (localctx IModule_item_starContext) {
	localctx = NewModule_item_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SysVerilogHDLParserRULE_module_item_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(987)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-49)&-(0x1f+1)) == 0 && ((1<<uint((_la-49)))&((1<<(SysVerilogHDLParserAlways-49))|(1<<(SysVerilogHDLParserAlways_comb-49))|(1<<(SysVerilogHDLParserAlways_ff-49))|(1<<(SysVerilogHDLParserAnd-49))|(1<<(SysVerilogHDLParserAssign-49))|(1<<(SysVerilogHDLParserAutomatic-49))|(1<<(SysVerilogHDLParserBit-49))|(1<<(SysVerilogHDLParserBuf-49))|(1<<(SysVerilogHDLParserBufif0-49))|(1<<(SysVerilogHDLParserBufif1-49))|(1<<(SysVerilogHDLParserByte-49))|(1<<(SysVerilogHDLParserCmos-49))|(1<<(SysVerilogHDLParserConst-49))|(1<<(SysVerilogHDLParserDefault_nettype-49))|(1<<(SysVerilogHDLParserDefparam-49)))) != 0) || (((_la-88)&-(0x1f+1)) == 0 && ((1<<uint((_la-88)))&((1<<(SysVerilogHDLParserEnum-88))|(1<<(SysVerilogHDLParserEvent_keyword-88))|(1<<(SysVerilogHDLParserFinal-88))|(1<<(SysVerilogHDLParserFunction-88))|(1<<(SysVerilogHDLParserGenerate-88))|(1<<(SysVerilogHDLParserGenvar-88))|(1<<(SysVerilogHDLParserImport-88))|(1<<(SysVerilogHDLParserInitial-88))|(1<<(SysVerilogHDLParserInout-88))|(1<<(SysVerilogHDLParserInput-88))|(1<<(SysVerilogHDLParserInt-88))|(1<<(SysVerilogHDLParserInteger-88))|(1<<(SysVerilogHDLParserLocalparam-88))|(1<<(SysVerilogHDLParserLogic-88)))) != 0) || (((_la-122)&-(0x1f+1)) == 0 && ((1<<uint((_la-122)))&((1<<(SysVerilogHDLParserNand-122))|(1<<(SysVerilogHDLParserNmos-122))|(1<<(SysVerilogHDLParserNONE-122))|(1<<(SysVerilogHDLParserNor-122))|(1<<(SysVerilogHDLParserNot-122))|(1<<(SysVerilogHDLParserNotif0-122))|(1<<(SysVerilogHDLParserNotif1-122))|(1<<(SysVerilogHDLParserOr-122))|(1<<(SysVerilogHDLParserOutput-122))|(1<<(SysVerilogHDLParserParameter-122))|(1<<(SysVerilogHDLParserPmos-122))|(1<<(SysVerilogHDLParserPullup-122))|(1<<(SysVerilogHDLParserPulldown-122))|(1<<(SysVerilogHDLParserRcmos-122))|(1<<(SysVerilogHDLParserReal-122))|(1<<(SysVerilogHDLParserRealtime-122))|(1<<(SysVerilogHDLParserRef-122))|(1<<(SysVerilogHDLParserReg-122)))) != 0) || (((_la-154)&-(0x1f+1)) == 0 && ((1<<uint((_la-154)))&((1<<(SysVerilogHDLParserRnmos-154))|(1<<(SysVerilogHDLParserRpmos-154))|(1<<(SysVerilogHDLParserRtran-154))|(1<<(SysVerilogHDLParserRtranif0-154))|(1<<(SysVerilogHDLParserRtranif1-154))|(1<<(SysVerilogHDLParserStatic-154))|(1<<(SysVerilogHDLParserSVString-154))|(1<<(SysVerilogHDLParserStruct-154))|(1<<(SysVerilogHDLParserSupply0-154))|(1<<(SysVerilogHDLParserSupply1-154))|(1<<(SysVerilogHDLParserTask-154))|(1<<(SysVerilogHDLParserTick_timescale-154))|(1<<(SysVerilogHDLParserTime-154))|(1<<(SysVerilogHDLParserTimeprecision-154))|(1<<(SysVerilogHDLParserTimeunit-154))|(1<<(SysVerilogHDLParserTran-154))|(1<<(SysVerilogHDLParserTranif0-154))|(1<<(SysVerilogHDLParserTranif1-154))|(1<<(SysVerilogHDLParserTri-154))|(1<<(SysVerilogHDLParserTri_and-154))|(1<<(SysVerilogHDLParserTri_or-154))|(1<<(SysVerilogHDLParserTri_reg-154))|(1<<(SysVerilogHDLParserTri0-154))|(1<<(SysVerilogHDLParserTri1-154)))) != 0) || (((_la-186)&-(0x1f+1)) == 0 && ((1<<uint((_la-186)))&((1<<(SysVerilogHDLParserTypedef-186))|(1<<(SysVerilogHDLParserUnionStruct-186))|(1<<(SysVerilogHDLParserUwire-186))|(1<<(SysVerilogHDLParserWand-186))|(1<<(SysVerilogHDLParserWire-186))|(1<<(SysVerilogHDLParserWor-186))|(1<<(SysVerilogHDLParserXnor-186))|(1<<(SysVerilogHDLParserXor-186))|(1<<(SysVerilogHDLParserEscaped_identifier-186))|(1<<(SysVerilogHDLParserSimple_identifier-186)))) != 0) || _la == SysVerilogHDLParserOpen_parenthesis {
		{
			p.SetState(984)
			p.Module_item()
		}

		p.SetState(989)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IModule_itemContext is an interface to support dynamic dispatch.
type IModule_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_itemContext differentiates from other interfaces.
	IsModule_itemContext()
}

type Module_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_itemContext() *Module_itemContext {
	var p = new(Module_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_module_item
	return p
}

func (*Module_itemContext) IsModule_itemContext() {}

func NewModule_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_itemContext {
	var p = new(Module_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_module_item

	return p
}

func (s *Module_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_itemContext) Import_package() IImport_packageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_packageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_packageContext)
}

func (s *Module_itemContext) Parameter_item_semicolon() IParameter_item_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_item_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_item_semicolonContext)
}

func (s *Module_itemContext) Attr_port_item_semicolon() IAttr_port_item_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_port_item_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_port_item_semicolonContext)
}

func (s *Module_itemContext) Attr_variable_item_semicolon() IAttr_variable_item_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_variable_item_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_variable_item_semicolonContext)
}

func (s *Module_itemContext) Subroutine_item_semicolon() ISubroutine_item_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubroutine_item_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubroutine_item_semicolonContext)
}

func (s *Module_itemContext) Attr_construct_item() IAttr_construct_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_construct_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_construct_itemContext)
}

func (s *Module_itemContext) Attr_generated_instantiation() IAttr_generated_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_generated_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_generated_instantiationContext)
}

func (s *Module_itemContext) Attr_component_item() IAttr_component_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_component_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_component_itemContext)
}

func (s *Module_itemContext) Compiler_item() ICompiler_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompiler_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompiler_itemContext)
}

func (s *Module_itemContext) Type_item() IType_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_itemContext)
}

func (s *Module_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterModule_item(s)
	}
}

func (s *Module_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitModule_item(s)
	}
}

func (p *SysVerilogHDLParser) Module_item() (localctx IModule_itemContext) {
	localctx = NewModule_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SysVerilogHDLParserRULE_module_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1000)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(990)
			p.Import_package()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(991)
			p.Parameter_item_semicolon()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(992)
			p.Attr_port_item_semicolon()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(993)
			p.Attr_variable_item_semicolon()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(994)
			p.Subroutine_item_semicolon()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(995)
			p.Attr_construct_item()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(996)
			p.Attr_generated_instantiation()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(997)
			p.Attr_component_item()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(998)
			p.Compiler_item()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(999)
			p.Type_item()
		}

	}

	return localctx
}

// IColon_module_identifierContext is an interface to support dynamic dispatch.
type IColon_module_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColon_module_identifierContext differentiates from other interfaces.
	IsColon_module_identifierContext()
}

type Colon_module_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColon_module_identifierContext() *Colon_module_identifierContext {
	var p = new(Colon_module_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_colon_module_identifier
	return p
}

func (*Colon_module_identifierContext) IsColon_module_identifierContext() {}

func NewColon_module_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Colon_module_identifierContext {
	var p = new(Colon_module_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_colon_module_identifier

	return p
}

func (s *Colon_module_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Colon_module_identifierContext) Colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserColon, 0)
}

func (s *Colon_module_identifierContext) Module_identifier() IModule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_identifierContext)
}

func (s *Colon_module_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Colon_module_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Colon_module_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterColon_module_identifier(s)
	}
}

func (s *Colon_module_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitColon_module_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Colon_module_identifier() (localctx IColon_module_identifierContext) {
	localctx = NewColon_module_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SysVerilogHDLParserRULE_colon_module_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1002)
		p.Match(SysVerilogHDLParserColon)
	}
	{
		p.SetState(1003)
		p.Module_identifier()
	}

	return localctx
}

// IPackage_declarationContext is an interface to support dynamic dispatch.
type IPackage_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_declarationContext differentiates from other interfaces.
	IsPackage_declarationContext()
}

type Package_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_declarationContext() *Package_declarationContext {
	var p = new(Package_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_package_declaration
	return p
}

func (*Package_declarationContext) IsPackage_declarationContext() {}

func NewPackage_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_declarationContext {
	var p = new(Package_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_package_declaration

	return p
}

func (s *Package_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_declarationContext) Attribute_instance_star() IAttribute_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instance_starContext)
}

func (s *Package_declarationContext) Package() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserPackage, 0)
}

func (s *Package_declarationContext) Package_identifier() IPackage_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_identifierContext)
}

func (s *Package_declarationContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Package_declarationContext) Package_item_star() IPackage_item_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_item_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_item_starContext)
}

func (s *Package_declarationContext) Endpackage() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEndpackage, 0)
}

func (s *Package_declarationContext) Colon_package_identifier() IColon_package_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColon_package_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColon_package_identifierContext)
}

func (s *Package_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPackage_declaration(s)
	}
}

func (s *Package_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPackage_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Package_declaration() (localctx IPackage_declarationContext) {
	localctx = NewPackage_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SysVerilogHDLParserRULE_package_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1005)
		p.Attribute_instance_star()
	}
	{
		p.SetState(1006)
		p.Match(SysVerilogHDLParserPackage)
	}
	{
		p.SetState(1007)
		p.Package_identifier()
	}
	{
		p.SetState(1008)
		p.Semicolon()
	}
	{
		p.SetState(1009)
		p.Package_item_star()
	}
	{
		p.SetState(1010)
		p.Match(SysVerilogHDLParserEndpackage)
	}
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserColon {
		{
			p.SetState(1011)
			p.Colon_package_identifier()
		}

	}

	return localctx
}

// IPackage_identifierContext is an interface to support dynamic dispatch.
type IPackage_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_identifierContext differentiates from other interfaces.
	IsPackage_identifierContext()
}

type Package_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_identifierContext() *Package_identifierContext {
	var p = new(Package_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_package_identifier
	return p
}

func (*Package_identifierContext) IsPackage_identifierContext() {}

func NewPackage_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_identifierContext {
	var p = new(Package_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_package_identifier

	return p
}

func (s *Package_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Package_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPackage_identifier(s)
	}
}

func (s *Package_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPackage_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Package_identifier() (localctx IPackage_identifierContext) {
	localctx = NewPackage_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SysVerilogHDLParserRULE_package_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1014)
		p.Identifier()
	}

	return localctx
}

// IColon_package_identifierContext is an interface to support dynamic dispatch.
type IColon_package_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColon_package_identifierContext differentiates from other interfaces.
	IsColon_package_identifierContext()
}

type Colon_package_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColon_package_identifierContext() *Colon_package_identifierContext {
	var p = new(Colon_package_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_colon_package_identifier
	return p
}

func (*Colon_package_identifierContext) IsColon_package_identifierContext() {}

func NewColon_package_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Colon_package_identifierContext {
	var p = new(Colon_package_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_colon_package_identifier

	return p
}

func (s *Colon_package_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Colon_package_identifierContext) Colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserColon, 0)
}

func (s *Colon_package_identifierContext) Package_identifier() IPackage_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_identifierContext)
}

func (s *Colon_package_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Colon_package_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Colon_package_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterColon_package_identifier(s)
	}
}

func (s *Colon_package_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitColon_package_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Colon_package_identifier() (localctx IColon_package_identifierContext) {
	localctx = NewColon_package_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SysVerilogHDLParserRULE_colon_package_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1016)
		p.Match(SysVerilogHDLParserColon)
	}
	{
		p.SetState(1017)
		p.Package_identifier()
	}

	return localctx
}

// IPackage_item_starContext is an interface to support dynamic dispatch.
type IPackage_item_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_item_starContext differentiates from other interfaces.
	IsPackage_item_starContext()
}

type Package_item_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_item_starContext() *Package_item_starContext {
	var p = new(Package_item_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_package_item_star
	return p
}

func (*Package_item_starContext) IsPackage_item_starContext() {}

func NewPackage_item_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_item_starContext {
	var p = new(Package_item_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_package_item_star

	return p
}

func (s *Package_item_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_item_starContext) AllPackage_item() []IPackage_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_itemContext)(nil)).Elem())
	var tst = make([]IPackage_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_itemContext)
		}
	}

	return tst
}

func (s *Package_item_starContext) Package_item(i int) IPackage_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_itemContext)
}

func (s *Package_item_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_item_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_item_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPackage_item_star(s)
	}
}

func (s *Package_item_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPackage_item_star(s)
	}
}

func (p *SysVerilogHDLParser) Package_item_star() (localctx IPackage_item_starContext) {
	localctx = NewPackage_item_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SysVerilogHDLParserRULE_package_item_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1022)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-52)&-(0x1f+1)) == 0 && ((1<<uint((_la-52)))&((1<<(SysVerilogHDLParserAnd-52))|(1<<(SysVerilogHDLParserAutomatic-52))|(1<<(SysVerilogHDLParserBit-52))|(1<<(SysVerilogHDLParserBuf-52))|(1<<(SysVerilogHDLParserBufif0-52))|(1<<(SysVerilogHDLParserBufif1-52))|(1<<(SysVerilogHDLParserByte-52))|(1<<(SysVerilogHDLParserCmos-52))|(1<<(SysVerilogHDLParserConst-52))|(1<<(SysVerilogHDLParserDefault_nettype-52))|(1<<(SysVerilogHDLParserDefparam-52)))) != 0) || (((_la-88)&-(0x1f+1)) == 0 && ((1<<uint((_la-88)))&((1<<(SysVerilogHDLParserEnum-88))|(1<<(SysVerilogHDLParserEvent_keyword-88))|(1<<(SysVerilogHDLParserFunction-88))|(1<<(SysVerilogHDLParserGenvar-88))|(1<<(SysVerilogHDLParserImport-88))|(1<<(SysVerilogHDLParserInt-88))|(1<<(SysVerilogHDLParserInteger-88))|(1<<(SysVerilogHDLParserLocalparam-88))|(1<<(SysVerilogHDLParserLogic-88)))) != 0) || (((_la-122)&-(0x1f+1)) == 0 && ((1<<uint((_la-122)))&((1<<(SysVerilogHDLParserNand-122))|(1<<(SysVerilogHDLParserNmos-122))|(1<<(SysVerilogHDLParserNONE-122))|(1<<(SysVerilogHDLParserNor-122))|(1<<(SysVerilogHDLParserNot-122))|(1<<(SysVerilogHDLParserNotif0-122))|(1<<(SysVerilogHDLParserNotif1-122))|(1<<(SysVerilogHDLParserOr-122))|(1<<(SysVerilogHDLParserParameter-122))|(1<<(SysVerilogHDLParserPmos-122))|(1<<(SysVerilogHDLParserPullup-122))|(1<<(SysVerilogHDLParserPulldown-122))|(1<<(SysVerilogHDLParserRcmos-122))|(1<<(SysVerilogHDLParserReal-122))|(1<<(SysVerilogHDLParserRealtime-122))|(1<<(SysVerilogHDLParserReg-122)))) != 0) || (((_la-154)&-(0x1f+1)) == 0 && ((1<<uint((_la-154)))&((1<<(SysVerilogHDLParserRnmos-154))|(1<<(SysVerilogHDLParserRpmos-154))|(1<<(SysVerilogHDLParserRtran-154))|(1<<(SysVerilogHDLParserRtranif0-154))|(1<<(SysVerilogHDLParserRtranif1-154))|(1<<(SysVerilogHDLParserStatic-154))|(1<<(SysVerilogHDLParserSVString-154))|(1<<(SysVerilogHDLParserStruct-154))|(1<<(SysVerilogHDLParserSupply0-154))|(1<<(SysVerilogHDLParserSupply1-154))|(1<<(SysVerilogHDLParserTask-154))|(1<<(SysVerilogHDLParserTick_timescale-154))|(1<<(SysVerilogHDLParserTime-154))|(1<<(SysVerilogHDLParserTimeprecision-154))|(1<<(SysVerilogHDLParserTimeunit-154))|(1<<(SysVerilogHDLParserTran-154))|(1<<(SysVerilogHDLParserTranif0-154))|(1<<(SysVerilogHDLParserTranif1-154))|(1<<(SysVerilogHDLParserTri-154))|(1<<(SysVerilogHDLParserTri_and-154))|(1<<(SysVerilogHDLParserTri_or-154))|(1<<(SysVerilogHDLParserTri_reg-154))|(1<<(SysVerilogHDLParserTri0-154))|(1<<(SysVerilogHDLParserTri1-154)))) != 0) || (((_la-186)&-(0x1f+1)) == 0 && ((1<<uint((_la-186)))&((1<<(SysVerilogHDLParserTypedef-186))|(1<<(SysVerilogHDLParserUnionStruct-186))|(1<<(SysVerilogHDLParserUwire-186))|(1<<(SysVerilogHDLParserWand-186))|(1<<(SysVerilogHDLParserWire-186))|(1<<(SysVerilogHDLParserWor-186))|(1<<(SysVerilogHDLParserXnor-186))|(1<<(SysVerilogHDLParserXor-186))|(1<<(SysVerilogHDLParserEscaped_identifier-186))|(1<<(SysVerilogHDLParserSimple_identifier-186)))) != 0) || _la == SysVerilogHDLParserOpen_parenthesis {
		{
			p.SetState(1019)
			p.Package_item()
		}

		p.SetState(1024)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPackage_itemContext is an interface to support dynamic dispatch.
type IPackage_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_itemContext differentiates from other interfaces.
	IsPackage_itemContext()
}

type Package_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_itemContext() *Package_itemContext {
	var p = new(Package_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_package_item
	return p
}

func (*Package_itemContext) IsPackage_itemContext() {}

func NewPackage_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_itemContext {
	var p = new(Package_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_package_item

	return p
}

func (s *Package_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_itemContext) Import_package() IImport_packageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_packageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_packageContext)
}

func (s *Package_itemContext) Parameter_item_semicolon() IParameter_item_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_item_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_item_semicolonContext)
}

func (s *Package_itemContext) Attr_variable_item_semicolon() IAttr_variable_item_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_variable_item_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_variable_item_semicolonContext)
}

func (s *Package_itemContext) Subroutine_item_semicolon() ISubroutine_item_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubroutine_item_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubroutine_item_semicolonContext)
}

func (s *Package_itemContext) Attr_component_item() IAttr_component_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_component_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_component_itemContext)
}

func (s *Package_itemContext) Compiler_item() ICompiler_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompiler_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompiler_itemContext)
}

func (s *Package_itemContext) Type_item() IType_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_itemContext)
}

func (s *Package_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPackage_item(s)
	}
}

func (s *Package_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPackage_item(s)
	}
}

func (p *SysVerilogHDLParser) Package_item() (localctx IPackage_itemContext) {
	localctx = NewPackage_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SysVerilogHDLParserRULE_package_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1032)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1025)
			p.Import_package()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1026)
			p.Parameter_item_semicolon()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1027)
			p.Attr_variable_item_semicolon()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1028)
			p.Subroutine_item_semicolon()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1029)
			p.Attr_component_item()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1030)
			p.Compiler_item()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1031)
			p.Type_item()
		}

	}

	return localctx
}

// IImport_packageContext is an interface to support dynamic dispatch.
type IImport_packageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_packageContext differentiates from other interfaces.
	IsImport_packageContext()
}

type Import_packageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_packageContext() *Import_packageContext {
	var p = new(Import_packageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_import_package
	return p
}

func (*Import_packageContext) IsImport_packageContext() {}

func NewImport_packageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_packageContext {
	var p = new(Import_packageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_import_package

	return p
}

func (s *Import_packageContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_packageContext) Import() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserImport, 0)
}

func (s *Import_packageContext) Package_identifier() IPackage_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_identifierContext)
}

func (s *Import_packageContext) Double_colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDouble_colon, 0)
}

func (s *Import_packageContext) Star() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserStar, 0)
}

func (s *Import_packageContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Import_packageContext) Package_item_identifier() IPackage_item_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_item_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_item_identifierContext)
}

func (s *Import_packageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_packageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_packageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterImport_package(s)
	}
}

func (s *Import_packageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitImport_package(s)
	}
}

func (p *SysVerilogHDLParser) Import_package() (localctx IImport_packageContext) {
	localctx = NewImport_packageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SysVerilogHDLParserRULE_import_package)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1046)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1034)
			p.Match(SysVerilogHDLParserImport)
		}
		{
			p.SetState(1035)
			p.Package_identifier()
		}
		{
			p.SetState(1036)
			p.Match(SysVerilogHDLParserDouble_colon)
		}
		{
			p.SetState(1037)
			p.Match(SysVerilogHDLParserStar)
		}
		{
			p.SetState(1038)
			p.Semicolon()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1040)
			p.Match(SysVerilogHDLParserImport)
		}
		{
			p.SetState(1041)
			p.Package_identifier()
		}
		{
			p.SetState(1042)
			p.Match(SysVerilogHDLParserDouble_colon)
		}
		{
			p.SetState(1043)
			p.Package_item_identifier()
		}
		{
			p.SetState(1044)
			p.Semicolon()
		}

	}

	return localctx
}

// IPackage_item_identifierContext is an interface to support dynamic dispatch.
type IPackage_item_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_item_identifierContext differentiates from other interfaces.
	IsPackage_item_identifierContext()
}

type Package_item_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_item_identifierContext() *Package_item_identifierContext {
	var p = new(Package_item_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_package_item_identifier
	return p
}

func (*Package_item_identifierContext) IsPackage_item_identifierContext() {}

func NewPackage_item_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_item_identifierContext {
	var p = new(Package_item_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_package_item_identifier

	return p
}

func (s *Package_item_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_item_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Package_item_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_item_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_item_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPackage_item_identifier(s)
	}
}

func (s *Package_item_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPackage_item_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Package_item_identifier() (localctx IPackage_item_identifierContext) {
	localctx = NewPackage_item_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SysVerilogHDLParserRULE_package_item_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1048)
		p.Identifier()
	}

	return localctx
}

// IParameter_item_semicolonContext is an interface to support dynamic dispatch.
type IParameter_item_semicolonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_item_semicolonContext differentiates from other interfaces.
	IsParameter_item_semicolonContext()
}

type Parameter_item_semicolonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_item_semicolonContext() *Parameter_item_semicolonContext {
	var p = new(Parameter_item_semicolonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_parameter_item_semicolon
	return p
}

func (*Parameter_item_semicolonContext) IsParameter_item_semicolonContext() {}

func NewParameter_item_semicolonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_item_semicolonContext {
	var p = new(Parameter_item_semicolonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_parameter_item_semicolon

	return p
}

func (s *Parameter_item_semicolonContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_item_semicolonContext) Parameter_item() IParameter_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_itemContext)
}

func (s *Parameter_item_semicolonContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Parameter_item_semicolonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_item_semicolonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_item_semicolonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterParameter_item_semicolon(s)
	}
}

func (s *Parameter_item_semicolonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitParameter_item_semicolon(s)
	}
}

func (p *SysVerilogHDLParser) Parameter_item_semicolon() (localctx IParameter_item_semicolonContext) {
	localctx = NewParameter_item_semicolonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SysVerilogHDLParserRULE_parameter_item_semicolon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1050)
		p.Parameter_item()
	}
	{
		p.SetState(1051)
		p.Semicolon()
	}

	return localctx
}

// IParameter_itemContext is an interface to support dynamic dispatch.
type IParameter_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_itemContext differentiates from other interfaces.
	IsParameter_itemContext()
}

type Parameter_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_itemContext() *Parameter_itemContext {
	var p = new(Parameter_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_parameter_item
	return p
}

func (*Parameter_itemContext) IsParameter_itemContext() {}

func NewParameter_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_itemContext {
	var p = new(Parameter_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_parameter_item

	return p
}

func (s *Parameter_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_itemContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Parameter_itemContext) Local_parameter_declaration() ILocal_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocal_parameter_declarationContext)
}

func (s *Parameter_itemContext) Parameter_override() IParameter_overrideContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_overrideContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_overrideContext)
}

func (s *Parameter_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterParameter_item(s)
	}
}

func (s *Parameter_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitParameter_item(s)
	}
}

func (p *SysVerilogHDLParser) Parameter_item() (localctx IParameter_itemContext) {
	localctx = NewParameter_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SysVerilogHDLParserRULE_parameter_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1056)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserParameter:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1053)
			p.Parameter_declaration()
		}

	case SysVerilogHDLParserLocalparam:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1054)
			p.Local_parameter_declaration()
		}

	case SysVerilogHDLParserDefparam:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1055)
			p.Parameter_override()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttr_port_item_semicolonContext is an interface to support dynamic dispatch.
type IAttr_port_item_semicolonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_port_item_semicolonContext differentiates from other interfaces.
	IsAttr_port_item_semicolonContext()
}

type Attr_port_item_semicolonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_port_item_semicolonContext() *Attr_port_item_semicolonContext {
	var p = new(Attr_port_item_semicolonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attr_port_item_semicolon
	return p
}

func (*Attr_port_item_semicolonContext) IsAttr_port_item_semicolonContext() {}

func NewAttr_port_item_semicolonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_port_item_semicolonContext {
	var p = new(Attr_port_item_semicolonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attr_port_item_semicolon

	return p
}

func (s *Attr_port_item_semicolonContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_port_item_semicolonContext) Attribute_instance_star() IAttribute_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instance_starContext)
}

func (s *Attr_port_item_semicolonContext) Port_declaration() IPort_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_declarationContext)
}

func (s *Attr_port_item_semicolonContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Attr_port_item_semicolonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_port_item_semicolonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_port_item_semicolonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttr_port_item_semicolon(s)
	}
}

func (s *Attr_port_item_semicolonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttr_port_item_semicolon(s)
	}
}

func (p *SysVerilogHDLParser) Attr_port_item_semicolon() (localctx IAttr_port_item_semicolonContext) {
	localctx = NewAttr_port_item_semicolonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SysVerilogHDLParserRULE_attr_port_item_semicolon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1058)
		p.Attribute_instance_star()
	}
	{
		p.SetState(1059)
		p.Port_declaration()
	}
	{
		p.SetState(1060)
		p.Semicolon()
	}

	return localctx
}

// IAttr_variable_item_semicolonContext is an interface to support dynamic dispatch.
type IAttr_variable_item_semicolonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_variable_item_semicolonContext differentiates from other interfaces.
	IsAttr_variable_item_semicolonContext()
}

type Attr_variable_item_semicolonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_variable_item_semicolonContext() *Attr_variable_item_semicolonContext {
	var p = new(Attr_variable_item_semicolonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attr_variable_item_semicolon
	return p
}

func (*Attr_variable_item_semicolonContext) IsAttr_variable_item_semicolonContext() {}

func NewAttr_variable_item_semicolonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_variable_item_semicolonContext {
	var p = new(Attr_variable_item_semicolonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attr_variable_item_semicolon

	return p
}

func (s *Attr_variable_item_semicolonContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_variable_item_semicolonContext) Attribute_instance_star() IAttribute_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instance_starContext)
}

func (s *Attr_variable_item_semicolonContext) Variable_item() IVariable_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_itemContext)
}

func (s *Attr_variable_item_semicolonContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Attr_variable_item_semicolonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_variable_item_semicolonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_variable_item_semicolonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttr_variable_item_semicolon(s)
	}
}

func (s *Attr_variable_item_semicolonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttr_variable_item_semicolon(s)
	}
}

func (p *SysVerilogHDLParser) Attr_variable_item_semicolon() (localctx IAttr_variable_item_semicolonContext) {
	localctx = NewAttr_variable_item_semicolonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SysVerilogHDLParserRULE_attr_variable_item_semicolon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1062)
		p.Attribute_instance_star()
	}
	{
		p.SetState(1063)
		p.Variable_item()
	}
	{
		p.SetState(1064)
		p.Semicolon()
	}

	return localctx
}

// IVariable_itemContext is an interface to support dynamic dispatch.
type IVariable_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_itemContext differentiates from other interfaces.
	IsVariable_itemContext()
}

type Variable_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_itemContext() *Variable_itemContext {
	var p = new(Variable_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_variable_item
	return p
}

func (*Variable_itemContext) IsVariable_itemContext() {}

func NewVariable_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_itemContext {
	var p = new(Variable_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_variable_item

	return p
}

func (s *Variable_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_itemContext) Net_declaration() INet_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_declarationContext)
}

func (s *Variable_itemContext) Reg_declaration() IReg_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReg_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReg_declarationContext)
}

func (s *Variable_itemContext) Logic_declaration() ILogic_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogic_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogic_declarationContext)
}

func (s *Variable_itemContext) Bits_declaration() IBits_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBits_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBits_declarationContext)
}

func (s *Variable_itemContext) Integer_declaration() IInteger_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_declarationContext)
}

func (s *Variable_itemContext) Int_declaration() IInt_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_declarationContext)
}

func (s *Variable_itemContext) Real_declaration() IReal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_declarationContext)
}

func (s *Variable_itemContext) Time_declaration() ITime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITime_declarationContext)
}

func (s *Variable_itemContext) Realtime_declaration() IRealtime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRealtime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRealtime_declarationContext)
}

func (s *Variable_itemContext) Event_declaration() IEvent_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_declarationContext)
}

func (s *Variable_itemContext) Genvar_declaration() IGenvar_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_declarationContext)
}

func (s *Variable_itemContext) Usertype_variable_declaration() IUsertype_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUsertype_variable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUsertype_variable_declarationContext)
}

func (s *Variable_itemContext) String_declaration() IString_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_declarationContext)
}

func (s *Variable_itemContext) Struct_declaration() IStruct_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_declarationContext)
}

func (s *Variable_itemContext) Enum_declaration() IEnum_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_declarationContext)
}

func (s *Variable_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterVariable_item(s)
	}
}

func (s *Variable_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitVariable_item(s)
	}
}

func (p *SysVerilogHDLParser) Variable_item() (localctx IVariable_itemContext) {
	localctx = NewVariable_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SysVerilogHDLParserRULE_variable_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1081)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1066)
			p.Net_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1067)
			p.Reg_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1068)
			p.Logic_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1069)
			p.Bits_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1070)
			p.Integer_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1071)
			p.Int_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1072)
			p.Real_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1073)
			p.Time_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1074)
			p.Realtime_declaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1075)
			p.Event_declaration()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1076)
			p.Genvar_declaration()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1077)
			p.Usertype_variable_declaration()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1078)
			p.String_declaration()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1079)
			p.Struct_declaration()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1080)
			p.Enum_declaration()
		}

	}

	return localctx
}

// ISubroutine_item_semicolonContext is an interface to support dynamic dispatch.
type ISubroutine_item_semicolonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubroutine_item_semicolonContext differentiates from other interfaces.
	IsSubroutine_item_semicolonContext()
}

type Subroutine_item_semicolonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubroutine_item_semicolonContext() *Subroutine_item_semicolonContext {
	var p = new(Subroutine_item_semicolonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_subroutine_item_semicolon
	return p
}

func (*Subroutine_item_semicolonContext) IsSubroutine_item_semicolonContext() {}

func NewSubroutine_item_semicolonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subroutine_item_semicolonContext {
	var p = new(Subroutine_item_semicolonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_subroutine_item_semicolon

	return p
}

func (s *Subroutine_item_semicolonContext) GetParser() antlr.Parser { return s.parser }

func (s *Subroutine_item_semicolonContext) Subroutine_item() ISubroutine_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubroutine_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubroutine_itemContext)
}

func (s *Subroutine_item_semicolonContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Subroutine_item_semicolonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subroutine_item_semicolonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subroutine_item_semicolonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterSubroutine_item_semicolon(s)
	}
}

func (s *Subroutine_item_semicolonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitSubroutine_item_semicolon(s)
	}
}

func (p *SysVerilogHDLParser) Subroutine_item_semicolon() (localctx ISubroutine_item_semicolonContext) {
	localctx = NewSubroutine_item_semicolonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SysVerilogHDLParserRULE_subroutine_item_semicolon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1083)
		p.Subroutine_item()
	}
	p.SetState(1085)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1084)
			p.Semicolon()
		}

	}

	return localctx
}

// ISubroutine_itemContext is an interface to support dynamic dispatch.
type ISubroutine_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubroutine_itemContext differentiates from other interfaces.
	IsSubroutine_itemContext()
}

type Subroutine_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubroutine_itemContext() *Subroutine_itemContext {
	var p = new(Subroutine_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_subroutine_item
	return p
}

func (*Subroutine_itemContext) IsSubroutine_itemContext() {}

func NewSubroutine_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subroutine_itemContext {
	var p = new(Subroutine_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_subroutine_item

	return p
}

func (s *Subroutine_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Subroutine_itemContext) Task_declaration() ITask_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_declarationContext)
}

func (s *Subroutine_itemContext) Function_declaration() IFunction_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_declarationContext)
}

func (s *Subroutine_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subroutine_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subroutine_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterSubroutine_item(s)
	}
}

func (s *Subroutine_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitSubroutine_item(s)
	}
}

func (p *SysVerilogHDLParser) Subroutine_item() (localctx ISubroutine_itemContext) {
	localctx = NewSubroutine_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SysVerilogHDLParserRULE_subroutine_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1089)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserTask:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1087)
			p.Task_declaration()
		}

	case SysVerilogHDLParserFunction:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1088)
			p.Function_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttr_construct_itemContext is an interface to support dynamic dispatch.
type IAttr_construct_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_construct_itemContext differentiates from other interfaces.
	IsAttr_construct_itemContext()
}

type Attr_construct_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_construct_itemContext() *Attr_construct_itemContext {
	var p = new(Attr_construct_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attr_construct_item
	return p
}

func (*Attr_construct_itemContext) IsAttr_construct_itemContext() {}

func NewAttr_construct_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_construct_itemContext {
	var p = new(Attr_construct_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attr_construct_item

	return p
}

func (s *Attr_construct_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_construct_itemContext) Attribute_instance_star() IAttribute_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instance_starContext)
}

func (s *Attr_construct_itemContext) Construct_item() IConstruct_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstruct_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstruct_itemContext)
}

func (s *Attr_construct_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_construct_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_construct_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttr_construct_item(s)
	}
}

func (s *Attr_construct_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttr_construct_item(s)
	}
}

func (p *SysVerilogHDLParser) Attr_construct_item() (localctx IAttr_construct_itemContext) {
	localctx = NewAttr_construct_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SysVerilogHDLParserRULE_attr_construct_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1091)
		p.Attribute_instance_star()
	}
	{
		p.SetState(1092)
		p.Construct_item()
	}

	return localctx
}

// IConstruct_itemContext is an interface to support dynamic dispatch.
type IConstruct_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstruct_itemContext differentiates from other interfaces.
	IsConstruct_itemContext()
}

type Construct_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstruct_itemContext() *Construct_itemContext {
	var p = new(Construct_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_construct_item
	return p
}

func (*Construct_itemContext) IsConstruct_itemContext() {}

func NewConstruct_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Construct_itemContext {
	var p = new(Construct_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_construct_item

	return p
}

func (s *Construct_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Construct_itemContext) Continuous_assign() IContinuous_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinuous_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinuous_assignContext)
}

func (s *Construct_itemContext) Initial_construct() IInitial_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitial_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitial_constructContext)
}

func (s *Construct_itemContext) Final_construct() IFinal_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinal_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinal_constructContext)
}

func (s *Construct_itemContext) Always_construct() IAlways_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlways_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlways_constructContext)
}

func (s *Construct_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Construct_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Construct_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterConstruct_item(s)
	}
}

func (s *Construct_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitConstruct_item(s)
	}
}

func (p *SysVerilogHDLParser) Construct_item() (localctx IConstruct_itemContext) {
	localctx = NewConstruct_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SysVerilogHDLParserRULE_construct_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1098)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserAssign:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1094)
			p.Continuous_assign()
		}

	case SysVerilogHDLParserInitial:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1095)
			p.Initial_construct()
		}

	case SysVerilogHDLParserFinal:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1096)
			p.Final_construct()
		}

	case SysVerilogHDLParserAlways, SysVerilogHDLParserAlways_comb, SysVerilogHDLParserAlways_ff:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1097)
			p.Always_construct()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttr_component_itemContext is an interface to support dynamic dispatch.
type IAttr_component_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_component_itemContext differentiates from other interfaces.
	IsAttr_component_itemContext()
}

type Attr_component_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_component_itemContext() *Attr_component_itemContext {
	var p = new(Attr_component_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attr_component_item
	return p
}

func (*Attr_component_itemContext) IsAttr_component_itemContext() {}

func NewAttr_component_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_component_itemContext {
	var p = new(Attr_component_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attr_component_item

	return p
}

func (s *Attr_component_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_component_itemContext) Attribute_instance_star() IAttribute_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instance_starContext)
}

func (s *Attr_component_itemContext) Component_item() IComponent_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_itemContext)
}

func (s *Attr_component_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_component_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_component_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttr_component_item(s)
	}
}

func (s *Attr_component_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttr_component_item(s)
	}
}

func (p *SysVerilogHDLParser) Attr_component_item() (localctx IAttr_component_itemContext) {
	localctx = NewAttr_component_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SysVerilogHDLParserRULE_attr_component_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1100)
		p.Attribute_instance_star()
	}
	{
		p.SetState(1101)
		p.Component_item()
	}

	return localctx
}

// IComponent_itemContext is an interface to support dynamic dispatch.
type IComponent_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_itemContext differentiates from other interfaces.
	IsComponent_itemContext()
}

type Component_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_itemContext() *Component_itemContext {
	var p = new(Component_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_component_item
	return p
}

func (*Component_itemContext) IsComponent_itemContext() {}

func NewComponent_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_itemContext {
	var p = new(Component_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_component_item

	return p
}

func (s *Component_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_itemContext) Module_instantiation() IModule_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_instantiationContext)
}

func (s *Component_itemContext) Gate_instantiation() IGate_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGate_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGate_instantiationContext)
}

func (s *Component_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComponent_item(s)
	}
}

func (s *Component_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComponent_item(s)
	}
}

func (p *SysVerilogHDLParser) Component_item() (localctx IComponent_itemContext) {
	localctx = NewComponent_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SysVerilogHDLParserRULE_component_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1105)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1103)
			p.Module_instantiation()
		}

	case SysVerilogHDLParserAnd, SysVerilogHDLParserBuf, SysVerilogHDLParserBufif0, SysVerilogHDLParserBufif1, SysVerilogHDLParserCmos, SysVerilogHDLParserNand, SysVerilogHDLParserNmos, SysVerilogHDLParserNor, SysVerilogHDLParserNot, SysVerilogHDLParserNotif0, SysVerilogHDLParserNotif1, SysVerilogHDLParserOr, SysVerilogHDLParserPmos, SysVerilogHDLParserPullup, SysVerilogHDLParserPulldown, SysVerilogHDLParserRcmos, SysVerilogHDLParserRnmos, SysVerilogHDLParserRpmos, SysVerilogHDLParserRtran, SysVerilogHDLParserRtranif0, SysVerilogHDLParserRtranif1, SysVerilogHDLParserTran, SysVerilogHDLParserTranif0, SysVerilogHDLParserTranif1, SysVerilogHDLParserXnor, SysVerilogHDLParserXor:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1104)
			p.Gate_instantiation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICompiler_itemContext is an interface to support dynamic dispatch.
type ICompiler_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompiler_itemContext differentiates from other interfaces.
	IsCompiler_itemContext()
}

type Compiler_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompiler_itemContext() *Compiler_itemContext {
	var p = new(Compiler_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_compiler_item
	return p
}

func (*Compiler_itemContext) IsCompiler_itemContext() {}

func NewCompiler_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compiler_itemContext {
	var p = new(Compiler_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_compiler_item

	return p
}

func (s *Compiler_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Compiler_itemContext) Timescale_compiler_directive() ITimescale_compiler_directiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimescale_compiler_directiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimescale_compiler_directiveContext)
}

func (s *Compiler_itemContext) Timeunit_directive() ITimeunit_directiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeunit_directiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeunit_directiveContext)
}

func (s *Compiler_itemContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Compiler_itemContext) Timeprecision_directive() ITimeprecision_directiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeprecision_directiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeprecision_directiveContext)
}

func (s *Compiler_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compiler_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compiler_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterCompiler_item(s)
	}
}

func (s *Compiler_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitCompiler_item(s)
	}
}

func (p *SysVerilogHDLParser) Compiler_item() (localctx ICompiler_itemContext) {
	localctx = NewCompiler_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SysVerilogHDLParserRULE_compiler_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1114)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserTick_timescale:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1107)
			p.Timescale_compiler_directive()
		}

	case SysVerilogHDLParserTimeunit:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1108)
			p.Timeunit_directive()
		}
		{
			p.SetState(1109)
			p.Semicolon()
		}

	case SysVerilogHDLParserTimeprecision:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1111)
			p.Timeprecision_directive()
		}
		{
			p.SetState(1112)
			p.Semicolon()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IType_itemContext is an interface to support dynamic dispatch.
type IType_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_itemContext differentiates from other interfaces.
	IsType_itemContext()
}

type Type_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_itemContext() *Type_itemContext {
	var p = new(Type_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_type_item
	return p
}

func (*Type_itemContext) IsType_itemContext() {}

func NewType_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_itemContext {
	var p = new(Type_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_type_item

	return p
}

func (s *Type_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_itemContext) Default_nettype_statement() IDefault_nettype_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefault_nettype_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefault_nettype_statementContext)
}

func (s *Type_itemContext) Typedef_declaration() ITypedef_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedef_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedef_declarationContext)
}

func (s *Type_itemContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Type_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterType_item(s)
	}
}

func (s *Type_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitType_item(s)
	}
}

func (p *SysVerilogHDLParser) Type_item() (localctx IType_itemContext) {
	localctx = NewType_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SysVerilogHDLParserRULE_type_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1120)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserDefault_nettype:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1116)
			p.Default_nettype_statement()
		}

	case SysVerilogHDLParserTypedef:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1117)
			p.Typedef_declaration()
		}
		{
			p.SetState(1118)
			p.Semicolon()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INull_itemContext is an interface to support dynamic dispatch.
type INull_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNull_itemContext differentiates from other interfaces.
	IsNull_itemContext()
}

type Null_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_itemContext() *Null_itemContext {
	var p = new(Null_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_null_item
	return p
}

func (*Null_itemContext) IsNull_itemContext() {}

func NewNull_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_itemContext {
	var p = new(Null_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_null_item

	return p
}

func (s *Null_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Null_itemContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Null_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Null_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterNull_item(s)
	}
}

func (s *Null_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitNull_item(s)
	}
}

func (p *SysVerilogHDLParser) Null_item() (localctx INull_itemContext) {
	localctx = NewNull_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SysVerilogHDLParserRULE_null_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1122)
		p.Semicolon()
	}

	return localctx
}

// IList_of_interface_parametersContext is an interface to support dynamic dispatch.
type IList_of_interface_parametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_interface_parametersContext differentiates from other interfaces.
	IsList_of_interface_parametersContext()
}

type List_of_interface_parametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_interface_parametersContext() *List_of_interface_parametersContext {
	var p = new(List_of_interface_parametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_interface_parameters
	return p
}

func (*List_of_interface_parametersContext) IsList_of_interface_parametersContext() {}

func NewList_of_interface_parametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_interface_parametersContext {
	var p = new(List_of_interface_parametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_interface_parameters

	return p
}

func (s *List_of_interface_parametersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_interface_parametersContext) List_of_parameter_declarations() IList_of_parameter_declarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_parameter_declarationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_parameter_declarationsContext)
}

func (s *List_of_interface_parametersContext) List_of_parameter_descriptions() IList_of_parameter_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_parameter_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_parameter_descriptionsContext)
}

func (s *List_of_interface_parametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_interface_parametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_interface_parametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_interface_parameters(s)
	}
}

func (s *List_of_interface_parametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_interface_parameters(s)
	}
}

func (p *SysVerilogHDLParser) List_of_interface_parameters() (localctx IList_of_interface_parametersContext) {
	localctx = NewList_of_interface_parametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SysVerilogHDLParserRULE_list_of_interface_parameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1126)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserParameter:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1124)
			p.List_of_parameter_declarations()
		}

	case SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1125)
			p.List_of_parameter_descriptions()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_of_parameter_declarationsContext is an interface to support dynamic dispatch.
type IList_of_parameter_declarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_parameter_declarationsContext differentiates from other interfaces.
	IsList_of_parameter_declarationsContext()
}

type List_of_parameter_declarationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_parameter_declarationsContext() *List_of_parameter_declarationsContext {
	var p = new(List_of_parameter_declarationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_parameter_declarations
	return p
}

func (*List_of_parameter_declarationsContext) IsList_of_parameter_declarationsContext() {}

func NewList_of_parameter_declarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_parameter_declarationsContext {
	var p = new(List_of_parameter_declarationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_parameter_declarations

	return p
}

func (s *List_of_parameter_declarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_parameter_declarationsContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *List_of_parameter_declarationsContext) Comma_parameter_declaration_star() IComma_parameter_declaration_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_parameter_declaration_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_parameter_declaration_starContext)
}

func (s *List_of_parameter_declarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_parameter_declarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_parameter_declarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_parameter_declarations(s)
	}
}

func (s *List_of_parameter_declarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_parameter_declarations(s)
	}
}

func (p *SysVerilogHDLParser) List_of_parameter_declarations() (localctx IList_of_parameter_declarationsContext) {
	localctx = NewList_of_parameter_declarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SysVerilogHDLParserRULE_list_of_parameter_declarations)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1128)
		p.Parameter_declaration()
	}
	{
		p.SetState(1129)
		p.Comma_parameter_declaration_star()
	}

	return localctx
}

// IComma_parameter_declaration_starContext is an interface to support dynamic dispatch.
type IComma_parameter_declaration_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_parameter_declaration_starContext differentiates from other interfaces.
	IsComma_parameter_declaration_starContext()
}

type Comma_parameter_declaration_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_parameter_declaration_starContext() *Comma_parameter_declaration_starContext {
	var p = new(Comma_parameter_declaration_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_parameter_declaration_star
	return p
}

func (*Comma_parameter_declaration_starContext) IsComma_parameter_declaration_starContext() {}

func NewComma_parameter_declaration_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_parameter_declaration_starContext {
	var p = new(Comma_parameter_declaration_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_parameter_declaration_star

	return p
}

func (s *Comma_parameter_declaration_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_parameter_declaration_starContext) AllComma_parameter_declaration() []IComma_parameter_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_parameter_declarationContext)(nil)).Elem())
	var tst = make([]IComma_parameter_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_parameter_declarationContext)
		}
	}

	return tst
}

func (s *Comma_parameter_declaration_starContext) Comma_parameter_declaration(i int) IComma_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_parameter_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_parameter_declarationContext)
}

func (s *Comma_parameter_declaration_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_parameter_declaration_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_parameter_declaration_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_parameter_declaration_star(s)
	}
}

func (s *Comma_parameter_declaration_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_parameter_declaration_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_parameter_declaration_star() (localctx IComma_parameter_declaration_starContext) {
	localctx = NewComma_parameter_declaration_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SysVerilogHDLParserRULE_comma_parameter_declaration_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1134)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(1131)
			p.Comma_parameter_declaration()
		}

		p.SetState(1136)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_parameter_declarationContext is an interface to support dynamic dispatch.
type IComma_parameter_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_parameter_declarationContext differentiates from other interfaces.
	IsComma_parameter_declarationContext()
}

type Comma_parameter_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_parameter_declarationContext() *Comma_parameter_declarationContext {
	var p = new(Comma_parameter_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_parameter_declaration
	return p
}

func (*Comma_parameter_declarationContext) IsComma_parameter_declarationContext() {}

func NewComma_parameter_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_parameter_declarationContext {
	var p = new(Comma_parameter_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_parameter_declaration

	return p
}

func (s *Comma_parameter_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_parameter_declarationContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_parameter_declarationContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Comma_parameter_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_parameter_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_parameter_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_parameter_declaration(s)
	}
}

func (s *Comma_parameter_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_parameter_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Comma_parameter_declaration() (localctx IComma_parameter_declarationContext) {
	localctx = NewComma_parameter_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SysVerilogHDLParserRULE_comma_parameter_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1137)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(1138)
		p.Parameter_declaration()
	}

	return localctx
}

// IList_of_parameter_descriptionsContext is an interface to support dynamic dispatch.
type IList_of_parameter_descriptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_parameter_descriptionsContext differentiates from other interfaces.
	IsList_of_parameter_descriptionsContext()
}

type List_of_parameter_descriptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_parameter_descriptionsContext() *List_of_parameter_descriptionsContext {
	var p = new(List_of_parameter_descriptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_parameter_descriptions
	return p
}

func (*List_of_parameter_descriptionsContext) IsList_of_parameter_descriptionsContext() {}

func NewList_of_parameter_descriptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_parameter_descriptionsContext {
	var p = new(List_of_parameter_descriptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_parameter_descriptions

	return p
}

func (s *List_of_parameter_descriptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_parameter_descriptionsContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *List_of_parameter_descriptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_parameter_descriptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_parameter_descriptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_parameter_descriptions(s)
	}
}

func (s *List_of_parameter_descriptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_parameter_descriptions(s)
	}
}

func (p *SysVerilogHDLParser) List_of_parameter_descriptions() (localctx IList_of_parameter_descriptionsContext) {
	localctx = NewList_of_parameter_descriptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SysVerilogHDLParserRULE_list_of_parameter_descriptions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1140)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// IParam_declarationContext is an interface to support dynamic dispatch.
type IParam_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_declarationContext differentiates from other interfaces.
	IsParam_declarationContext()
}

type Param_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_declarationContext() *Param_declarationContext {
	var p = new(Param_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_param_declaration
	return p
}

func (*Param_declarationContext) IsParam_declarationContext() {}

func NewParam_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_declarationContext {
	var p = new(Param_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_param_declaration

	return p
}

func (s *Param_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_declarationContext) List_of_hierarchical_variable_descriptions() IList_of_hierarchical_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_hierarchical_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_hierarchical_variable_descriptionsContext)
}

func (s *Param_declarationContext) Dimension_plus() IDimension_plusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimension_plusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimension_plusContext)
}

func (s *Param_declarationContext) Signed() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSigned, 0)
}

func (s *Param_declarationContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserUnsigned, 0)
}

func (s *Param_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterParam_declaration(s)
	}
}

func (s *Param_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitParam_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Param_declaration() (localctx IParam_declarationContext) {
	localctx = NewParam_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SysVerilogHDLParserRULE_param_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1143)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned {
		{
			p.SetState(1142)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1146)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserLeft_bracket {
		{
			p.SetState(1145)
			p.Dimension_plus()
		}

	}
	{
		p.SetState(1148)
		p.List_of_hierarchical_variable_descriptions()
	}

	return localctx
}

// IParam_descriptionContext is an interface to support dynamic dispatch.
type IParam_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_descriptionContext differentiates from other interfaces.
	IsParam_descriptionContext()
}

type Param_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_descriptionContext() *Param_descriptionContext {
	var p = new(Param_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_param_description
	return p
}

func (*Param_descriptionContext) IsParam_descriptionContext() {}

func NewParam_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_descriptionContext {
	var p = new(Param_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_param_description

	return p
}

func (s *Param_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_descriptionContext) Param_declaration() IParam_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_declarationContext)
}

func (s *Param_descriptionContext) Logic_declaration() ILogic_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogic_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogic_declarationContext)
}

func (s *Param_descriptionContext) Integer_declaration() IInteger_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_declarationContext)
}

func (s *Param_descriptionContext) Int_declaration() IInt_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_declarationContext)
}

func (s *Param_descriptionContext) Real_declaration() IReal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_declarationContext)
}

func (s *Param_descriptionContext) Time_declaration() ITime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITime_declarationContext)
}

func (s *Param_descriptionContext) Realtime_declaration() IRealtime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRealtime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRealtime_declarationContext)
}

func (s *Param_descriptionContext) Usertype_variable_declaration() IUsertype_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUsertype_variable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUsertype_variable_declarationContext)
}

func (s *Param_descriptionContext) String_declaration() IString_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_declarationContext)
}

func (s *Param_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterParam_description(s)
	}
}

func (s *Param_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitParam_description(s)
	}
}

func (p *SysVerilogHDLParser) Param_description() (localctx IParam_descriptionContext) {
	localctx = NewParam_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SysVerilogHDLParserRULE_param_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1159)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1150)
			p.Param_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1151)
			p.Logic_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1152)
			p.Integer_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1153)
			p.Int_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1154)
			p.Real_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1155)
			p.Time_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1156)
			p.Realtime_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1157)
			p.Usertype_variable_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1158)
			p.String_declaration()
		}

	}

	return localctx
}

// IParameter_declarationContext is an interface to support dynamic dispatch.
type IParameter_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declarationContext differentiates from other interfaces.
	IsParameter_declarationContext()
}

type Parameter_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declarationContext() *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_parameter_declaration
	return p
}

func (*Parameter_declarationContext) IsParameter_declarationContext() {}

func NewParameter_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_parameter_declaration

	return p
}

func (s *Parameter_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declarationContext) Parameter() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserParameter, 0)
}

func (s *Parameter_declarationContext) Param_description() IParam_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_descriptionContext)
}

func (s *Parameter_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterParameter_declaration(s)
	}
}

func (s *Parameter_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitParameter_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Parameter_declaration() (localctx IParameter_declarationContext) {
	localctx = NewParameter_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SysVerilogHDLParserRULE_parameter_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1161)
		p.Match(SysVerilogHDLParserParameter)
	}
	{
		p.SetState(1162)
		p.Param_description()
	}

	return localctx
}

// ILocal_parameter_declarationContext is an interface to support dynamic dispatch.
type ILocal_parameter_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocal_parameter_declarationContext differentiates from other interfaces.
	IsLocal_parameter_declarationContext()
}

type Local_parameter_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocal_parameter_declarationContext() *Local_parameter_declarationContext {
	var p = new(Local_parameter_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_local_parameter_declaration
	return p
}

func (*Local_parameter_declarationContext) IsLocal_parameter_declarationContext() {}

func NewLocal_parameter_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Local_parameter_declarationContext {
	var p = new(Local_parameter_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_local_parameter_declaration

	return p
}

func (s *Local_parameter_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Local_parameter_declarationContext) Localparam() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserLocalparam, 0)
}

func (s *Local_parameter_declarationContext) Param_description() IParam_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_descriptionContext)
}

func (s *Local_parameter_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Local_parameter_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Local_parameter_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterLocal_parameter_declaration(s)
	}
}

func (s *Local_parameter_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitLocal_parameter_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Local_parameter_declaration() (localctx ILocal_parameter_declarationContext) {
	localctx = NewLocal_parameter_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SysVerilogHDLParserRULE_local_parameter_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1164)
		p.Match(SysVerilogHDLParserLocalparam)
	}
	{
		p.SetState(1165)
		p.Param_description()
	}

	return localctx
}

// IParameter_overrideContext is an interface to support dynamic dispatch.
type IParameter_overrideContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_overrideContext differentiates from other interfaces.
	IsParameter_overrideContext()
}

type Parameter_overrideContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_overrideContext() *Parameter_overrideContext {
	var p = new(Parameter_overrideContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_parameter_override
	return p
}

func (*Parameter_overrideContext) IsParameter_overrideContext() {}

func NewParameter_overrideContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_overrideContext {
	var p = new(Parameter_overrideContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_parameter_override

	return p
}

func (s *Parameter_overrideContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_overrideContext) Defparam() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDefparam, 0)
}

func (s *Parameter_overrideContext) Param_description() IParam_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_descriptionContext)
}

func (s *Parameter_overrideContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_overrideContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_overrideContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterParameter_override(s)
	}
}

func (s *Parameter_overrideContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitParameter_override(s)
	}
}

func (p *SysVerilogHDLParser) Parameter_override() (localctx IParameter_overrideContext) {
	localctx = NewParameter_overrideContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SysVerilogHDLParserRULE_parameter_override)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1167)
		p.Match(SysVerilogHDLParserDefparam)
	}
	{
		p.SetState(1168)
		p.Param_description()
	}

	return localctx
}

// IList_of_tf_interface_portsContext is an interface to support dynamic dispatch.
type IList_of_tf_interface_portsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_tf_interface_portsContext differentiates from other interfaces.
	IsList_of_tf_interface_portsContext()
}

type List_of_tf_interface_portsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_tf_interface_portsContext() *List_of_tf_interface_portsContext {
	var p = new(List_of_tf_interface_portsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_tf_interface_ports
	return p
}

func (*List_of_tf_interface_portsContext) IsList_of_tf_interface_portsContext() {}

func NewList_of_tf_interface_portsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_tf_interface_portsContext {
	var p = new(List_of_tf_interface_portsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_tf_interface_ports

	return p
}

func (s *List_of_tf_interface_portsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_tf_interface_portsContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *List_of_tf_interface_portsContext) List_of_tf_port_declarations() IList_of_tf_port_declarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_tf_port_declarationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_tf_port_declarationsContext)
}

func (s *List_of_tf_interface_portsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_tf_interface_portsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_tf_interface_portsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_tf_interface_ports(s)
	}
}

func (s *List_of_tf_interface_portsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_tf_interface_ports(s)
	}
}

func (p *SysVerilogHDLParser) List_of_tf_interface_ports() (localctx IList_of_tf_interface_portsContext) {
	localctx = NewList_of_tf_interface_portsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SysVerilogHDLParserRULE_list_of_tf_interface_ports)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1172)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1170)
			p.List_of_port_identifiers()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1171)
			p.List_of_tf_port_declarations()
		}

	}

	return localctx
}

// IList_of_tf_port_declarationsContext is an interface to support dynamic dispatch.
type IList_of_tf_port_declarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_tf_port_declarationsContext differentiates from other interfaces.
	IsList_of_tf_port_declarationsContext()
}

type List_of_tf_port_declarationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_tf_port_declarationsContext() *List_of_tf_port_declarationsContext {
	var p = new(List_of_tf_port_declarationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_tf_port_declarations
	return p
}

func (*List_of_tf_port_declarationsContext) IsList_of_tf_port_declarationsContext() {}

func NewList_of_tf_port_declarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_tf_port_declarationsContext {
	var p = new(List_of_tf_port_declarationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_tf_port_declarations

	return p
}

func (s *List_of_tf_port_declarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_tf_port_declarationsContext) List_of_tf_port_declarations_comma() IList_of_tf_port_declarations_commaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_tf_port_declarations_commaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_tf_port_declarations_commaContext)
}

func (s *List_of_tf_port_declarationsContext) List_of_tf_port_declarations_semicolon() IList_of_tf_port_declarations_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_tf_port_declarations_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_tf_port_declarations_semicolonContext)
}

func (s *List_of_tf_port_declarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_tf_port_declarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_tf_port_declarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_tf_port_declarations(s)
	}
}

func (s *List_of_tf_port_declarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_tf_port_declarations(s)
	}
}

func (p *SysVerilogHDLParser) List_of_tf_port_declarations() (localctx IList_of_tf_port_declarationsContext) {
	localctx = NewList_of_tf_port_declarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SysVerilogHDLParserRULE_list_of_tf_port_declarations)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1176)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1174)
			p.List_of_tf_port_declarations_comma()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1175)
			p.List_of_tf_port_declarations_semicolon()
		}

	}

	return localctx
}

// IList_of_tf_port_declarations_commaContext is an interface to support dynamic dispatch.
type IList_of_tf_port_declarations_commaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_tf_port_declarations_commaContext differentiates from other interfaces.
	IsList_of_tf_port_declarations_commaContext()
}

type List_of_tf_port_declarations_commaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_tf_port_declarations_commaContext() *List_of_tf_port_declarations_commaContext {
	var p = new(List_of_tf_port_declarations_commaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_tf_port_declarations_comma
	return p
}

func (*List_of_tf_port_declarations_commaContext) IsList_of_tf_port_declarations_commaContext() {}

func NewList_of_tf_port_declarations_commaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_tf_port_declarations_commaContext {
	var p = new(List_of_tf_port_declarations_commaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_tf_port_declarations_comma

	return p
}

func (s *List_of_tf_port_declarations_commaContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_tf_port_declarations_commaContext) Attr_tf_port_declaration() IAttr_tf_port_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_tf_port_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_tf_port_declarationContext)
}

func (s *List_of_tf_port_declarations_commaContext) Comma_attr_tf_port_declaration_star() IComma_attr_tf_port_declaration_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_attr_tf_port_declaration_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_attr_tf_port_declaration_starContext)
}

func (s *List_of_tf_port_declarations_commaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_tf_port_declarations_commaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_tf_port_declarations_commaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_tf_port_declarations_comma(s)
	}
}

func (s *List_of_tf_port_declarations_commaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_tf_port_declarations_comma(s)
	}
}

func (p *SysVerilogHDLParser) List_of_tf_port_declarations_comma() (localctx IList_of_tf_port_declarations_commaContext) {
	localctx = NewList_of_tf_port_declarations_commaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SysVerilogHDLParserRULE_list_of_tf_port_declarations_comma)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1178)
		p.Attr_tf_port_declaration()
	}
	{
		p.SetState(1179)
		p.Comma_attr_tf_port_declaration_star()
	}

	return localctx
}

// IComma_attr_tf_port_declaration_starContext is an interface to support dynamic dispatch.
type IComma_attr_tf_port_declaration_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_attr_tf_port_declaration_starContext differentiates from other interfaces.
	IsComma_attr_tf_port_declaration_starContext()
}

type Comma_attr_tf_port_declaration_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_attr_tf_port_declaration_starContext() *Comma_attr_tf_port_declaration_starContext {
	var p = new(Comma_attr_tf_port_declaration_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_attr_tf_port_declaration_star
	return p
}

func (*Comma_attr_tf_port_declaration_starContext) IsComma_attr_tf_port_declaration_starContext() {}

func NewComma_attr_tf_port_declaration_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_attr_tf_port_declaration_starContext {
	var p = new(Comma_attr_tf_port_declaration_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_attr_tf_port_declaration_star

	return p
}

func (s *Comma_attr_tf_port_declaration_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_attr_tf_port_declaration_starContext) AllComma_attr_tf_port_declaration() []IComma_attr_tf_port_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_attr_tf_port_declarationContext)(nil)).Elem())
	var tst = make([]IComma_attr_tf_port_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_attr_tf_port_declarationContext)
		}
	}

	return tst
}

func (s *Comma_attr_tf_port_declaration_starContext) Comma_attr_tf_port_declaration(i int) IComma_attr_tf_port_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_attr_tf_port_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_attr_tf_port_declarationContext)
}

func (s *Comma_attr_tf_port_declaration_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_attr_tf_port_declaration_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_attr_tf_port_declaration_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_attr_tf_port_declaration_star(s)
	}
}

func (s *Comma_attr_tf_port_declaration_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_attr_tf_port_declaration_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_attr_tf_port_declaration_star() (localctx IComma_attr_tf_port_declaration_starContext) {
	localctx = NewComma_attr_tf_port_declaration_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SysVerilogHDLParserRULE_comma_attr_tf_port_declaration_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1184)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(1181)
			p.Comma_attr_tf_port_declaration()
		}

		p.SetState(1186)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_attr_tf_port_declarationContext is an interface to support dynamic dispatch.
type IComma_attr_tf_port_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_attr_tf_port_declarationContext differentiates from other interfaces.
	IsComma_attr_tf_port_declarationContext()
}

type Comma_attr_tf_port_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_attr_tf_port_declarationContext() *Comma_attr_tf_port_declarationContext {
	var p = new(Comma_attr_tf_port_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_attr_tf_port_declaration
	return p
}

func (*Comma_attr_tf_port_declarationContext) IsComma_attr_tf_port_declarationContext() {}

func NewComma_attr_tf_port_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_attr_tf_port_declarationContext {
	var p = new(Comma_attr_tf_port_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_attr_tf_port_declaration

	return p
}

func (s *Comma_attr_tf_port_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_attr_tf_port_declarationContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_attr_tf_port_declarationContext) Attr_tf_port_declaration() IAttr_tf_port_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_tf_port_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_tf_port_declarationContext)
}

func (s *Comma_attr_tf_port_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_attr_tf_port_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_attr_tf_port_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_attr_tf_port_declaration(s)
	}
}

func (s *Comma_attr_tf_port_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_attr_tf_port_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Comma_attr_tf_port_declaration() (localctx IComma_attr_tf_port_declarationContext) {
	localctx = NewComma_attr_tf_port_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SysVerilogHDLParserRULE_comma_attr_tf_port_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1187)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(1188)
		p.Attr_tf_port_declaration()
	}

	return localctx
}

// IList_of_tf_port_declarations_semicolonContext is an interface to support dynamic dispatch.
type IList_of_tf_port_declarations_semicolonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_tf_port_declarations_semicolonContext differentiates from other interfaces.
	IsList_of_tf_port_declarations_semicolonContext()
}

type List_of_tf_port_declarations_semicolonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_tf_port_declarations_semicolonContext() *List_of_tf_port_declarations_semicolonContext {
	var p = new(List_of_tf_port_declarations_semicolonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_tf_port_declarations_semicolon
	return p
}

func (*List_of_tf_port_declarations_semicolonContext) IsList_of_tf_port_declarations_semicolonContext() {
}

func NewList_of_tf_port_declarations_semicolonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_tf_port_declarations_semicolonContext {
	var p = new(List_of_tf_port_declarations_semicolonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_tf_port_declarations_semicolon

	return p
}

func (s *List_of_tf_port_declarations_semicolonContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_tf_port_declarations_semicolonContext) Attr_tf_port_declaration_semicolon_plus() IAttr_tf_port_declaration_semicolon_plusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_tf_port_declaration_semicolon_plusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_tf_port_declaration_semicolon_plusContext)
}

func (s *List_of_tf_port_declarations_semicolonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_tf_port_declarations_semicolonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_tf_port_declarations_semicolonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_tf_port_declarations_semicolon(s)
	}
}

func (s *List_of_tf_port_declarations_semicolonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_tf_port_declarations_semicolon(s)
	}
}

func (p *SysVerilogHDLParser) List_of_tf_port_declarations_semicolon() (localctx IList_of_tf_port_declarations_semicolonContext) {
	localctx = NewList_of_tf_port_declarations_semicolonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SysVerilogHDLParserRULE_list_of_tf_port_declarations_semicolon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1190)
		p.Attr_tf_port_declaration_semicolon_plus()
	}

	return localctx
}

// IAttr_tf_port_declaration_semicolon_plusContext is an interface to support dynamic dispatch.
type IAttr_tf_port_declaration_semicolon_plusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_tf_port_declaration_semicolon_plusContext differentiates from other interfaces.
	IsAttr_tf_port_declaration_semicolon_plusContext()
}

type Attr_tf_port_declaration_semicolon_plusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_tf_port_declaration_semicolon_plusContext() *Attr_tf_port_declaration_semicolon_plusContext {
	var p = new(Attr_tf_port_declaration_semicolon_plusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attr_tf_port_declaration_semicolon_plus
	return p
}

func (*Attr_tf_port_declaration_semicolon_plusContext) IsAttr_tf_port_declaration_semicolon_plusContext() {
}

func NewAttr_tf_port_declaration_semicolon_plusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_tf_port_declaration_semicolon_plusContext {
	var p = new(Attr_tf_port_declaration_semicolon_plusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attr_tf_port_declaration_semicolon_plus

	return p
}

func (s *Attr_tf_port_declaration_semicolon_plusContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_tf_port_declaration_semicolon_plusContext) AllAttr_tf_port_declaration_semicolon() []IAttr_tf_port_declaration_semicolonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttr_tf_port_declaration_semicolonContext)(nil)).Elem())
	var tst = make([]IAttr_tf_port_declaration_semicolonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttr_tf_port_declaration_semicolonContext)
		}
	}

	return tst
}

func (s *Attr_tf_port_declaration_semicolon_plusContext) Attr_tf_port_declaration_semicolon(i int) IAttr_tf_port_declaration_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_tf_port_declaration_semicolonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttr_tf_port_declaration_semicolonContext)
}

func (s *Attr_tf_port_declaration_semicolon_plusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_tf_port_declaration_semicolon_plusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_tf_port_declaration_semicolon_plusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttr_tf_port_declaration_semicolon_plus(s)
	}
}

func (s *Attr_tf_port_declaration_semicolon_plusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttr_tf_port_declaration_semicolon_plus(s)
	}
}

func (p *SysVerilogHDLParser) Attr_tf_port_declaration_semicolon_plus() (localctx IAttr_tf_port_declaration_semicolon_plusContext) {
	localctx = NewAttr_tf_port_declaration_semicolon_plusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SysVerilogHDLParserRULE_attr_tf_port_declaration_semicolon_plus)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1193)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-55)&-(0x1f+1)) == 0 && ((1<<uint((_la-55)))&((1<<(SysVerilogHDLParserAutomatic-55))|(1<<(SysVerilogHDLParserBit-55))|(1<<(SysVerilogHDLParserByte-55))|(1<<(SysVerilogHDLParserConst-55)))) != 0) || (((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(SysVerilogHDLParserInout-106))|(1<<(SysVerilogHDLParserInput-106))|(1<<(SysVerilogHDLParserInt-106))|(1<<(SysVerilogHDLParserInteger-106))|(1<<(SysVerilogHDLParserLogic-106))|(1<<(SysVerilogHDLParserNONE-106))|(1<<(SysVerilogHDLParserOutput-106)))) != 0) || (((_la-147)&-(0x1f+1)) == 0 && ((1<<uint((_la-147)))&((1<<(SysVerilogHDLParserReal-147))|(1<<(SysVerilogHDLParserRef-147))|(1<<(SysVerilogHDLParserReg-147))|(1<<(SysVerilogHDLParserSigned-147))|(1<<(SysVerilogHDLParserStatic-147))|(1<<(SysVerilogHDLParserSVString-147))|(1<<(SysVerilogHDLParserSupply0-147))|(1<<(SysVerilogHDLParserSupply1-147))|(1<<(SysVerilogHDLParserTime-147)))) != 0) || (((_la-180)&-(0x1f+1)) == 0 && ((1<<uint((_la-180)))&((1<<(SysVerilogHDLParserTri-180))|(1<<(SysVerilogHDLParserTri_and-180))|(1<<(SysVerilogHDLParserTri_or-180))|(1<<(SysVerilogHDLParserTri_reg-180))|(1<<(SysVerilogHDLParserTri0-180))|(1<<(SysVerilogHDLParserTri1-180))|(1<<(SysVerilogHDLParserUnsigned-180))|(1<<(SysVerilogHDLParserUwire-180))|(1<<(SysVerilogHDLParserWand-180))|(1<<(SysVerilogHDLParserWire-180))|(1<<(SysVerilogHDLParserWor-180))|(1<<(SysVerilogHDLParserEscaped_identifier-180))|(1<<(SysVerilogHDLParserSimple_identifier-180)))) != 0) || _la == SysVerilogHDLParserLeft_bracket || _la == SysVerilogHDLParserOpen_parenthesis {
		{
			p.SetState(1192)
			p.Attr_tf_port_declaration_semicolon()
		}

		p.SetState(1195)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAttr_tf_port_declaration_semicolon_starContext is an interface to support dynamic dispatch.
type IAttr_tf_port_declaration_semicolon_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_tf_port_declaration_semicolon_starContext differentiates from other interfaces.
	IsAttr_tf_port_declaration_semicolon_starContext()
}

type Attr_tf_port_declaration_semicolon_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_tf_port_declaration_semicolon_starContext() *Attr_tf_port_declaration_semicolon_starContext {
	var p = new(Attr_tf_port_declaration_semicolon_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attr_tf_port_declaration_semicolon_star
	return p
}

func (*Attr_tf_port_declaration_semicolon_starContext) IsAttr_tf_port_declaration_semicolon_starContext() {
}

func NewAttr_tf_port_declaration_semicolon_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_tf_port_declaration_semicolon_starContext {
	var p = new(Attr_tf_port_declaration_semicolon_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attr_tf_port_declaration_semicolon_star

	return p
}

func (s *Attr_tf_port_declaration_semicolon_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_tf_port_declaration_semicolon_starContext) AllAttr_tf_port_declaration_semicolon() []IAttr_tf_port_declaration_semicolonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttr_tf_port_declaration_semicolonContext)(nil)).Elem())
	var tst = make([]IAttr_tf_port_declaration_semicolonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttr_tf_port_declaration_semicolonContext)
		}
	}

	return tst
}

func (s *Attr_tf_port_declaration_semicolon_starContext) Attr_tf_port_declaration_semicolon(i int) IAttr_tf_port_declaration_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_tf_port_declaration_semicolonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttr_tf_port_declaration_semicolonContext)
}

func (s *Attr_tf_port_declaration_semicolon_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_tf_port_declaration_semicolon_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_tf_port_declaration_semicolon_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttr_tf_port_declaration_semicolon_star(s)
	}
}

func (s *Attr_tf_port_declaration_semicolon_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttr_tf_port_declaration_semicolon_star(s)
	}
}

func (p *SysVerilogHDLParser) Attr_tf_port_declaration_semicolon_star() (localctx IAttr_tf_port_declaration_semicolon_starContext) {
	localctx = NewAttr_tf_port_declaration_semicolon_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SysVerilogHDLParserRULE_attr_tf_port_declaration_semicolon_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1200)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-55)&-(0x1f+1)) == 0 && ((1<<uint((_la-55)))&((1<<(SysVerilogHDLParserAutomatic-55))|(1<<(SysVerilogHDLParserBit-55))|(1<<(SysVerilogHDLParserByte-55))|(1<<(SysVerilogHDLParserConst-55)))) != 0) || (((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(SysVerilogHDLParserInout-106))|(1<<(SysVerilogHDLParserInput-106))|(1<<(SysVerilogHDLParserInt-106))|(1<<(SysVerilogHDLParserInteger-106))|(1<<(SysVerilogHDLParserLogic-106))|(1<<(SysVerilogHDLParserNONE-106))|(1<<(SysVerilogHDLParserOutput-106)))) != 0) || (((_la-147)&-(0x1f+1)) == 0 && ((1<<uint((_la-147)))&((1<<(SysVerilogHDLParserReal-147))|(1<<(SysVerilogHDLParserRef-147))|(1<<(SysVerilogHDLParserReg-147))|(1<<(SysVerilogHDLParserSigned-147))|(1<<(SysVerilogHDLParserStatic-147))|(1<<(SysVerilogHDLParserSVString-147))|(1<<(SysVerilogHDLParserSupply0-147))|(1<<(SysVerilogHDLParserSupply1-147))|(1<<(SysVerilogHDLParserTime-147)))) != 0) || (((_la-180)&-(0x1f+1)) == 0 && ((1<<uint((_la-180)))&((1<<(SysVerilogHDLParserTri-180))|(1<<(SysVerilogHDLParserTri_and-180))|(1<<(SysVerilogHDLParserTri_or-180))|(1<<(SysVerilogHDLParserTri_reg-180))|(1<<(SysVerilogHDLParserTri0-180))|(1<<(SysVerilogHDLParserTri1-180))|(1<<(SysVerilogHDLParserUnsigned-180))|(1<<(SysVerilogHDLParserUwire-180))|(1<<(SysVerilogHDLParserWand-180))|(1<<(SysVerilogHDLParserWire-180))|(1<<(SysVerilogHDLParserWor-180))|(1<<(SysVerilogHDLParserEscaped_identifier-180))|(1<<(SysVerilogHDLParserSimple_identifier-180)))) != 0) || _la == SysVerilogHDLParserLeft_bracket || _la == SysVerilogHDLParserOpen_parenthesis {
		{
			p.SetState(1197)
			p.Attr_tf_port_declaration_semicolon()
		}

		p.SetState(1202)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAttr_tf_port_declaration_semicolonContext is an interface to support dynamic dispatch.
type IAttr_tf_port_declaration_semicolonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_tf_port_declaration_semicolonContext differentiates from other interfaces.
	IsAttr_tf_port_declaration_semicolonContext()
}

type Attr_tf_port_declaration_semicolonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_tf_port_declaration_semicolonContext() *Attr_tf_port_declaration_semicolonContext {
	var p = new(Attr_tf_port_declaration_semicolonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attr_tf_port_declaration_semicolon
	return p
}

func (*Attr_tf_port_declaration_semicolonContext) IsAttr_tf_port_declaration_semicolonContext() {}

func NewAttr_tf_port_declaration_semicolonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_tf_port_declaration_semicolonContext {
	var p = new(Attr_tf_port_declaration_semicolonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attr_tf_port_declaration_semicolon

	return p
}

func (s *Attr_tf_port_declaration_semicolonContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_tf_port_declaration_semicolonContext) Attr_tf_port_declaration() IAttr_tf_port_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_tf_port_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_tf_port_declarationContext)
}

func (s *Attr_tf_port_declaration_semicolonContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Attr_tf_port_declaration_semicolonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_tf_port_declaration_semicolonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_tf_port_declaration_semicolonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttr_tf_port_declaration_semicolon(s)
	}
}

func (s *Attr_tf_port_declaration_semicolonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttr_tf_port_declaration_semicolon(s)
	}
}

func (p *SysVerilogHDLParser) Attr_tf_port_declaration_semicolon() (localctx IAttr_tf_port_declaration_semicolonContext) {
	localctx = NewAttr_tf_port_declaration_semicolonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SysVerilogHDLParserRULE_attr_tf_port_declaration_semicolon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1203)
		p.Attr_tf_port_declaration()
	}
	{
		p.SetState(1204)
		p.Semicolon()
	}

	return localctx
}

// IAttr_tf_port_declarationContext is an interface to support dynamic dispatch.
type IAttr_tf_port_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_tf_port_declarationContext differentiates from other interfaces.
	IsAttr_tf_port_declarationContext()
}

type Attr_tf_port_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_tf_port_declarationContext() *Attr_tf_port_declarationContext {
	var p = new(Attr_tf_port_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attr_tf_port_declaration
	return p
}

func (*Attr_tf_port_declarationContext) IsAttr_tf_port_declarationContext() {}

func NewAttr_tf_port_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_tf_port_declarationContext {
	var p = new(Attr_tf_port_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attr_tf_port_declaration

	return p
}

func (s *Attr_tf_port_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_tf_port_declarationContext) Attribute_instance_star() IAttribute_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instance_starContext)
}

func (s *Attr_tf_port_declarationContext) Tf_port_declaration() ITf_port_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_port_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_port_declarationContext)
}

func (s *Attr_tf_port_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_tf_port_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_tf_port_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttr_tf_port_declaration(s)
	}
}

func (s *Attr_tf_port_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttr_tf_port_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Attr_tf_port_declaration() (localctx IAttr_tf_port_declarationContext) {
	localctx = NewAttr_tf_port_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SysVerilogHDLParserRULE_attr_tf_port_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1206)
		p.Attribute_instance_star()
	}
	{
		p.SetState(1207)
		p.Tf_port_declaration()
	}

	return localctx
}

// ITf_port_declarationContext is an interface to support dynamic dispatch.
type ITf_port_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf_port_declarationContext differentiates from other interfaces.
	IsTf_port_declarationContext()
}

type Tf_port_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf_port_declarationContext() *Tf_port_declarationContext {
	var p = new(Tf_port_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_tf_port_declaration
	return p
}

func (*Tf_port_declarationContext) IsTf_port_declarationContext() {}

func NewTf_port_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf_port_declarationContext {
	var p = new(Tf_port_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_tf_port_declaration

	return p
}

func (s *Tf_port_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf_port_declarationContext) Inout_declaration() IInout_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInout_declarationContext)
}

func (s *Tf_port_declarationContext) Input_declaration() IInput_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_declarationContext)
}

func (s *Tf_port_declarationContext) Output_declaration() IOutput_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_declarationContext)
}

func (s *Tf_port_declarationContext) Ref_declaration() IRef_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRef_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRef_declarationContext)
}

func (s *Tf_port_declarationContext) Tf_declaration() ITf_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_declarationContext)
}

func (s *Tf_port_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf_port_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf_port_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTf_port_declaration(s)
	}
}

func (s *Tf_port_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTf_port_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Tf_port_declaration() (localctx ITf_port_declarationContext) {
	localctx = NewTf_port_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SysVerilogHDLParserRULE_tf_port_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1214)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserInout:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1209)
			p.Inout_declaration()
		}

	case SysVerilogHDLParserInput:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1210)
			p.Input_declaration()
		}

	case SysVerilogHDLParserOutput:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1211)
			p.Output_declaration()
		}

	case SysVerilogHDLParserRef:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1212)
			p.Ref_declaration()
		}

	case SysVerilogHDLParserAutomatic, SysVerilogHDLParserBit, SysVerilogHDLParserByte, SysVerilogHDLParserConst, SysVerilogHDLParserInt, SysVerilogHDLParserInteger, SysVerilogHDLParserLogic, SysVerilogHDLParserNONE, SysVerilogHDLParserReal, SysVerilogHDLParserReg, SysVerilogHDLParserSigned, SysVerilogHDLParserStatic, SysVerilogHDLParserSVString, SysVerilogHDLParserSupply0, SysVerilogHDLParserSupply1, SysVerilogHDLParserTime, SysVerilogHDLParserTri, SysVerilogHDLParserTri_and, SysVerilogHDLParserTri_or, SysVerilogHDLParserTri_reg, SysVerilogHDLParserTri0, SysVerilogHDLParserTri1, SysVerilogHDLParserUnsigned, SysVerilogHDLParserUwire, SysVerilogHDLParserWand, SysVerilogHDLParserWire, SysVerilogHDLParserWor, SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier, SysVerilogHDLParserLeft_bracket:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1213)
			p.Tf_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_of_interface_portsContext is an interface to support dynamic dispatch.
type IList_of_interface_portsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_interface_portsContext differentiates from other interfaces.
	IsList_of_interface_portsContext()
}

type List_of_interface_portsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_interface_portsContext() *List_of_interface_portsContext {
	var p = new(List_of_interface_portsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_interface_ports
	return p
}

func (*List_of_interface_portsContext) IsList_of_interface_portsContext() {}

func NewList_of_interface_portsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_interface_portsContext {
	var p = new(List_of_interface_portsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_interface_ports

	return p
}

func (s *List_of_interface_portsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_interface_portsContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *List_of_interface_portsContext) List_of_port_declarations() IList_of_port_declarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_declarationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_declarationsContext)
}

func (s *List_of_interface_portsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_interface_portsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_interface_portsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_interface_ports(s)
	}
}

func (s *List_of_interface_portsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_interface_ports(s)
	}
}

func (p *SysVerilogHDLParser) List_of_interface_ports() (localctx IList_of_interface_portsContext) {
	localctx = NewList_of_interface_portsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SysVerilogHDLParserRULE_list_of_interface_ports)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1218)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1216)
			p.List_of_port_identifiers()
		}

	case SysVerilogHDLParserInout, SysVerilogHDLParserInput, SysVerilogHDLParserOutput, SysVerilogHDLParserRef, SysVerilogHDLParserOpen_parenthesis:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1217)
			p.List_of_port_declarations()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_of_port_identifiersContext is an interface to support dynamic dispatch.
type IList_of_port_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_port_identifiersContext differentiates from other interfaces.
	IsList_of_port_identifiersContext()
}

type List_of_port_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_port_identifiersContext() *List_of_port_identifiersContext {
	var p = new(List_of_port_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_port_identifiers
	return p
}

func (*List_of_port_identifiersContext) IsList_of_port_identifiersContext() {}

func NewList_of_port_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_port_identifiersContext {
	var p = new(List_of_port_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_port_identifiers

	return p
}

func (s *List_of_port_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_port_identifiersContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *List_of_port_identifiersContext) Comma_port_identifier_star() IComma_port_identifier_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_port_identifier_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_port_identifier_starContext)
}

func (s *List_of_port_identifiersContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *List_of_port_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_port_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_port_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_port_identifiers(s)
	}
}

func (s *List_of_port_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_port_identifiers(s)
	}
}

func (p *SysVerilogHDLParser) List_of_port_identifiers() (localctx IList_of_port_identifiersContext) {
	localctx = NewList_of_port_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SysVerilogHDLParserRULE_list_of_port_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1220)
		p.Port_identifier()
	}
	{
		p.SetState(1221)
		p.Comma_port_identifier_star()
	}
	p.SetState(1223)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserComma {
		{
			p.SetState(1222)
			p.Match(SysVerilogHDLParserComma)
		}

	}

	return localctx
}

// IComma_port_identifier_starContext is an interface to support dynamic dispatch.
type IComma_port_identifier_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_port_identifier_starContext differentiates from other interfaces.
	IsComma_port_identifier_starContext()
}

type Comma_port_identifier_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_port_identifier_starContext() *Comma_port_identifier_starContext {
	var p = new(Comma_port_identifier_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_port_identifier_star
	return p
}

func (*Comma_port_identifier_starContext) IsComma_port_identifier_starContext() {}

func NewComma_port_identifier_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_port_identifier_starContext {
	var p = new(Comma_port_identifier_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_port_identifier_star

	return p
}

func (s *Comma_port_identifier_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_port_identifier_starContext) AllComma_port_identifier() []IComma_port_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_port_identifierContext)(nil)).Elem())
	var tst = make([]IComma_port_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_port_identifierContext)
		}
	}

	return tst
}

func (s *Comma_port_identifier_starContext) Comma_port_identifier(i int) IComma_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_port_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_port_identifierContext)
}

func (s *Comma_port_identifier_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_port_identifier_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_port_identifier_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_port_identifier_star(s)
	}
}

func (s *Comma_port_identifier_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_port_identifier_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_port_identifier_star() (localctx IComma_port_identifier_starContext) {
	localctx = NewComma_port_identifier_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SysVerilogHDLParserRULE_comma_port_identifier_star)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1228)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1225)
				p.Comma_port_identifier()
			}

		}
		p.SetState(1230)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext())
	}

	return localctx
}

// IComma_port_identifierContext is an interface to support dynamic dispatch.
type IComma_port_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_port_identifierContext differentiates from other interfaces.
	IsComma_port_identifierContext()
}

type Comma_port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_port_identifierContext() *Comma_port_identifierContext {
	var p = new(Comma_port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_port_identifier
	return p
}

func (*Comma_port_identifierContext) IsComma_port_identifierContext() {}

func NewComma_port_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_port_identifierContext {
	var p = new(Comma_port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_port_identifier

	return p
}

func (s *Comma_port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_port_identifierContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_port_identifierContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *Comma_port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_port_identifier(s)
	}
}

func (s *Comma_port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_port_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Comma_port_identifier() (localctx IComma_port_identifierContext) {
	localctx = NewComma_port_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SysVerilogHDLParserRULE_comma_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1231)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(1232)
		p.Port_identifier()
	}

	return localctx
}

// IPort_identifierContext is an interface to support dynamic dispatch.
type IPort_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_identifierContext differentiates from other interfaces.
	IsPort_identifierContext()
}

type Port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_identifierContext() *Port_identifierContext {
	var p = new(Port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_port_identifier
	return p
}

func (*Port_identifierContext) IsPort_identifierContext() {}

func NewPort_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_identifierContext {
	var p = new(Port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_port_identifier

	return p
}

func (s *Port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPort_identifier(s)
	}
}

func (s *Port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPort_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Port_identifier() (localctx IPort_identifierContext) {
	localctx = NewPort_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SysVerilogHDLParserRULE_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1234)
		p.Identifier()
	}

	return localctx
}

// IList_of_port_declarationsContext is an interface to support dynamic dispatch.
type IList_of_port_declarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_port_declarationsContext differentiates from other interfaces.
	IsList_of_port_declarationsContext()
}

type List_of_port_declarationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_port_declarationsContext() *List_of_port_declarationsContext {
	var p = new(List_of_port_declarationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_port_declarations
	return p
}

func (*List_of_port_declarationsContext) IsList_of_port_declarationsContext() {}

func NewList_of_port_declarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_port_declarationsContext {
	var p = new(List_of_port_declarationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_port_declarations

	return p
}

func (s *List_of_port_declarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_port_declarationsContext) List_of_port_declarations_comma() IList_of_port_declarations_commaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_declarations_commaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_declarations_commaContext)
}

func (s *List_of_port_declarationsContext) List_of_port_declarations_semicolon() IList_of_port_declarations_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_declarations_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_declarations_semicolonContext)
}

func (s *List_of_port_declarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_port_declarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_port_declarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_port_declarations(s)
	}
}

func (s *List_of_port_declarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_port_declarations(s)
	}
}

func (p *SysVerilogHDLParser) List_of_port_declarations() (localctx IList_of_port_declarationsContext) {
	localctx = NewList_of_port_declarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SysVerilogHDLParserRULE_list_of_port_declarations)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1238)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1236)
			p.List_of_port_declarations_comma()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1237)
			p.List_of_port_declarations_semicolon()
		}

	}

	return localctx
}

// IList_of_port_declarations_commaContext is an interface to support dynamic dispatch.
type IList_of_port_declarations_commaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_port_declarations_commaContext differentiates from other interfaces.
	IsList_of_port_declarations_commaContext()
}

type List_of_port_declarations_commaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_port_declarations_commaContext() *List_of_port_declarations_commaContext {
	var p = new(List_of_port_declarations_commaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_port_declarations_comma
	return p
}

func (*List_of_port_declarations_commaContext) IsList_of_port_declarations_commaContext() {}

func NewList_of_port_declarations_commaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_port_declarations_commaContext {
	var p = new(List_of_port_declarations_commaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_port_declarations_comma

	return p
}

func (s *List_of_port_declarations_commaContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_port_declarations_commaContext) Attr_port_declaration() IAttr_port_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_port_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_port_declarationContext)
}

func (s *List_of_port_declarations_commaContext) Comma_attr_port_declaration_star() IComma_attr_port_declaration_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_attr_port_declaration_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_attr_port_declaration_starContext)
}

func (s *List_of_port_declarations_commaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_port_declarations_commaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_port_declarations_commaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_port_declarations_comma(s)
	}
}

func (s *List_of_port_declarations_commaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_port_declarations_comma(s)
	}
}

func (p *SysVerilogHDLParser) List_of_port_declarations_comma() (localctx IList_of_port_declarations_commaContext) {
	localctx = NewList_of_port_declarations_commaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SysVerilogHDLParserRULE_list_of_port_declarations_comma)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1240)
		p.Attr_port_declaration()
	}
	{
		p.SetState(1241)
		p.Comma_attr_port_declaration_star()
	}

	return localctx
}

// IComma_attr_port_declaration_starContext is an interface to support dynamic dispatch.
type IComma_attr_port_declaration_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_attr_port_declaration_starContext differentiates from other interfaces.
	IsComma_attr_port_declaration_starContext()
}

type Comma_attr_port_declaration_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_attr_port_declaration_starContext() *Comma_attr_port_declaration_starContext {
	var p = new(Comma_attr_port_declaration_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_attr_port_declaration_star
	return p
}

func (*Comma_attr_port_declaration_starContext) IsComma_attr_port_declaration_starContext() {}

func NewComma_attr_port_declaration_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_attr_port_declaration_starContext {
	var p = new(Comma_attr_port_declaration_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_attr_port_declaration_star

	return p
}

func (s *Comma_attr_port_declaration_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_attr_port_declaration_starContext) AllComma_attr_port_declaration() []IComma_attr_port_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_attr_port_declarationContext)(nil)).Elem())
	var tst = make([]IComma_attr_port_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_attr_port_declarationContext)
		}
	}

	return tst
}

func (s *Comma_attr_port_declaration_starContext) Comma_attr_port_declaration(i int) IComma_attr_port_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_attr_port_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_attr_port_declarationContext)
}

func (s *Comma_attr_port_declaration_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_attr_port_declaration_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_attr_port_declaration_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_attr_port_declaration_star(s)
	}
}

func (s *Comma_attr_port_declaration_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_attr_port_declaration_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_attr_port_declaration_star() (localctx IComma_attr_port_declaration_starContext) {
	localctx = NewComma_attr_port_declaration_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SysVerilogHDLParserRULE_comma_attr_port_declaration_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1246)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(1243)
			p.Comma_attr_port_declaration()
		}

		p.SetState(1248)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_attr_port_declarationContext is an interface to support dynamic dispatch.
type IComma_attr_port_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_attr_port_declarationContext differentiates from other interfaces.
	IsComma_attr_port_declarationContext()
}

type Comma_attr_port_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_attr_port_declarationContext() *Comma_attr_port_declarationContext {
	var p = new(Comma_attr_port_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_attr_port_declaration
	return p
}

func (*Comma_attr_port_declarationContext) IsComma_attr_port_declarationContext() {}

func NewComma_attr_port_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_attr_port_declarationContext {
	var p = new(Comma_attr_port_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_attr_port_declaration

	return p
}

func (s *Comma_attr_port_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_attr_port_declarationContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_attr_port_declarationContext) Attr_port_declaration() IAttr_port_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_port_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_port_declarationContext)
}

func (s *Comma_attr_port_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_attr_port_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_attr_port_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_attr_port_declaration(s)
	}
}

func (s *Comma_attr_port_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_attr_port_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Comma_attr_port_declaration() (localctx IComma_attr_port_declarationContext) {
	localctx = NewComma_attr_port_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SysVerilogHDLParserRULE_comma_attr_port_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1249)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(1250)
		p.Attr_port_declaration()
	}

	return localctx
}

// IList_of_port_declarations_semicolonContext is an interface to support dynamic dispatch.
type IList_of_port_declarations_semicolonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_port_declarations_semicolonContext differentiates from other interfaces.
	IsList_of_port_declarations_semicolonContext()
}

type List_of_port_declarations_semicolonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_port_declarations_semicolonContext() *List_of_port_declarations_semicolonContext {
	var p = new(List_of_port_declarations_semicolonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_port_declarations_semicolon
	return p
}

func (*List_of_port_declarations_semicolonContext) IsList_of_port_declarations_semicolonContext() {}

func NewList_of_port_declarations_semicolonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_port_declarations_semicolonContext {
	var p = new(List_of_port_declarations_semicolonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_port_declarations_semicolon

	return p
}

func (s *List_of_port_declarations_semicolonContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_port_declarations_semicolonContext) Attr_port_declaration_semicolon_plus() IAttr_port_declaration_semicolon_plusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_port_declaration_semicolon_plusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_port_declaration_semicolon_plusContext)
}

func (s *List_of_port_declarations_semicolonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_port_declarations_semicolonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_port_declarations_semicolonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_port_declarations_semicolon(s)
	}
}

func (s *List_of_port_declarations_semicolonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_port_declarations_semicolon(s)
	}
}

func (p *SysVerilogHDLParser) List_of_port_declarations_semicolon() (localctx IList_of_port_declarations_semicolonContext) {
	localctx = NewList_of_port_declarations_semicolonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SysVerilogHDLParserRULE_list_of_port_declarations_semicolon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1252)
		p.Attr_port_declaration_semicolon_plus()
	}

	return localctx
}

// IAttr_port_declaration_semicolon_plusContext is an interface to support dynamic dispatch.
type IAttr_port_declaration_semicolon_plusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_port_declaration_semicolon_plusContext differentiates from other interfaces.
	IsAttr_port_declaration_semicolon_plusContext()
}

type Attr_port_declaration_semicolon_plusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_port_declaration_semicolon_plusContext() *Attr_port_declaration_semicolon_plusContext {
	var p = new(Attr_port_declaration_semicolon_plusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attr_port_declaration_semicolon_plus
	return p
}

func (*Attr_port_declaration_semicolon_plusContext) IsAttr_port_declaration_semicolon_plusContext() {}

func NewAttr_port_declaration_semicolon_plusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_port_declaration_semicolon_plusContext {
	var p = new(Attr_port_declaration_semicolon_plusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attr_port_declaration_semicolon_plus

	return p
}

func (s *Attr_port_declaration_semicolon_plusContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_port_declaration_semicolon_plusContext) AllAttr_port_declaration_semicolon() []IAttr_port_declaration_semicolonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttr_port_declaration_semicolonContext)(nil)).Elem())
	var tst = make([]IAttr_port_declaration_semicolonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttr_port_declaration_semicolonContext)
		}
	}

	return tst
}

func (s *Attr_port_declaration_semicolon_plusContext) Attr_port_declaration_semicolon(i int) IAttr_port_declaration_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_port_declaration_semicolonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttr_port_declaration_semicolonContext)
}

func (s *Attr_port_declaration_semicolon_plusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_port_declaration_semicolon_plusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_port_declaration_semicolon_plusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttr_port_declaration_semicolon_plus(s)
	}
}

func (s *Attr_port_declaration_semicolon_plusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttr_port_declaration_semicolon_plus(s)
	}
}

func (p *SysVerilogHDLParser) Attr_port_declaration_semicolon_plus() (localctx IAttr_port_declaration_semicolon_plusContext) {
	localctx = NewAttr_port_declaration_semicolon_plusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SysVerilogHDLParserRULE_attr_port_declaration_semicolon_plus)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1255)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(SysVerilogHDLParserInout-106))|(1<<(SysVerilogHDLParserInput-106))|(1<<(SysVerilogHDLParserOutput-106)))) != 0) || _la == SysVerilogHDLParserRef || _la == SysVerilogHDLParserOpen_parenthesis {
		{
			p.SetState(1254)
			p.Attr_port_declaration_semicolon()
		}

		p.SetState(1257)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAttr_port_declaration_semicolon_starContext is an interface to support dynamic dispatch.
type IAttr_port_declaration_semicolon_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_port_declaration_semicolon_starContext differentiates from other interfaces.
	IsAttr_port_declaration_semicolon_starContext()
}

type Attr_port_declaration_semicolon_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_port_declaration_semicolon_starContext() *Attr_port_declaration_semicolon_starContext {
	var p = new(Attr_port_declaration_semicolon_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attr_port_declaration_semicolon_star
	return p
}

func (*Attr_port_declaration_semicolon_starContext) IsAttr_port_declaration_semicolon_starContext() {}

func NewAttr_port_declaration_semicolon_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_port_declaration_semicolon_starContext {
	var p = new(Attr_port_declaration_semicolon_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attr_port_declaration_semicolon_star

	return p
}

func (s *Attr_port_declaration_semicolon_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_port_declaration_semicolon_starContext) AllAttr_port_declaration_semicolon() []IAttr_port_declaration_semicolonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttr_port_declaration_semicolonContext)(nil)).Elem())
	var tst = make([]IAttr_port_declaration_semicolonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttr_port_declaration_semicolonContext)
		}
	}

	return tst
}

func (s *Attr_port_declaration_semicolon_starContext) Attr_port_declaration_semicolon(i int) IAttr_port_declaration_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_port_declaration_semicolonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttr_port_declaration_semicolonContext)
}

func (s *Attr_port_declaration_semicolon_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_port_declaration_semicolon_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_port_declaration_semicolon_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttr_port_declaration_semicolon_star(s)
	}
}

func (s *Attr_port_declaration_semicolon_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttr_port_declaration_semicolon_star(s)
	}
}

func (p *SysVerilogHDLParser) Attr_port_declaration_semicolon_star() (localctx IAttr_port_declaration_semicolon_starContext) {
	localctx = NewAttr_port_declaration_semicolon_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SysVerilogHDLParserRULE_attr_port_declaration_semicolon_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1262)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(SysVerilogHDLParserInout-106))|(1<<(SysVerilogHDLParserInput-106))|(1<<(SysVerilogHDLParserOutput-106)))) != 0) || _la == SysVerilogHDLParserRef || _la == SysVerilogHDLParserOpen_parenthesis {
		{
			p.SetState(1259)
			p.Attr_port_declaration_semicolon()
		}

		p.SetState(1264)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAttr_port_declaration_semicolonContext is an interface to support dynamic dispatch.
type IAttr_port_declaration_semicolonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_port_declaration_semicolonContext differentiates from other interfaces.
	IsAttr_port_declaration_semicolonContext()
}

type Attr_port_declaration_semicolonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_port_declaration_semicolonContext() *Attr_port_declaration_semicolonContext {
	var p = new(Attr_port_declaration_semicolonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attr_port_declaration_semicolon
	return p
}

func (*Attr_port_declaration_semicolonContext) IsAttr_port_declaration_semicolonContext() {}

func NewAttr_port_declaration_semicolonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_port_declaration_semicolonContext {
	var p = new(Attr_port_declaration_semicolonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attr_port_declaration_semicolon

	return p
}

func (s *Attr_port_declaration_semicolonContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_port_declaration_semicolonContext) Attr_port_declaration() IAttr_port_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_port_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_port_declarationContext)
}

func (s *Attr_port_declaration_semicolonContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Attr_port_declaration_semicolonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_port_declaration_semicolonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_port_declaration_semicolonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttr_port_declaration_semicolon(s)
	}
}

func (s *Attr_port_declaration_semicolonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttr_port_declaration_semicolon(s)
	}
}

func (p *SysVerilogHDLParser) Attr_port_declaration_semicolon() (localctx IAttr_port_declaration_semicolonContext) {
	localctx = NewAttr_port_declaration_semicolonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SysVerilogHDLParserRULE_attr_port_declaration_semicolon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1265)
		p.Attr_port_declaration()
	}
	{
		p.SetState(1266)
		p.Semicolon()
	}

	return localctx
}

// IAttr_port_declarationContext is an interface to support dynamic dispatch.
type IAttr_port_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_port_declarationContext differentiates from other interfaces.
	IsAttr_port_declarationContext()
}

type Attr_port_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_port_declarationContext() *Attr_port_declarationContext {
	var p = new(Attr_port_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attr_port_declaration
	return p
}

func (*Attr_port_declarationContext) IsAttr_port_declarationContext() {}

func NewAttr_port_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_port_declarationContext {
	var p = new(Attr_port_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attr_port_declaration

	return p
}

func (s *Attr_port_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_port_declarationContext) Attribute_instance_star() IAttribute_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instance_starContext)
}

func (s *Attr_port_declarationContext) Port_declaration() IPort_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_declarationContext)
}

func (s *Attr_port_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_port_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_port_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttr_port_declaration(s)
	}
}

func (s *Attr_port_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttr_port_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Attr_port_declaration() (localctx IAttr_port_declarationContext) {
	localctx = NewAttr_port_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SysVerilogHDLParserRULE_attr_port_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1268)
		p.Attribute_instance_star()
	}
	{
		p.SetState(1269)
		p.Port_declaration()
	}

	return localctx
}

// IPort_declarationContext is an interface to support dynamic dispatch.
type IPort_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_declarationContext differentiates from other interfaces.
	IsPort_declarationContext()
}

type Port_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_declarationContext() *Port_declarationContext {
	var p = new(Port_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_port_declaration
	return p
}

func (*Port_declarationContext) IsPort_declarationContext() {}

func NewPort_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_declarationContext {
	var p = new(Port_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_port_declaration

	return p
}

func (s *Port_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_declarationContext) Inout_declaration() IInout_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInout_declarationContext)
}

func (s *Port_declarationContext) Input_declaration() IInput_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_declarationContext)
}

func (s *Port_declarationContext) Output_declaration() IOutput_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_declarationContext)
}

func (s *Port_declarationContext) Ref_declaration() IRef_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRef_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRef_declarationContext)
}

func (s *Port_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPort_declaration(s)
	}
}

func (s *Port_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPort_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Port_declaration() (localctx IPort_declarationContext) {
	localctx = NewPort_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SysVerilogHDLParserRULE_port_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1275)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserInout:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1271)
			p.Inout_declaration()
		}

	case SysVerilogHDLParserInput:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1272)
			p.Input_declaration()
		}

	case SysVerilogHDLParserOutput:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1273)
			p.Output_declaration()
		}

	case SysVerilogHDLParserRef:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1274)
			p.Ref_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPort_descriptionContext is an interface to support dynamic dispatch.
type IPort_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_descriptionContext differentiates from other interfaces.
	IsPort_descriptionContext()
}

type Port_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_descriptionContext() *Port_descriptionContext {
	var p = new(Port_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_port_description
	return p
}

func (*Port_descriptionContext) IsPort_descriptionContext() {}

func NewPort_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_descriptionContext {
	var p = new(Port_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_port_description

	return p
}

func (s *Port_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_descriptionContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *Port_descriptionContext) Dimension_plus() IDimension_plusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimension_plusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimension_plusContext)
}

func (s *Port_descriptionContext) Signed() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSigned, 0)
}

func (s *Port_descriptionContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserUnsigned, 0)
}

func (s *Port_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPort_description(s)
	}
}

func (s *Port_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPort_description(s)
	}
}

func (p *SysVerilogHDLParser) Port_description() (localctx IPort_descriptionContext) {
	localctx = NewPort_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SysVerilogHDLParserRULE_port_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1278)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned {
		{
			p.SetState(1277)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserLeft_bracket {
		{
			p.SetState(1280)
			p.Dimension_plus()
		}

	}
	{
		p.SetState(1283)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// IInout_descriptionContext is an interface to support dynamic dispatch.
type IInout_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInout_descriptionContext differentiates from other interfaces.
	IsInout_descriptionContext()
}

type Inout_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInout_descriptionContext() *Inout_descriptionContext {
	var p = new(Inout_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_inout_description
	return p
}

func (*Inout_descriptionContext) IsInout_descriptionContext() {}

func NewInout_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inout_descriptionContext {
	var p = new(Inout_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_inout_description

	return p
}

func (s *Inout_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Inout_descriptionContext) Port_description() IPort_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_descriptionContext)
}

func (s *Inout_descriptionContext) Net_declaration() INet_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_declarationContext)
}

func (s *Inout_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inout_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inout_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterInout_description(s)
	}
}

func (s *Inout_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitInout_description(s)
	}
}

func (p *SysVerilogHDLParser) Inout_description() (localctx IInout_descriptionContext) {
	localctx = NewInout_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SysVerilogHDLParserRULE_inout_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1287)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserSigned, SysVerilogHDLParserUnsigned, SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier, SysVerilogHDLParserLeft_bracket:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1285)
			p.Port_description()
		}

	case SysVerilogHDLParserNONE, SysVerilogHDLParserSupply0, SysVerilogHDLParserSupply1, SysVerilogHDLParserTri, SysVerilogHDLParserTri_and, SysVerilogHDLParserTri_or, SysVerilogHDLParserTri_reg, SysVerilogHDLParserTri0, SysVerilogHDLParserTri1, SysVerilogHDLParserUwire, SysVerilogHDLParserWand, SysVerilogHDLParserWire, SysVerilogHDLParserWor:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1286)
			p.Net_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInput_descriptionContext is an interface to support dynamic dispatch.
type IInput_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_descriptionContext differentiates from other interfaces.
	IsInput_descriptionContext()
}

type Input_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_descriptionContext() *Input_descriptionContext {
	var p = new(Input_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_input_description
	return p
}

func (*Input_descriptionContext) IsInput_descriptionContext() {}

func NewInput_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_descriptionContext {
	var p = new(Input_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_input_description

	return p
}

func (s *Input_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_descriptionContext) Port_description() IPort_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_descriptionContext)
}

func (s *Input_descriptionContext) Net_declaration() INet_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_declarationContext)
}

func (s *Input_descriptionContext) Reg_declaration() IReg_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReg_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReg_declarationContext)
}

func (s *Input_descriptionContext) Logic_declaration() ILogic_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogic_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogic_declarationContext)
}

func (s *Input_descriptionContext) Bits_declaration() IBits_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBits_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBits_declarationContext)
}

func (s *Input_descriptionContext) Int_declaration() IInt_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_declarationContext)
}

func (s *Input_descriptionContext) Integer_declaration() IInteger_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_declarationContext)
}

func (s *Input_descriptionContext) Real_declaration() IReal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_declarationContext)
}

func (s *Input_descriptionContext) Time_declaration() ITime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITime_declarationContext)
}

func (s *Input_descriptionContext) Usertype_variable_declaration() IUsertype_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUsertype_variable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUsertype_variable_declarationContext)
}

func (s *Input_descriptionContext) String_declaration() IString_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_declarationContext)
}

func (s *Input_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterInput_description(s)
	}
}

func (s *Input_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitInput_description(s)
	}
}

func (p *SysVerilogHDLParser) Input_description() (localctx IInput_descriptionContext) {
	localctx = NewInput_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SysVerilogHDLParserRULE_input_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1300)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1289)
			p.Port_description()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1290)
			p.Net_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1291)
			p.Reg_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1292)
			p.Logic_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1293)
			p.Bits_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1294)
			p.Int_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1295)
			p.Integer_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1296)
			p.Real_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1297)
			p.Time_declaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1298)
			p.Usertype_variable_declaration()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1299)
			p.String_declaration()
		}

	}

	return localctx
}

// IOutput_descriptionContext is an interface to support dynamic dispatch.
type IOutput_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_descriptionContext differentiates from other interfaces.
	IsOutput_descriptionContext()
}

type Output_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_descriptionContext() *Output_descriptionContext {
	var p = new(Output_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_output_description
	return p
}

func (*Output_descriptionContext) IsOutput_descriptionContext() {}

func NewOutput_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_descriptionContext {
	var p = new(Output_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_output_description

	return p
}

func (s *Output_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_descriptionContext) Port_description() IPort_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_descriptionContext)
}

func (s *Output_descriptionContext) Net_declaration() INet_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_declarationContext)
}

func (s *Output_descriptionContext) Reg_declaration() IReg_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReg_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReg_declarationContext)
}

func (s *Output_descriptionContext) Logic_declaration() ILogic_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogic_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogic_declarationContext)
}

func (s *Output_descriptionContext) Integer_declaration() IInteger_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_declarationContext)
}

func (s *Output_descriptionContext) Time_declaration() ITime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITime_declarationContext)
}

func (s *Output_descriptionContext) Usertype_variable_declaration() IUsertype_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUsertype_variable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUsertype_variable_declarationContext)
}

func (s *Output_descriptionContext) String_declaration() IString_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_declarationContext)
}

func (s *Output_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterOutput_description(s)
	}
}

func (s *Output_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitOutput_description(s)
	}
}

func (p *SysVerilogHDLParser) Output_description() (localctx IOutput_descriptionContext) {
	localctx = NewOutput_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SysVerilogHDLParserRULE_output_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1310)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1302)
			p.Port_description()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1303)
			p.Net_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1304)
			p.Reg_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1305)
			p.Logic_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1306)
			p.Integer_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1307)
			p.Time_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1308)
			p.Usertype_variable_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1309)
			p.String_declaration()
		}

	}

	return localctx
}

// IRef_descriptionContext is an interface to support dynamic dispatch.
type IRef_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRef_descriptionContext differentiates from other interfaces.
	IsRef_descriptionContext()
}

type Ref_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRef_descriptionContext() *Ref_descriptionContext {
	var p = new(Ref_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_ref_description
	return p
}

func (*Ref_descriptionContext) IsRef_descriptionContext() {}

func NewRef_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ref_descriptionContext {
	var p = new(Ref_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_ref_description

	return p
}

func (s *Ref_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Ref_descriptionContext) Port_description() IPort_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_descriptionContext)
}

func (s *Ref_descriptionContext) Net_declaration() INet_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_declarationContext)
}

func (s *Ref_descriptionContext) Reg_declaration() IReg_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReg_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReg_declarationContext)
}

func (s *Ref_descriptionContext) Logic_declaration() ILogic_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogic_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogic_declarationContext)
}

func (s *Ref_descriptionContext) Integer_declaration() IInteger_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_declarationContext)
}

func (s *Ref_descriptionContext) Time_declaration() ITime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITime_declarationContext)
}

func (s *Ref_descriptionContext) Usertype_variable_declaration() IUsertype_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUsertype_variable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUsertype_variable_declarationContext)
}

func (s *Ref_descriptionContext) String_declaration() IString_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_declarationContext)
}

func (s *Ref_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ref_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ref_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterRef_description(s)
	}
}

func (s *Ref_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitRef_description(s)
	}
}

func (p *SysVerilogHDLParser) Ref_description() (localctx IRef_descriptionContext) {
	localctx = NewRef_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SysVerilogHDLParserRULE_ref_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1320)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1312)
			p.Port_description()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1313)
			p.Net_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1314)
			p.Reg_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1315)
			p.Logic_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1316)
			p.Integer_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1317)
			p.Time_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1318)
			p.Usertype_variable_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1319)
			p.String_declaration()
		}

	}

	return localctx
}

// ITf_declarationContext is an interface to support dynamic dispatch.
type ITf_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf_declarationContext differentiates from other interfaces.
	IsTf_declarationContext()
}

type Tf_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf_declarationContext() *Tf_declarationContext {
	var p = new(Tf_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_tf_declaration
	return p
}

func (*Tf_declarationContext) IsTf_declarationContext() {}

func NewTf_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf_declarationContext {
	var p = new(Tf_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_tf_declaration

	return p
}

func (s *Tf_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf_declarationContext) Port_description() IPort_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_descriptionContext)
}

func (s *Tf_declarationContext) Real_declaration() IReal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_declarationContext)
}

func (s *Tf_declarationContext) Net_declaration() INet_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_declarationContext)
}

func (s *Tf_declarationContext) Reg_declaration() IReg_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReg_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReg_declarationContext)
}

func (s *Tf_declarationContext) Logic_declaration() ILogic_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogic_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogic_declarationContext)
}

func (s *Tf_declarationContext) Bits_declaration() IBits_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBits_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBits_declarationContext)
}

func (s *Tf_declarationContext) Int_declaration() IInt_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_declarationContext)
}

func (s *Tf_declarationContext) Integer_declaration() IInteger_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_declarationContext)
}

func (s *Tf_declarationContext) Time_declaration() ITime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITime_declarationContext)
}

func (s *Tf_declarationContext) Usertype_variable_declaration() IUsertype_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUsertype_variable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUsertype_variable_declarationContext)
}

func (s *Tf_declarationContext) String_declaration() IString_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_declarationContext)
}

func (s *Tf_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTf_declaration(s)
	}
}

func (s *Tf_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTf_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Tf_declaration() (localctx ITf_declarationContext) {
	localctx = NewTf_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SysVerilogHDLParserRULE_tf_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1333)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1322)
			p.Port_description()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1323)
			p.Real_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1324)
			p.Net_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1325)
			p.Reg_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1326)
			p.Logic_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1327)
			p.Bits_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1328)
			p.Int_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1329)
			p.Integer_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1330)
			p.Time_declaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1331)
			p.Usertype_variable_declaration()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1332)
			p.String_declaration()
		}

	}

	return localctx
}

// IInout_declarationContext is an interface to support dynamic dispatch.
type IInout_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInout_declarationContext differentiates from other interfaces.
	IsInout_declarationContext()
}

type Inout_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInout_declarationContext() *Inout_declarationContext {
	var p = new(Inout_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_inout_declaration
	return p
}

func (*Inout_declarationContext) IsInout_declarationContext() {}

func NewInout_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inout_declarationContext {
	var p = new(Inout_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_inout_declaration

	return p
}

func (s *Inout_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Inout_declarationContext) Inout() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserInout, 0)
}

func (s *Inout_declarationContext) Inout_description() IInout_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInout_descriptionContext)
}

func (s *Inout_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inout_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inout_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterInout_declaration(s)
	}
}

func (s *Inout_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitInout_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Inout_declaration() (localctx IInout_declarationContext) {
	localctx = NewInout_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SysVerilogHDLParserRULE_inout_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1335)
		p.Match(SysVerilogHDLParserInout)
	}
	{
		p.SetState(1336)
		p.Inout_description()
	}

	return localctx
}

// IInput_declarationContext is an interface to support dynamic dispatch.
type IInput_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_declarationContext differentiates from other interfaces.
	IsInput_declarationContext()
}

type Input_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_declarationContext() *Input_declarationContext {
	var p = new(Input_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_input_declaration
	return p
}

func (*Input_declarationContext) IsInput_declarationContext() {}

func NewInput_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_declarationContext {
	var p = new(Input_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_input_declaration

	return p
}

func (s *Input_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_declarationContext) Input() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserInput, 0)
}

func (s *Input_declarationContext) Input_description() IInput_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_descriptionContext)
}

func (s *Input_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterInput_declaration(s)
	}
}

func (s *Input_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitInput_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Input_declaration() (localctx IInput_declarationContext) {
	localctx = NewInput_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SysVerilogHDLParserRULE_input_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1338)
		p.Match(SysVerilogHDLParserInput)
	}
	{
		p.SetState(1339)
		p.Input_description()
	}

	return localctx
}

// IOutput_declarationContext is an interface to support dynamic dispatch.
type IOutput_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_declarationContext differentiates from other interfaces.
	IsOutput_declarationContext()
}

type Output_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_declarationContext() *Output_declarationContext {
	var p = new(Output_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_output_declaration
	return p
}

func (*Output_declarationContext) IsOutput_declarationContext() {}

func NewOutput_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_declarationContext {
	var p = new(Output_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_output_declaration

	return p
}

func (s *Output_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_declarationContext) Output() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOutput, 0)
}

func (s *Output_declarationContext) Output_description() IOutput_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_descriptionContext)
}

func (s *Output_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterOutput_declaration(s)
	}
}

func (s *Output_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitOutput_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Output_declaration() (localctx IOutput_declarationContext) {
	localctx = NewOutput_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SysVerilogHDLParserRULE_output_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1341)
		p.Match(SysVerilogHDLParserOutput)
	}
	{
		p.SetState(1342)
		p.Output_description()
	}

	return localctx
}

// IRef_declarationContext is an interface to support dynamic dispatch.
type IRef_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRef_declarationContext differentiates from other interfaces.
	IsRef_declarationContext()
}

type Ref_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRef_declarationContext() *Ref_declarationContext {
	var p = new(Ref_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_ref_declaration
	return p
}

func (*Ref_declarationContext) IsRef_declarationContext() {}

func NewRef_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ref_declarationContext {
	var p = new(Ref_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_ref_declaration

	return p
}

func (s *Ref_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Ref_declarationContext) Ref() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRef, 0)
}

func (s *Ref_declarationContext) Ref_description() IRef_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRef_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRef_descriptionContext)
}

func (s *Ref_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ref_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ref_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterRef_declaration(s)
	}
}

func (s *Ref_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitRef_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Ref_declaration() (localctx IRef_declarationContext) {
	localctx = NewRef_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SysVerilogHDLParserRULE_ref_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1344)
		p.Match(SysVerilogHDLParserRef)
	}
	{
		p.SetState(1345)
		p.Ref_description()
	}

	return localctx
}

// IUser_typeContext is an interface to support dynamic dispatch.
type IUser_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUser_typeContext differentiates from other interfaces.
	IsUser_typeContext()
}

type User_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUser_typeContext() *User_typeContext {
	var p = new(User_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_user_type
	return p
}

func (*User_typeContext) IsUser_typeContext() {}

func NewUser_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *User_typeContext {
	var p = new(User_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_user_type

	return p
}

func (s *User_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *User_typeContext) User_type_identifer() IUser_type_identiferContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_type_identiferContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUser_type_identiferContext)
}

func (s *User_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *User_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *User_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterUser_type(s)
	}
}

func (s *User_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitUser_type(s)
	}
}

func (p *SysVerilogHDLParser) User_type() (localctx IUser_typeContext) {
	localctx = NewUser_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SysVerilogHDLParserRULE_user_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1347)
		p.User_type_identifer()
	}

	return localctx
}

// IUser_type_identiferContext is an interface to support dynamic dispatch.
type IUser_type_identiferContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUser_type_identiferContext differentiates from other interfaces.
	IsUser_type_identiferContext()
}

type User_type_identiferContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUser_type_identiferContext() *User_type_identiferContext {
	var p = new(User_type_identiferContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_user_type_identifer
	return p
}

func (*User_type_identiferContext) IsUser_type_identiferContext() {}

func NewUser_type_identiferContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *User_type_identiferContext {
	var p = new(User_type_identiferContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_user_type_identifer

	return p
}

func (s *User_type_identiferContext) GetParser() antlr.Parser { return s.parser }

func (s *User_type_identiferContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *User_type_identiferContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *User_type_identiferContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *User_type_identiferContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterUser_type_identifer(s)
	}
}

func (s *User_type_identiferContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitUser_type_identifer(s)
	}
}

func (p *SysVerilogHDLParser) User_type_identifer() (localctx IUser_type_identiferContext) {
	localctx = NewUser_type_identiferContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SysVerilogHDLParserRULE_user_type_identifer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1349)
		p.Identifier()
	}

	return localctx
}

// IDimension_plusContext is an interface to support dynamic dispatch.
type IDimension_plusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimension_plusContext differentiates from other interfaces.
	IsDimension_plusContext()
}

type Dimension_plusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimension_plusContext() *Dimension_plusContext {
	var p = new(Dimension_plusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_dimension_plus
	return p
}

func (*Dimension_plusContext) IsDimension_plusContext() {}

func NewDimension_plusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dimension_plusContext {
	var p = new(Dimension_plusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_dimension_plus

	return p
}

func (s *Dimension_plusContext) GetParser() antlr.Parser { return s.parser }

func (s *Dimension_plusContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *Dimension_plusContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Dimension_plusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dimension_plusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dimension_plusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDimension_plus(s)
	}
}

func (s *Dimension_plusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDimension_plus(s)
	}
}

func (p *SysVerilogHDLParser) Dimension_plus() (localctx IDimension_plusContext) {
	localctx = NewDimension_plusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SysVerilogHDLParserRULE_dimension_plus)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1352)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1351)
				p.Dimension()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1354)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())
	}

	return localctx
}

// IDimension_starContext is an interface to support dynamic dispatch.
type IDimension_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimension_starContext differentiates from other interfaces.
	IsDimension_starContext()
}

type Dimension_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimension_starContext() *Dimension_starContext {
	var p = new(Dimension_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_dimension_star
	return p
}

func (*Dimension_starContext) IsDimension_starContext() {}

func NewDimension_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dimension_starContext {
	var p = new(Dimension_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_dimension_star

	return p
}

func (s *Dimension_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Dimension_starContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *Dimension_starContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Dimension_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dimension_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dimension_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDimension_star(s)
	}
}

func (s *Dimension_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDimension_star(s)
	}
}

func (p *SysVerilogHDLParser) Dimension_star() (localctx IDimension_starContext) {
	localctx = NewDimension_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SysVerilogHDLParserRULE_dimension_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1359)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserLeft_bracket {
		{
			p.SetState(1356)
			p.Dimension()
		}

		p.SetState(1361)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDimensionContext is an interface to support dynamic dispatch.
type IDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimensionContext differentiates from other interfaces.
	IsDimensionContext()
}

type DimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimensionContext() *DimensionContext {
	var p = new(DimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_dimension
	return p
}

func (*DimensionContext) IsDimensionContext() {}

func NewDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimensionContext {
	var p = new(DimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_dimension

	return p
}

func (s *DimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *DimensionContext) Left_bracket() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserLeft_bracket, 0)
}

func (s *DimensionContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *DimensionContext) Right_bracket() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRight_bracket, 0)
}

func (s *DimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDimension(s)
	}
}

func (s *DimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDimension(s)
	}
}

func (p *SysVerilogHDLParser) Dimension() (localctx IDimensionContext) {
	localctx = NewDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SysVerilogHDLParserRULE_dimension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1362)
		p.Match(SysVerilogHDLParserLeft_bracket)
	}
	{
		p.SetState(1363)
		p.Range_expression()
	}
	{
		p.SetState(1364)
		p.Match(SysVerilogHDLParserRight_bracket)
	}

	return localctx
}

// IRange_expressionContext is an interface to support dynamic dispatch.
type IRange_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRange_expressionContext differentiates from other interfaces.
	IsRange_expressionContext()
}

type Range_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_expressionContext() *Range_expressionContext {
	var p = new(Range_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_range_expression
	return p
}

func (*Range_expressionContext) IsRange_expressionContext() {}

func NewRange_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_expressionContext {
	var p = new(Range_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_range_expression

	return p
}

func (s *Range_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_expressionContext) Index_expression() IIndex_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndex_expressionContext)
}

func (s *Range_expressionContext) Sb_range() ISb_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISb_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISb_rangeContext)
}

func (s *Range_expressionContext) Base_increment_range() IBase_increment_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_increment_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_increment_rangeContext)
}

func (s *Range_expressionContext) Base_decrement_range() IBase_decrement_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_decrement_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_decrement_rangeContext)
}

func (s *Range_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterRange_expression(s)
	}
}

func (s *Range_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitRange_expression(s)
	}
}

func (p *SysVerilogHDLParser) Range_expression() (localctx IRange_expressionContext) {
	localctx = NewRange_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SysVerilogHDLParserRULE_range_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1370)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1366)
			p.Index_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1367)
			p.Sb_range()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1368)
			p.Base_increment_range()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1369)
			p.Base_decrement_range()
		}

	}

	return localctx
}

// IIndex_expressionContext is an interface to support dynamic dispatch.
type IIndex_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndex_expressionContext differentiates from other interfaces.
	IsIndex_expressionContext()
}

type Index_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_expressionContext() *Index_expressionContext {
	var p = new(Index_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_index_expression
	return p
}

func (*Index_expressionContext) IsIndex_expressionContext() {}

func NewIndex_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_expressionContext {
	var p = new(Index_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_index_expression

	return p
}

func (s *Index_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Index_expressionContext) Dollar() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDollar, 0)
}

func (s *Index_expressionContext) Star() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserStar, 0)
}

func (s *Index_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterIndex_expression(s)
	}
}

func (s *Index_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitIndex_expression(s)
	}
}

func (p *SysVerilogHDLParser) Index_expression() (localctx IIndex_expressionContext) {
	localctx = NewIndex_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SysVerilogHDLParserRULE_index_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1375)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserT__1, SysVerilogHDLParserT__2, SysVerilogHDLParserT__3, SysVerilogHDLParserT__4, SysVerilogHDLParserT__5, SysVerilogHDLParserT__6, SysVerilogHDLParserT__7, SysVerilogHDLParserT__8, SysVerilogHDLParserT__9, SysVerilogHDLParserT__10, SysVerilogHDLParserT__26, SysVerilogHDLParserT__27, SysVerilogHDLParserBinary_number, SysVerilogHDLParserDecimal_number, SysVerilogHDLParserFixed_point_number, SysVerilogHDLParserHex_number, SysVerilogHDLParserOctal_number, SysVerilogHDLParserReal_exp_form, SysVerilogHDLParserInt, SysVerilogHDLParserSigned, SysVerilogHDLParserUnsigned, SysVerilogHDLParserDollar_Identifier, SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier, SysVerilogHDLParserString_literal, SysVerilogHDLParserLeft_curly_bracket, SysVerilogHDLParserOpen_parenthesis, SysVerilogHDLParserQuote, SysVerilogHDLParserTilde:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1372)
			p.Expression()
		}

	case SysVerilogHDLParserDollar:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1373)
			p.Match(SysVerilogHDLParserDollar)
		}

	case SysVerilogHDLParserStar:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1374)
			p.Match(SysVerilogHDLParserStar)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISb_rangeContext is an interface to support dynamic dispatch.
type ISb_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSb_rangeContext differentiates from other interfaces.
	IsSb_rangeContext()
}

type Sb_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySb_rangeContext() *Sb_rangeContext {
	var p = new(Sb_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_sb_range
	return p
}

func (*Sb_rangeContext) IsSb_rangeContext() {}

func NewSb_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sb_rangeContext {
	var p = new(Sb_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_sb_range

	return p
}

func (s *Sb_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Sb_rangeContext) Base_expression() IBase_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_expressionContext)
}

func (s *Sb_rangeContext) Colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserColon, 0)
}

func (s *Sb_rangeContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Sb_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sb_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sb_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterSb_range(s)
	}
}

func (s *Sb_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitSb_range(s)
	}
}

func (p *SysVerilogHDLParser) Sb_range() (localctx ISb_rangeContext) {
	localctx = NewSb_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, SysVerilogHDLParserRULE_sb_range)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1377)
		p.Base_expression()
	}
	{
		p.SetState(1378)
		p.Match(SysVerilogHDLParserColon)
	}
	{
		p.SetState(1379)
		p.Expression()
	}

	return localctx
}

// IBase_increment_rangeContext is an interface to support dynamic dispatch.
type IBase_increment_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_increment_rangeContext differentiates from other interfaces.
	IsBase_increment_rangeContext()
}

type Base_increment_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_increment_rangeContext() *Base_increment_rangeContext {
	var p = new(Base_increment_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_base_increment_range
	return p
}

func (*Base_increment_rangeContext) IsBase_increment_rangeContext() {}

func NewBase_increment_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_increment_rangeContext {
	var p = new(Base_increment_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_base_increment_range

	return p
}

func (s *Base_increment_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_increment_rangeContext) Base_expression() IBase_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_expressionContext)
}

func (s *Base_increment_rangeContext) Plus_colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserPlus_colon, 0)
}

func (s *Base_increment_rangeContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Base_increment_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_increment_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_increment_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterBase_increment_range(s)
	}
}

func (s *Base_increment_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitBase_increment_range(s)
	}
}

func (p *SysVerilogHDLParser) Base_increment_range() (localctx IBase_increment_rangeContext) {
	localctx = NewBase_increment_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, SysVerilogHDLParserRULE_base_increment_range)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1381)
		p.Base_expression()
	}
	{
		p.SetState(1382)
		p.Match(SysVerilogHDLParserPlus_colon)
	}
	{
		p.SetState(1383)
		p.Expression()
	}

	return localctx
}

// IBase_decrement_rangeContext is an interface to support dynamic dispatch.
type IBase_decrement_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_decrement_rangeContext differentiates from other interfaces.
	IsBase_decrement_rangeContext()
}

type Base_decrement_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_decrement_rangeContext() *Base_decrement_rangeContext {
	var p = new(Base_decrement_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_base_decrement_range
	return p
}

func (*Base_decrement_rangeContext) IsBase_decrement_rangeContext() {}

func NewBase_decrement_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_decrement_rangeContext {
	var p = new(Base_decrement_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_base_decrement_range

	return p
}

func (s *Base_decrement_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_decrement_rangeContext) Base_expression() IBase_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_expressionContext)
}

func (s *Base_decrement_rangeContext) Minus_colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserMinus_colon, 0)
}

func (s *Base_decrement_rangeContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Base_decrement_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_decrement_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_decrement_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterBase_decrement_range(s)
	}
}

func (s *Base_decrement_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitBase_decrement_range(s)
	}
}

func (p *SysVerilogHDLParser) Base_decrement_range() (localctx IBase_decrement_rangeContext) {
	localctx = NewBase_decrement_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, SysVerilogHDLParserRULE_base_decrement_range)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1385)
		p.Base_expression()
	}
	{
		p.SetState(1386)
		p.Match(SysVerilogHDLParserMinus_colon)
	}
	{
		p.SetState(1387)
		p.Expression()
	}

	return localctx
}

// IBase_expressionContext is an interface to support dynamic dispatch.
type IBase_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_expressionContext differentiates from other interfaces.
	IsBase_expressionContext()
}

type Base_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_expressionContext() *Base_expressionContext {
	var p = new(Base_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_base_expression
	return p
}

func (*Base_expressionContext) IsBase_expressionContext() {}

func NewBase_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_expressionContext {
	var p = new(Base_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_base_expression

	return p
}

func (s *Base_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Base_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterBase_expression(s)
	}
}

func (s *Base_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitBase_expression(s)
	}
}

func (p *SysVerilogHDLParser) Base_expression() (localctx IBase_expressionContext) {
	localctx = NewBase_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, SysVerilogHDLParserRULE_base_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1389)
		p.Expression()
	}

	return localctx
}

// INet_typeContext is an interface to support dynamic dispatch.
type INet_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_typeContext differentiates from other interfaces.
	IsNet_typeContext()
}

type Net_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_typeContext() *Net_typeContext {
	var p = new(Net_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_net_type
	return p
}

func (*Net_typeContext) IsNet_typeContext() {}

func NewNet_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_typeContext {
	var p = new(Net_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_net_type

	return p
}

func (s *Net_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_typeContext) Supply0() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSupply0, 0)
}

func (s *Net_typeContext) Supply1() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSupply1, 0)
}

func (s *Net_typeContext) Tri() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTri, 0)
}

func (s *Net_typeContext) Tri_and() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTri_and, 0)
}

func (s *Net_typeContext) Tri_or() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTri_or, 0)
}

func (s *Net_typeContext) Tri_reg() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTri_reg, 0)
}

func (s *Net_typeContext) Tri0() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTri0, 0)
}

func (s *Net_typeContext) Tri1() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTri1, 0)
}

func (s *Net_typeContext) Uwire() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserUwire, 0)
}

func (s *Net_typeContext) Wire() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserWire, 0)
}

func (s *Net_typeContext) Wand() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserWand, 0)
}

func (s *Net_typeContext) Wor() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserWor, 0)
}

func (s *Net_typeContext) NONE() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserNONE, 0)
}

func (s *Net_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterNet_type(s)
	}
}

func (s *Net_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitNet_type(s)
	}
}

func (p *SysVerilogHDLParser) Net_type() (localctx INet_typeContext) {
	localctx = NewNet_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, SysVerilogHDLParserRULE_net_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1391)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SysVerilogHDLParserNONE || (((_la-170)&-(0x1f+1)) == 0 && ((1<<uint((_la-170)))&((1<<(SysVerilogHDLParserSupply0-170))|(1<<(SysVerilogHDLParserSupply1-170))|(1<<(SysVerilogHDLParserTri-170))|(1<<(SysVerilogHDLParserTri_and-170))|(1<<(SysVerilogHDLParserTri_or-170))|(1<<(SysVerilogHDLParserTri_reg-170))|(1<<(SysVerilogHDLParserTri0-170))|(1<<(SysVerilogHDLParserTri1-170))|(1<<(SysVerilogHDLParserUwire-170))|(1<<(SysVerilogHDLParserWand-170))|(1<<(SysVerilogHDLParserWire-170))|(1<<(SysVerilogHDLParserWor-170)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDrive_strengthContext is an interface to support dynamic dispatch.
type IDrive_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrive_strengthContext differentiates from other interfaces.
	IsDrive_strengthContext()
}

type Drive_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrive_strengthContext() *Drive_strengthContext {
	var p = new(Drive_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_drive_strength
	return p
}

func (*Drive_strengthContext) IsDrive_strengthContext() {}

func NewDrive_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drive_strengthContext {
	var p = new(Drive_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_drive_strength

	return p
}

func (s *Drive_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Drive_strengthContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Drive_strengthContext) Drive_strength_value_0() IDrive_strength_value_0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strength_value_0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strength_value_0Context)
}

func (s *Drive_strengthContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Drive_strengthContext) Drive_strength_value_1() IDrive_strength_value_1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strength_value_1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strength_value_1Context)
}

func (s *Drive_strengthContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Drive_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drive_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drive_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDrive_strength(s)
	}
}

func (s *Drive_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDrive_strength(s)
	}
}

func (p *SysVerilogHDLParser) Drive_strength() (localctx IDrive_strengthContext) {
	localctx = NewDrive_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, SysVerilogHDLParserRULE_drive_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1393)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(1394)
		p.Drive_strength_value_0()
	}
	{
		p.SetState(1395)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(1396)
		p.Drive_strength_value_1()
	}
	{
		p.SetState(1397)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// IDrive_strength_value_0Context is an interface to support dynamic dispatch.
type IDrive_strength_value_0Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrive_strength_value_0Context differentiates from other interfaces.
	IsDrive_strength_value_0Context()
}

type Drive_strength_value_0Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrive_strength_value_0Context() *Drive_strength_value_0Context {
	var p = new(Drive_strength_value_0Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_drive_strength_value_0
	return p
}

func (*Drive_strength_value_0Context) IsDrive_strength_value_0Context() {}

func NewDrive_strength_value_0Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drive_strength_value_0Context {
	var p = new(Drive_strength_value_0Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_drive_strength_value_0

	return p
}

func (s *Drive_strength_value_0Context) GetParser() antlr.Parser { return s.parser }

func (s *Drive_strength_value_0Context) Strength0() IStrength0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength0Context)
}

func (s *Drive_strength_value_0Context) Strength1() IStrength1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength1Context)
}

func (s *Drive_strength_value_0Context) Highz0() IHighz0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHighz0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHighz0Context)
}

func (s *Drive_strength_value_0Context) Highz1() IHighz1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHighz1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHighz1Context)
}

func (s *Drive_strength_value_0Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drive_strength_value_0Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drive_strength_value_0Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDrive_strength_value_0(s)
	}
}

func (s *Drive_strength_value_0Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDrive_strength_value_0(s)
	}
}

func (p *SysVerilogHDLParser) Drive_strength_value_0() (localctx IDrive_strength_value_0Context) {
	localctx = NewDrive_strength_value_0Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, SysVerilogHDLParserRULE_drive_strength_value_0)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1403)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserPull0, SysVerilogHDLParserStrong0, SysVerilogHDLParserSupply0, SysVerilogHDLParserWeak0:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1399)
			p.Strength0()
		}

	case SysVerilogHDLParserPull1, SysVerilogHDLParserStrong1, SysVerilogHDLParserSupply1, SysVerilogHDLParserWeak1:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1400)
			p.Strength1()
		}

	case SysVerilogHDLParserHighz0:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1401)
			p.Highz0()
		}

	case SysVerilogHDLParserHighz1:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1402)
			p.Highz1()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDrive_strength_value_1Context is an interface to support dynamic dispatch.
type IDrive_strength_value_1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrive_strength_value_1Context differentiates from other interfaces.
	IsDrive_strength_value_1Context()
}

type Drive_strength_value_1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrive_strength_value_1Context() *Drive_strength_value_1Context {
	var p = new(Drive_strength_value_1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_drive_strength_value_1
	return p
}

func (*Drive_strength_value_1Context) IsDrive_strength_value_1Context() {}

func NewDrive_strength_value_1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drive_strength_value_1Context {
	var p = new(Drive_strength_value_1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_drive_strength_value_1

	return p
}

func (s *Drive_strength_value_1Context) GetParser() antlr.Parser { return s.parser }

func (s *Drive_strength_value_1Context) Strength0() IStrength0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength0Context)
}

func (s *Drive_strength_value_1Context) Strength1() IStrength1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength1Context)
}

func (s *Drive_strength_value_1Context) Highz0() IHighz0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHighz0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHighz0Context)
}

func (s *Drive_strength_value_1Context) Highz1() IHighz1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHighz1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHighz1Context)
}

func (s *Drive_strength_value_1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drive_strength_value_1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drive_strength_value_1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDrive_strength_value_1(s)
	}
}

func (s *Drive_strength_value_1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDrive_strength_value_1(s)
	}
}

func (p *SysVerilogHDLParser) Drive_strength_value_1() (localctx IDrive_strength_value_1Context) {
	localctx = NewDrive_strength_value_1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, SysVerilogHDLParserRULE_drive_strength_value_1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1409)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserPull0, SysVerilogHDLParserStrong0, SysVerilogHDLParserSupply0, SysVerilogHDLParserWeak0:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1405)
			p.Strength0()
		}

	case SysVerilogHDLParserPull1, SysVerilogHDLParserStrong1, SysVerilogHDLParserSupply1, SysVerilogHDLParserWeak1:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1406)
			p.Strength1()
		}

	case SysVerilogHDLParserHighz0:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1407)
			p.Highz0()
		}

	case SysVerilogHDLParserHighz1:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1408)
			p.Highz1()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStrength0Context is an interface to support dynamic dispatch.
type IStrength0Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrength0Context differentiates from other interfaces.
	IsStrength0Context()
}

type Strength0Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrength0Context() *Strength0Context {
	var p = new(Strength0Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_strength0
	return p
}

func (*Strength0Context) IsStrength0Context() {}

func NewStrength0Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Strength0Context {
	var p = new(Strength0Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_strength0

	return p
}

func (s *Strength0Context) GetParser() antlr.Parser { return s.parser }

func (s *Strength0Context) Supply0() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSupply0, 0)
}

func (s *Strength0Context) Strong0() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserStrong0, 0)
}

func (s *Strength0Context) Pull0() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserPull0, 0)
}

func (s *Strength0Context) Weak0() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserWeak0, 0)
}

func (s *Strength0Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Strength0Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Strength0Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterStrength0(s)
	}
}

func (s *Strength0Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitStrength0(s)
	}
}

func (p *SysVerilogHDLParser) Strength0() (localctx IStrength0Context) {
	localctx = NewStrength0Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, SysVerilogHDLParserRULE_strength0)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1411)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(SysVerilogHDLParserPull0-140))|(1<<(SysVerilogHDLParserStrong0-140))|(1<<(SysVerilogHDLParserSupply0-140)))) != 0) || _la == SysVerilogHDLParserWeak0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStrength1Context is an interface to support dynamic dispatch.
type IStrength1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrength1Context differentiates from other interfaces.
	IsStrength1Context()
}

type Strength1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrength1Context() *Strength1Context {
	var p = new(Strength1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_strength1
	return p
}

func (*Strength1Context) IsStrength1Context() {}

func NewStrength1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Strength1Context {
	var p = new(Strength1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_strength1

	return p
}

func (s *Strength1Context) GetParser() antlr.Parser { return s.parser }

func (s *Strength1Context) Supply1() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSupply1, 0)
}

func (s *Strength1Context) Strong1() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserStrong1, 0)
}

func (s *Strength1Context) Pull1() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserPull1, 0)
}

func (s *Strength1Context) Weak1() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserWeak1, 0)
}

func (s *Strength1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Strength1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Strength1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterStrength1(s)
	}
}

func (s *Strength1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitStrength1(s)
	}
}

func (p *SysVerilogHDLParser) Strength1() (localctx IStrength1Context) {
	localctx = NewStrength1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, SysVerilogHDLParserRULE_strength1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1413)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(SysVerilogHDLParserPull1-141))|(1<<(SysVerilogHDLParserStrong1-141))|(1<<(SysVerilogHDLParserSupply1-141)))) != 0) || _la == SysVerilogHDLParserWeak1) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IHighz0Context is an interface to support dynamic dispatch.
type IHighz0Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHighz0Context differentiates from other interfaces.
	IsHighz0Context()
}

type Highz0Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHighz0Context() *Highz0Context {
	var p = new(Highz0Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_highz0
	return p
}

func (*Highz0Context) IsHighz0Context() {}

func NewHighz0Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Highz0Context {
	var p = new(Highz0Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_highz0

	return p
}

func (s *Highz0Context) GetParser() antlr.Parser { return s.parser }

func (s *Highz0Context) Highz0() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserHighz0, 0)
}

func (s *Highz0Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Highz0Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Highz0Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterHighz0(s)
	}
}

func (s *Highz0Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitHighz0(s)
	}
}

func (p *SysVerilogHDLParser) Highz0() (localctx IHighz0Context) {
	localctx = NewHighz0Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, SysVerilogHDLParserRULE_highz0)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1415)
		p.Match(SysVerilogHDLParserHighz0)
	}

	return localctx
}

// IHighz1Context is an interface to support dynamic dispatch.
type IHighz1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHighz1Context differentiates from other interfaces.
	IsHighz1Context()
}

type Highz1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHighz1Context() *Highz1Context {
	var p = new(Highz1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_highz1
	return p
}

func (*Highz1Context) IsHighz1Context() {}

func NewHighz1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Highz1Context {
	var p = new(Highz1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_highz1

	return p
}

func (s *Highz1Context) GetParser() antlr.Parser { return s.parser }

func (s *Highz1Context) Highz1() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserHighz1, 0)
}

func (s *Highz1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Highz1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Highz1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterHighz1(s)
	}
}

func (s *Highz1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitHighz1(s)
	}
}

func (p *SysVerilogHDLParser) Highz1() (localctx IHighz1Context) {
	localctx = NewHighz1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, SysVerilogHDLParserRULE_highz1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1417)
		p.Match(SysVerilogHDLParserHighz1)
	}

	return localctx
}

// ICharge_strengthContext is an interface to support dynamic dispatch.
type ICharge_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharge_strengthContext differentiates from other interfaces.
	IsCharge_strengthContext()
}

type Charge_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharge_strengthContext() *Charge_strengthContext {
	var p = new(Charge_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_charge_strength
	return p
}

func (*Charge_strengthContext) IsCharge_strengthContext() {}

func NewCharge_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Charge_strengthContext {
	var p = new(Charge_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_charge_strength

	return p
}

func (s *Charge_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Charge_strengthContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Charge_strengthContext) Charge_size() ICharge_sizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharge_sizeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharge_sizeContext)
}

func (s *Charge_strengthContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Charge_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Charge_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Charge_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterCharge_strength(s)
	}
}

func (s *Charge_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitCharge_strength(s)
	}
}

func (p *SysVerilogHDLParser) Charge_strength() (localctx ICharge_strengthContext) {
	localctx = NewCharge_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, SysVerilogHDLParserRULE_charge_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1419)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(1420)
		p.Charge_size()
	}
	{
		p.SetState(1421)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// ICharge_sizeContext is an interface to support dynamic dispatch.
type ICharge_sizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharge_sizeContext differentiates from other interfaces.
	IsCharge_sizeContext()
}

type Charge_sizeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharge_sizeContext() *Charge_sizeContext {
	var p = new(Charge_sizeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_charge_size
	return p
}

func (*Charge_sizeContext) IsCharge_sizeContext() {}

func NewCharge_sizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Charge_sizeContext {
	var p = new(Charge_sizeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_charge_size

	return p
}

func (s *Charge_sizeContext) GetParser() antlr.Parser { return s.parser }

func (s *Charge_sizeContext) Small() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSmall, 0)
}

func (s *Charge_sizeContext) Medium() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserMedium, 0)
}

func (s *Charge_sizeContext) Large() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserLarge, 0)
}

func (s *Charge_sizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Charge_sizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Charge_sizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterCharge_size(s)
	}
}

func (s *Charge_sizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitCharge_size(s)
	}
}

func (p *SysVerilogHDLParser) Charge_size() (localctx ICharge_sizeContext) {
	localctx = NewCharge_sizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, SysVerilogHDLParserRULE_charge_size)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1423)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SysVerilogHDLParserLarge || _la == SysVerilogHDLParserMedium || _la == SysVerilogHDLParserSmall) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IList_of_variable_descriptionsContext is an interface to support dynamic dispatch.
type IList_of_variable_descriptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_variable_descriptionsContext differentiates from other interfaces.
	IsList_of_variable_descriptionsContext()
}

type List_of_variable_descriptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_variable_descriptionsContext() *List_of_variable_descriptionsContext {
	var p = new(List_of_variable_descriptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_variable_descriptions
	return p
}

func (*List_of_variable_descriptionsContext) IsList_of_variable_descriptionsContext() {}

func NewList_of_variable_descriptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_variable_descriptionsContext {
	var p = new(List_of_variable_descriptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_variable_descriptions

	return p
}

func (s *List_of_variable_descriptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_variable_descriptionsContext) Variable_description() IVariable_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_descriptionContext)
}

func (s *List_of_variable_descriptionsContext) Comma_variable_description_star() IComma_variable_description_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_variable_description_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_variable_description_starContext)
}

func (s *List_of_variable_descriptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_variable_descriptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_variable_descriptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_variable_descriptions(s)
	}
}

func (s *List_of_variable_descriptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_variable_descriptions(s)
	}
}

func (p *SysVerilogHDLParser) List_of_variable_descriptions() (localctx IList_of_variable_descriptionsContext) {
	localctx = NewList_of_variable_descriptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, SysVerilogHDLParserRULE_list_of_variable_descriptions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1425)
		p.Variable_description()
	}
	{
		p.SetState(1426)
		p.Comma_variable_description_star()
	}

	return localctx
}

// IComma_variable_description_starContext is an interface to support dynamic dispatch.
type IComma_variable_description_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_variable_description_starContext differentiates from other interfaces.
	IsComma_variable_description_starContext()
}

type Comma_variable_description_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_variable_description_starContext() *Comma_variable_description_starContext {
	var p = new(Comma_variable_description_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_variable_description_star
	return p
}

func (*Comma_variable_description_starContext) IsComma_variable_description_starContext() {}

func NewComma_variable_description_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_variable_description_starContext {
	var p = new(Comma_variable_description_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_variable_description_star

	return p
}

func (s *Comma_variable_description_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_variable_description_starContext) AllComma_variable_description() []IComma_variable_descriptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_variable_descriptionContext)(nil)).Elem())
	var tst = make([]IComma_variable_descriptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_variable_descriptionContext)
		}
	}

	return tst
}

func (s *Comma_variable_description_starContext) Comma_variable_description(i int) IComma_variable_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_variable_descriptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_variable_descriptionContext)
}

func (s *Comma_variable_description_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_variable_description_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_variable_description_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_variable_description_star(s)
	}
}

func (s *Comma_variable_description_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_variable_description_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_variable_description_star() (localctx IComma_variable_description_starContext) {
	localctx = NewComma_variable_description_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, SysVerilogHDLParserRULE_comma_variable_description_star)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1431)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1428)
				p.Comma_variable_description()
			}

		}
		p.SetState(1433)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext())
	}

	return localctx
}

// IComma_variable_descriptionContext is an interface to support dynamic dispatch.
type IComma_variable_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_variable_descriptionContext differentiates from other interfaces.
	IsComma_variable_descriptionContext()
}

type Comma_variable_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_variable_descriptionContext() *Comma_variable_descriptionContext {
	var p = new(Comma_variable_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_variable_description
	return p
}

func (*Comma_variable_descriptionContext) IsComma_variable_descriptionContext() {}

func NewComma_variable_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_variable_descriptionContext {
	var p = new(Comma_variable_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_variable_description

	return p
}

func (s *Comma_variable_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_variable_descriptionContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_variable_descriptionContext) Variable_description() IVariable_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_descriptionContext)
}

func (s *Comma_variable_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_variable_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_variable_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_variable_description(s)
	}
}

func (s *Comma_variable_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_variable_description(s)
	}
}

func (p *SysVerilogHDLParser) Comma_variable_description() (localctx IComma_variable_descriptionContext) {
	localctx = NewComma_variable_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, SysVerilogHDLParserRULE_comma_variable_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1434)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(1435)
		p.Variable_description()
	}

	return localctx
}

// IVariable_descriptionContext is an interface to support dynamic dispatch.
type IVariable_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_descriptionContext differentiates from other interfaces.
	IsVariable_descriptionContext()
}

type Variable_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_descriptionContext() *Variable_descriptionContext {
	var p = new(Variable_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_variable_description
	return p
}

func (*Variable_descriptionContext) IsVariable_descriptionContext() {}

func NewVariable_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_descriptionContext {
	var p = new(Variable_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_variable_description

	return p
}

func (s *Variable_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_descriptionContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Variable_descriptionContext) Dimension_plus() IDimension_plusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimension_plusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimension_plusContext)
}

func (s *Variable_descriptionContext) Equal() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEqual, 0)
}

func (s *Variable_descriptionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterVariable_description(s)
	}
}

func (s *Variable_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitVariable_description(s)
	}
}

func (p *SysVerilogHDLParser) Variable_description() (localctx IVariable_descriptionContext) {
	localctx = NewVariable_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, SysVerilogHDLParserRULE_variable_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1437)
		p.Variable_identifier()
	}
	p.SetState(1439)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserLeft_bracket {
		{
			p.SetState(1438)
			p.Dimension_plus()
		}

	}
	p.SetState(1443)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserEqual {
		{
			p.SetState(1441)
			p.Match(SysVerilogHDLParserEqual)
		}
		{
			p.SetState(1442)
			p.Expression()
		}

	}

	return localctx
}

// IVariable_identifierContext is an interface to support dynamic dispatch.
type IVariable_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_identifierContext differentiates from other interfaces.
	IsVariable_identifierContext()
}

type Variable_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_identifierContext() *Variable_identifierContext {
	var p = new(Variable_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_variable_identifier
	return p
}

func (*Variable_identifierContext) IsVariable_identifierContext() {}

func NewVariable_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_identifierContext {
	var p = new(Variable_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_variable_identifier

	return p
}

func (s *Variable_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Variable_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterVariable_identifier(s)
	}
}

func (s *Variable_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitVariable_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Variable_identifier() (localctx IVariable_identifierContext) {
	localctx = NewVariable_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, SysVerilogHDLParserRULE_variable_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1445)
		p.Identifier()
	}

	return localctx
}

// IList_of_hierarchical_variable_descriptionsContext is an interface to support dynamic dispatch.
type IList_of_hierarchical_variable_descriptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_hierarchical_variable_descriptionsContext differentiates from other interfaces.
	IsList_of_hierarchical_variable_descriptionsContext()
}

type List_of_hierarchical_variable_descriptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_hierarchical_variable_descriptionsContext() *List_of_hierarchical_variable_descriptionsContext {
	var p = new(List_of_hierarchical_variable_descriptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_hierarchical_variable_descriptions
	return p
}

func (*List_of_hierarchical_variable_descriptionsContext) IsList_of_hierarchical_variable_descriptionsContext() {
}

func NewList_of_hierarchical_variable_descriptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_hierarchical_variable_descriptionsContext {
	var p = new(List_of_hierarchical_variable_descriptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_hierarchical_variable_descriptions

	return p
}

func (s *List_of_hierarchical_variable_descriptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_hierarchical_variable_descriptionsContext) Hierarchical_variable_description() IHierarchical_variable_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_variable_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_variable_descriptionContext)
}

func (s *List_of_hierarchical_variable_descriptionsContext) Comma_hierarchical_variable_description_star() IComma_hierarchical_variable_description_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_hierarchical_variable_description_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_hierarchical_variable_description_starContext)
}

func (s *List_of_hierarchical_variable_descriptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_hierarchical_variable_descriptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_hierarchical_variable_descriptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_hierarchical_variable_descriptions(s)
	}
}

func (s *List_of_hierarchical_variable_descriptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_hierarchical_variable_descriptions(s)
	}
}

func (p *SysVerilogHDLParser) List_of_hierarchical_variable_descriptions() (localctx IList_of_hierarchical_variable_descriptionsContext) {
	localctx = NewList_of_hierarchical_variable_descriptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, SysVerilogHDLParserRULE_list_of_hierarchical_variable_descriptions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1447)
		p.Hierarchical_variable_description()
	}
	{
		p.SetState(1448)
		p.Comma_hierarchical_variable_description_star()
	}

	return localctx
}

// IComma_hierarchical_variable_description_starContext is an interface to support dynamic dispatch.
type IComma_hierarchical_variable_description_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_hierarchical_variable_description_starContext differentiates from other interfaces.
	IsComma_hierarchical_variable_description_starContext()
}

type Comma_hierarchical_variable_description_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_hierarchical_variable_description_starContext() *Comma_hierarchical_variable_description_starContext {
	var p = new(Comma_hierarchical_variable_description_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_hierarchical_variable_description_star
	return p
}

func (*Comma_hierarchical_variable_description_starContext) IsComma_hierarchical_variable_description_starContext() {
}

func NewComma_hierarchical_variable_description_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_hierarchical_variable_description_starContext {
	var p = new(Comma_hierarchical_variable_description_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_hierarchical_variable_description_star

	return p
}

func (s *Comma_hierarchical_variable_description_starContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *Comma_hierarchical_variable_description_starContext) AllComma_hierarchical_variable_description() []IComma_hierarchical_variable_descriptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_hierarchical_variable_descriptionContext)(nil)).Elem())
	var tst = make([]IComma_hierarchical_variable_descriptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_hierarchical_variable_descriptionContext)
		}
	}

	return tst
}

func (s *Comma_hierarchical_variable_description_starContext) Comma_hierarchical_variable_description(i int) IComma_hierarchical_variable_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_hierarchical_variable_descriptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_hierarchical_variable_descriptionContext)
}

func (s *Comma_hierarchical_variable_description_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_hierarchical_variable_description_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_hierarchical_variable_description_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_hierarchical_variable_description_star(s)
	}
}

func (s *Comma_hierarchical_variable_description_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_hierarchical_variable_description_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_hierarchical_variable_description_star() (localctx IComma_hierarchical_variable_description_starContext) {
	localctx = NewComma_hierarchical_variable_description_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, SysVerilogHDLParserRULE_comma_hierarchical_variable_description_star)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1453)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1450)
				p.Comma_hierarchical_variable_description()
			}

		}
		p.SetState(1455)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())
	}

	return localctx
}

// IComma_hierarchical_variable_descriptionContext is an interface to support dynamic dispatch.
type IComma_hierarchical_variable_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_hierarchical_variable_descriptionContext differentiates from other interfaces.
	IsComma_hierarchical_variable_descriptionContext()
}

type Comma_hierarchical_variable_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_hierarchical_variable_descriptionContext() *Comma_hierarchical_variable_descriptionContext {
	var p = new(Comma_hierarchical_variable_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_hierarchical_variable_description
	return p
}

func (*Comma_hierarchical_variable_descriptionContext) IsComma_hierarchical_variable_descriptionContext() {
}

func NewComma_hierarchical_variable_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_hierarchical_variable_descriptionContext {
	var p = new(Comma_hierarchical_variable_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_hierarchical_variable_description

	return p
}

func (s *Comma_hierarchical_variable_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_hierarchical_variable_descriptionContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_hierarchical_variable_descriptionContext) Hierarchical_variable_description() IHierarchical_variable_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_variable_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_variable_descriptionContext)
}

func (s *Comma_hierarchical_variable_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_hierarchical_variable_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_hierarchical_variable_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_hierarchical_variable_description(s)
	}
}

func (s *Comma_hierarchical_variable_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_hierarchical_variable_description(s)
	}
}

func (p *SysVerilogHDLParser) Comma_hierarchical_variable_description() (localctx IComma_hierarchical_variable_descriptionContext) {
	localctx = NewComma_hierarchical_variable_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, SysVerilogHDLParserRULE_comma_hierarchical_variable_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1456)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(1457)
		p.Hierarchical_variable_description()
	}

	return localctx
}

// IHierarchical_variable_descriptionContext is an interface to support dynamic dispatch.
type IHierarchical_variable_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_variable_descriptionContext differentiates from other interfaces.
	IsHierarchical_variable_descriptionContext()
}

type Hierarchical_variable_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_variable_descriptionContext() *Hierarchical_variable_descriptionContext {
	var p = new(Hierarchical_variable_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_variable_description
	return p
}

func (*Hierarchical_variable_descriptionContext) IsHierarchical_variable_descriptionContext() {}

func NewHierarchical_variable_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_variable_descriptionContext {
	var p = new(Hierarchical_variable_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_variable_description

	return p
}

func (s *Hierarchical_variable_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_variable_descriptionContext) Hierarchical_variable_identifier() IHierarchical_variable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_variable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_variable_identifierContext)
}

func (s *Hierarchical_variable_descriptionContext) Dimension_plus() IDimension_plusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimension_plusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimension_plusContext)
}

func (s *Hierarchical_variable_descriptionContext) Equal() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEqual, 0)
}

func (s *Hierarchical_variable_descriptionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Hierarchical_variable_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_variable_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_variable_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterHierarchical_variable_description(s)
	}
}

func (s *Hierarchical_variable_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitHierarchical_variable_description(s)
	}
}

func (p *SysVerilogHDLParser) Hierarchical_variable_description() (localctx IHierarchical_variable_descriptionContext) {
	localctx = NewHierarchical_variable_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, SysVerilogHDLParserRULE_hierarchical_variable_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1459)
		p.Hierarchical_variable_identifier()
	}
	p.SetState(1461)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserLeft_bracket {
		{
			p.SetState(1460)
			p.Dimension_plus()
		}

	}
	p.SetState(1465)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserEqual {
		{
			p.SetState(1463)
			p.Match(SysVerilogHDLParserEqual)
		}
		{
			p.SetState(1464)
			p.Expression()
		}

	}

	return localctx
}

// IHierarchical_variable_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_variable_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_variable_identifierContext differentiates from other interfaces.
	IsHierarchical_variable_identifierContext()
}

type Hierarchical_variable_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_variable_identifierContext() *Hierarchical_variable_identifierContext {
	var p = new(Hierarchical_variable_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_variable_identifier
	return p
}

func (*Hierarchical_variable_identifierContext) IsHierarchical_variable_identifierContext() {}

func NewHierarchical_variable_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_variable_identifierContext {
	var p = new(Hierarchical_variable_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_variable_identifier

	return p
}

func (s *Hierarchical_variable_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_variable_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_variable_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_variable_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_variable_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterHierarchical_variable_identifier(s)
	}
}

func (s *Hierarchical_variable_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitHierarchical_variable_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Hierarchical_variable_identifier() (localctx IHierarchical_variable_identifierContext) {
	localctx = NewHierarchical_variable_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, SysVerilogHDLParserRULE_hierarchical_variable_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1467)
		p.Hierarchical_identifier()
	}

	return localctx
}

// INet_declarationContext is an interface to support dynamic dispatch.
type INet_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_declarationContext differentiates from other interfaces.
	IsNet_declarationContext()
}

type Net_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_declarationContext() *Net_declarationContext {
	var p = new(Net_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_net_declaration
	return p
}

func (*Net_declarationContext) IsNet_declarationContext() {}

func NewNet_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_declarationContext {
	var p = new(Net_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_net_declaration

	return p
}

func (s *Net_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_declarationContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Net_declarationContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *Net_declarationContext) User_type() IUser_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUser_typeContext)
}

func (s *Net_declarationContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *Net_declarationContext) Charge_strength() ICharge_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharge_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharge_strengthContext)
}

func (s *Net_declarationContext) Dimension_plus() IDimension_plusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimension_plusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimension_plusContext)
}

func (s *Net_declarationContext) Delay() IDelayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelayContext)
}

func (s *Net_declarationContext) Vectored() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserVectored, 0)
}

func (s *Net_declarationContext) Scalared() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserScalared, 0)
}

func (s *Net_declarationContext) Signed() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSigned, 0)
}

func (s *Net_declarationContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserUnsigned, 0)
}

func (s *Net_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterNet_declaration(s)
	}
}

func (s *Net_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitNet_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Net_declaration() (localctx INet_declarationContext) {
	localctx = NewNet_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, SysVerilogHDLParserRULE_net_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1469)
		p.Net_type()
	}
	p.SetState(1471)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1470)
			p.User_type()
		}

	}
	p.SetState(1474)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1473)
			p.Drive_strength()
		}

	}
	p.SetState(1477)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserOpen_parenthesis {
		{
			p.SetState(1476)
			p.Charge_strength()
		}

	}
	p.SetState(1480)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserScalared || _la == SysVerilogHDLParserVectored {
		{
			p.SetState(1479)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SysVerilogHDLParserScalared || _la == SysVerilogHDLParserVectored) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1483)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned {
		{
			p.SetState(1482)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1486)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserLeft_bracket {
		{
			p.SetState(1485)
			p.Dimension_plus()
		}

	}
	p.SetState(1489)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserHash {
		{
			p.SetState(1488)
			p.Delay()
		}

	}
	{
		p.SetState(1491)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// IReg_declarationContext is an interface to support dynamic dispatch.
type IReg_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReg_declarationContext differentiates from other interfaces.
	IsReg_declarationContext()
}

type Reg_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReg_declarationContext() *Reg_declarationContext {
	var p = new(Reg_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_reg_declaration
	return p
}

func (*Reg_declarationContext) IsReg_declarationContext() {}

func NewReg_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reg_declarationContext {
	var p = new(Reg_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_reg_declaration

	return p
}

func (s *Reg_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Reg_declarationContext) Reg() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserReg, 0)
}

func (s *Reg_declarationContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *Reg_declarationContext) Dimension_plus() IDimension_plusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimension_plusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimension_plusContext)
}

func (s *Reg_declarationContext) Signed() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSigned, 0)
}

func (s *Reg_declarationContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserUnsigned, 0)
}

func (s *Reg_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reg_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reg_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterReg_declaration(s)
	}
}

func (s *Reg_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitReg_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Reg_declaration() (localctx IReg_declarationContext) {
	localctx = NewReg_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, SysVerilogHDLParserRULE_reg_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1493)
		p.Match(SysVerilogHDLParserReg)
	}
	p.SetState(1495)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned {
		{
			p.SetState(1494)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1498)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserLeft_bracket {
		{
			p.SetState(1497)
			p.Dimension_plus()
		}

	}
	{
		p.SetState(1500)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// ILogic_declarationContext is an interface to support dynamic dispatch.
type ILogic_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogic_declarationContext differentiates from other interfaces.
	IsLogic_declarationContext()
}

type Logic_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogic_declarationContext() *Logic_declarationContext {
	var p = new(Logic_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_logic_declaration
	return p
}

func (*Logic_declarationContext) IsLogic_declarationContext() {}

func NewLogic_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logic_declarationContext {
	var p = new(Logic_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_logic_declaration

	return p
}

func (s *Logic_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Logic_declarationContext) Logic() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserLogic, 0)
}

func (s *Logic_declarationContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *Logic_declarationContext) Dimension_plus() IDimension_plusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimension_plusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimension_plusContext)
}

func (s *Logic_declarationContext) Signed() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSigned, 0)
}

func (s *Logic_declarationContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserUnsigned, 0)
}

func (s *Logic_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logic_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logic_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterLogic_declaration(s)
	}
}

func (s *Logic_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitLogic_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Logic_declaration() (localctx ILogic_declarationContext) {
	localctx = NewLogic_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, SysVerilogHDLParserRULE_logic_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1502)
		p.Match(SysVerilogHDLParserLogic)
	}
	p.SetState(1504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned {
		{
			p.SetState(1503)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1507)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserLeft_bracket {
		{
			p.SetState(1506)
			p.Dimension_plus()
		}

	}
	{
		p.SetState(1509)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// IBits_typeContext is an interface to support dynamic dispatch.
type IBits_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBits_typeContext differentiates from other interfaces.
	IsBits_typeContext()
}

type Bits_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBits_typeContext() *Bits_typeContext {
	var p = new(Bits_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_bits_type
	return p
}

func (*Bits_typeContext) IsBits_typeContext() {}

func NewBits_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bits_typeContext {
	var p = new(Bits_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_bits_type

	return p
}

func (s *Bits_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Bits_typeContext) Bit() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserBit, 0)
}

func (s *Bits_typeContext) Byte() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserByte, 0)
}

func (s *Bits_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bits_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bits_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterBits_type(s)
	}
}

func (s *Bits_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitBits_type(s)
	}
}

func (p *SysVerilogHDLParser) Bits_type() (localctx IBits_typeContext) {
	localctx = NewBits_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, SysVerilogHDLParserRULE_bits_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1511)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SysVerilogHDLParserBit || _la == SysVerilogHDLParserByte) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBits_declarationContext is an interface to support dynamic dispatch.
type IBits_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBits_declarationContext differentiates from other interfaces.
	IsBits_declarationContext()
}

type Bits_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBits_declarationContext() *Bits_declarationContext {
	var p = new(Bits_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_bits_declaration
	return p
}

func (*Bits_declarationContext) IsBits_declarationContext() {}

func NewBits_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bits_declarationContext {
	var p = new(Bits_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_bits_declaration

	return p
}

func (s *Bits_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Bits_declarationContext) Bits_type() IBits_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBits_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBits_typeContext)
}

func (s *Bits_declarationContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *Bits_declarationContext) Dimension_plus() IDimension_plusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimension_plusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimension_plusContext)
}

func (s *Bits_declarationContext) Signed() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSigned, 0)
}

func (s *Bits_declarationContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserUnsigned, 0)
}

func (s *Bits_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bits_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bits_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterBits_declaration(s)
	}
}

func (s *Bits_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitBits_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Bits_declaration() (localctx IBits_declarationContext) {
	localctx = NewBits_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, SysVerilogHDLParserRULE_bits_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1513)
		p.Bits_type()
	}
	p.SetState(1515)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned {
		{
			p.SetState(1514)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1518)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserLeft_bracket {
		{
			p.SetState(1517)
			p.Dimension_plus()
		}

	}
	{
		p.SetState(1520)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// IInteger_declarationContext is an interface to support dynamic dispatch.
type IInteger_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInteger_declarationContext differentiates from other interfaces.
	IsInteger_declarationContext()
}

type Integer_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_declarationContext() *Integer_declarationContext {
	var p = new(Integer_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_integer_declaration
	return p
}

func (*Integer_declarationContext) IsInteger_declarationContext() {}

func NewInteger_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_declarationContext {
	var p = new(Integer_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_integer_declaration

	return p
}

func (s *Integer_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_declarationContext) Integer() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserInteger, 0)
}

func (s *Integer_declarationContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *Integer_declarationContext) Automatic() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserAutomatic, 0)
}

func (s *Integer_declarationContext) Signed() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSigned, 0)
}

func (s *Integer_declarationContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserUnsigned, 0)
}

func (s *Integer_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterInteger_declaration(s)
	}
}

func (s *Integer_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitInteger_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Integer_declaration() (localctx IInteger_declarationContext) {
	localctx = NewInteger_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, SysVerilogHDLParserRULE_integer_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1523)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserAutomatic {
		{
			p.SetState(1522)
			p.Match(SysVerilogHDLParserAutomatic)
		}

	}
	{
		p.SetState(1525)
		p.Match(SysVerilogHDLParserInteger)
	}
	p.SetState(1527)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned {
		{
			p.SetState(1526)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1529)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// IInt_declarationContext is an interface to support dynamic dispatch.
type IInt_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInt_declarationContext differentiates from other interfaces.
	IsInt_declarationContext()
}

type Int_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInt_declarationContext() *Int_declarationContext {
	var p = new(Int_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_int_declaration
	return p
}

func (*Int_declarationContext) IsInt_declarationContext() {}

func NewInt_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int_declarationContext {
	var p = new(Int_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_int_declaration

	return p
}

func (s *Int_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Int_declarationContext) Int() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserInt, 0)
}

func (s *Int_declarationContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *Int_declarationContext) Automatic() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserAutomatic, 0)
}

func (s *Int_declarationContext) Static() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserStatic, 0)
}

func (s *Int_declarationContext) Const() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserConst, 0)
}

func (s *Int_declarationContext) Signed() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSigned, 0)
}

func (s *Int_declarationContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserUnsigned, 0)
}

func (s *Int_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Int_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterInt_declaration(s)
	}
}

func (s *Int_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitInt_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Int_declaration() (localctx IInt_declarationContext) {
	localctx = NewInt_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, SysVerilogHDLParserRULE_int_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1532)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserAutomatic || _la == SysVerilogHDLParserConst || _la == SysVerilogHDLParserStatic {
		{
			p.SetState(1531)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SysVerilogHDLParserAutomatic || _la == SysVerilogHDLParserConst || _la == SysVerilogHDLParserStatic) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1534)
		p.Match(SysVerilogHDLParserInt)
	}
	p.SetState(1536)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned {
		{
			p.SetState(1535)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1538)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// IReal_declarationContext is an interface to support dynamic dispatch.
type IReal_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReal_declarationContext differentiates from other interfaces.
	IsReal_declarationContext()
}

type Real_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_declarationContext() *Real_declarationContext {
	var p = new(Real_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_real_declaration
	return p
}

func (*Real_declarationContext) IsReal_declarationContext() {}

func NewReal_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_declarationContext {
	var p = new(Real_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_real_declaration

	return p
}

func (s *Real_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_declarationContext) Real() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserReal, 0)
}

func (s *Real_declarationContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *Real_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterReal_declaration(s)
	}
}

func (s *Real_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitReal_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Real_declaration() (localctx IReal_declarationContext) {
	localctx = NewReal_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, SysVerilogHDLParserRULE_real_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1540)
		p.Match(SysVerilogHDLParserReal)
	}
	{
		p.SetState(1541)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// ITime_declarationContext is an interface to support dynamic dispatch.
type ITime_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTime_declarationContext differentiates from other interfaces.
	IsTime_declarationContext()
}

type Time_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTime_declarationContext() *Time_declarationContext {
	var p = new(Time_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_time_declaration
	return p
}

func (*Time_declarationContext) IsTime_declarationContext() {}

func NewTime_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Time_declarationContext {
	var p = new(Time_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_time_declaration

	return p
}

func (s *Time_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Time_declarationContext) Time() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTime, 0)
}

func (s *Time_declarationContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *Time_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Time_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Time_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTime_declaration(s)
	}
}

func (s *Time_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTime_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Time_declaration() (localctx ITime_declarationContext) {
	localctx = NewTime_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, SysVerilogHDLParserRULE_time_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1543)
		p.Match(SysVerilogHDLParserTime)
	}
	{
		p.SetState(1544)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// IRealtime_declarationContext is an interface to support dynamic dispatch.
type IRealtime_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRealtime_declarationContext differentiates from other interfaces.
	IsRealtime_declarationContext()
}

type Realtime_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRealtime_declarationContext() *Realtime_declarationContext {
	var p = new(Realtime_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_realtime_declaration
	return p
}

func (*Realtime_declarationContext) IsRealtime_declarationContext() {}

func NewRealtime_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Realtime_declarationContext {
	var p = new(Realtime_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_realtime_declaration

	return p
}

func (s *Realtime_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Realtime_declarationContext) Realtime() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRealtime, 0)
}

func (s *Realtime_declarationContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *Realtime_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Realtime_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Realtime_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterRealtime_declaration(s)
	}
}

func (s *Realtime_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitRealtime_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Realtime_declaration() (localctx IRealtime_declarationContext) {
	localctx = NewRealtime_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, SysVerilogHDLParserRULE_realtime_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1546)
		p.Match(SysVerilogHDLParserRealtime)
	}
	{
		p.SetState(1547)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// IEvent_declarationContext is an interface to support dynamic dispatch.
type IEvent_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_declarationContext differentiates from other interfaces.
	IsEvent_declarationContext()
}

type Event_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_declarationContext() *Event_declarationContext {
	var p = new(Event_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_event_declaration
	return p
}

func (*Event_declarationContext) IsEvent_declarationContext() {}

func NewEvent_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_declarationContext {
	var p = new(Event_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_event_declaration

	return p
}

func (s *Event_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_declarationContext) Event_keyword() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEvent_keyword, 0)
}

func (s *Event_declarationContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *Event_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEvent_declaration(s)
	}
}

func (s *Event_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEvent_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Event_declaration() (localctx IEvent_declarationContext) {
	localctx = NewEvent_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, SysVerilogHDLParserRULE_event_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1549)
		p.Match(SysVerilogHDLParserEvent_keyword)
	}
	{
		p.SetState(1550)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// IGenvar_declarationContext is an interface to support dynamic dispatch.
type IGenvar_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_declarationContext differentiates from other interfaces.
	IsGenvar_declarationContext()
}

type Genvar_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_declarationContext() *Genvar_declarationContext {
	var p = new(Genvar_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_genvar_declaration
	return p
}

func (*Genvar_declarationContext) IsGenvar_declarationContext() {}

func NewGenvar_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_declarationContext {
	var p = new(Genvar_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_genvar_declaration

	return p
}

func (s *Genvar_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_declarationContext) Genvar() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserGenvar, 0)
}

func (s *Genvar_declarationContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *Genvar_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenvar_declaration(s)
	}
}

func (s *Genvar_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenvar_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Genvar_declaration() (localctx IGenvar_declarationContext) {
	localctx = NewGenvar_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, SysVerilogHDLParserRULE_genvar_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1552)
		p.Match(SysVerilogHDLParserGenvar)
	}
	{
		p.SetState(1553)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// IUsertype_variable_declarationContext is an interface to support dynamic dispatch.
type IUsertype_variable_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUsertype_variable_declarationContext differentiates from other interfaces.
	IsUsertype_variable_declarationContext()
}

type Usertype_variable_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsertype_variable_declarationContext() *Usertype_variable_declarationContext {
	var p = new(Usertype_variable_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_usertype_variable_declaration
	return p
}

func (*Usertype_variable_declarationContext) IsUsertype_variable_declarationContext() {}

func NewUsertype_variable_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Usertype_variable_declarationContext {
	var p = new(Usertype_variable_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_usertype_variable_declaration

	return p
}

func (s *Usertype_variable_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Usertype_variable_declarationContext) User_type() IUser_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUser_typeContext)
}

func (s *Usertype_variable_declarationContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *Usertype_variable_declarationContext) Automatic() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserAutomatic, 0)
}

func (s *Usertype_variable_declarationContext) Dimension() IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Usertype_variable_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Usertype_variable_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Usertype_variable_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterUsertype_variable_declaration(s)
	}
}

func (s *Usertype_variable_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitUsertype_variable_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Usertype_variable_declaration() (localctx IUsertype_variable_declarationContext) {
	localctx = NewUsertype_variable_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, SysVerilogHDLParserRULE_usertype_variable_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1556)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserAutomatic {
		{
			p.SetState(1555)
			p.Match(SysVerilogHDLParserAutomatic)
		}

	}
	{
		p.SetState(1558)
		p.User_type()
	}
	p.SetState(1560)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserLeft_bracket {
		{
			p.SetState(1559)
			p.Dimension()
		}

	}
	{
		p.SetState(1562)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// IString_declarationContext is an interface to support dynamic dispatch.
type IString_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsString_declarationContext differentiates from other interfaces.
	IsString_declarationContext()
}

type String_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_declarationContext() *String_declarationContext {
	var p = new(String_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_string_declaration
	return p
}

func (*String_declarationContext) IsString_declarationContext() {}

func NewString_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_declarationContext {
	var p = new(String_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_string_declaration

	return p
}

func (s *String_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *String_declarationContext) SVString() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSVString, 0)
}

func (s *String_declarationContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *String_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterString_declaration(s)
	}
}

func (s *String_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitString_declaration(s)
	}
}

func (p *SysVerilogHDLParser) String_declaration() (localctx IString_declarationContext) {
	localctx = NewString_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, SysVerilogHDLParserRULE_string_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1564)
		p.Match(SysVerilogHDLParserSVString)
	}
	{
		p.SetState(1565)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// IStruct_declarationContext is an interface to support dynamic dispatch.
type IStruct_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_declarationContext differentiates from other interfaces.
	IsStruct_declarationContext()
}

type Struct_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_declarationContext() *Struct_declarationContext {
	var p = new(Struct_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_struct_declaration
	return p
}

func (*Struct_declarationContext) IsStruct_declarationContext() {}

func NewStruct_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_declarationContext {
	var p = new(Struct_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_struct_declaration

	return p
}

func (s *Struct_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_declarationContext) Struct_type() IStruct_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_typeContext)
}

func (s *Struct_declarationContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *Struct_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterStruct_declaration(s)
	}
}

func (s *Struct_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitStruct_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Struct_declaration() (localctx IStruct_declarationContext) {
	localctx = NewStruct_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, SysVerilogHDLParserRULE_struct_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1567)
		p.Struct_type()
	}
	{
		p.SetState(1568)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// IEnum_declarationContext is an interface to support dynamic dispatch.
type IEnum_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_declarationContext differentiates from other interfaces.
	IsEnum_declarationContext()
}

type Enum_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_declarationContext() *Enum_declarationContext {
	var p = new(Enum_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_enum_declaration
	return p
}

func (*Enum_declarationContext) IsEnum_declarationContext() {}

func NewEnum_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_declarationContext {
	var p = new(Enum_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_enum_declaration

	return p
}

func (s *Enum_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_declarationContext) Enumerated_type() IEnumerated_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerated_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerated_typeContext)
}

func (s *Enum_declarationContext) List_of_variable_descriptions() IList_of_variable_descriptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_descriptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_descriptionsContext)
}

func (s *Enum_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEnum_declaration(s)
	}
}

func (s *Enum_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEnum_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Enum_declaration() (localctx IEnum_declarationContext) {
	localctx = NewEnum_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, SysVerilogHDLParserRULE_enum_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1570)
		p.Enumerated_type()
	}
	{
		p.SetState(1571)
		p.List_of_variable_descriptions()
	}

	return localctx
}

// IFunction_declarationContext is an interface to support dynamic dispatch.
type IFunction_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_declarationContext differentiates from other interfaces.
	IsFunction_declarationContext()
}

type Function_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_declarationContext() *Function_declarationContext {
	var p = new(Function_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_function_declaration
	return p
}

func (*Function_declarationContext) IsFunction_declarationContext() {}

func NewFunction_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_declarationContext {
	var p = new(Function_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_function_declaration

	return p
}

func (s *Function_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_declarationContext) Function() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserFunction, 0)
}

func (s *Function_declarationContext) Function_identifier() IFunction_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_identifierContext)
}

func (s *Function_declarationContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Function_declarationContext) Function_item_declaration_star() IFunction_item_declaration_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_item_declaration_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_item_declaration_starContext)
}

func (s *Function_declarationContext) Function_statement() IFunction_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_statementContext)
}

func (s *Function_declarationContext) Endfunction() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEndfunction, 0)
}

func (s *Function_declarationContext) Automatic() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserAutomatic, 0)
}

func (s *Function_declarationContext) Function_type() IFunction_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_typeContext)
}

func (s *Function_declarationContext) Dimension() IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Function_declarationContext) Function_interface() IFunction_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_interfaceContext)
}

func (s *Function_declarationContext) Colon_function_identifier() IColon_function_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColon_function_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColon_function_identifierContext)
}

func (s *Function_declarationContext) Signed() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSigned, 0)
}

func (s *Function_declarationContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserUnsigned, 0)
}

func (s *Function_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterFunction_declaration(s)
	}
}

func (s *Function_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitFunction_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Function_declaration() (localctx IFunction_declarationContext) {
	localctx = NewFunction_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, SysVerilogHDLParserRULE_function_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1573)
		p.Match(SysVerilogHDLParserFunction)
	}
	p.SetState(1575)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserAutomatic {
		{
			p.SetState(1574)
			p.Match(SysVerilogHDLParserAutomatic)
		}

	}
	p.SetState(1578)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned {
		{
			p.SetState(1577)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1581)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1580)
			p.Function_type()
		}

	}
	p.SetState(1584)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserLeft_bracket {
		{
			p.SetState(1583)
			p.Dimension()
		}

	}
	{
		p.SetState(1586)
		p.Function_identifier()
	}
	p.SetState(1588)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserOpen_parenthesis {
		{
			p.SetState(1587)
			p.Function_interface()
		}

	}
	{
		p.SetState(1590)
		p.Semicolon()
	}
	{
		p.SetState(1591)
		p.Function_item_declaration_star()
	}
	{
		p.SetState(1592)
		p.Function_statement()
	}
	{
		p.SetState(1593)
		p.Match(SysVerilogHDLParserEndfunction)
	}
	p.SetState(1595)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserColon {
		{
			p.SetState(1594)
			p.Colon_function_identifier()
		}

	}

	return localctx
}

// IFunction_typeContext is an interface to support dynamic dispatch.
type IFunction_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_typeContext differentiates from other interfaces.
	IsFunction_typeContext()
}

type Function_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_typeContext() *Function_typeContext {
	var p = new(Function_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_function_type
	return p
}

func (*Function_typeContext) IsFunction_typeContext() {}

func NewFunction_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_typeContext {
	var p = new(Function_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_function_type

	return p
}

func (s *Function_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_typeContext) Logic() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserLogic, 0)
}

func (s *Function_typeContext) Integer() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserInteger, 0)
}

func (s *Function_typeContext) Int() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserInt, 0)
}

func (s *Function_typeContext) Real() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserReal, 0)
}

func (s *Function_typeContext) Realtime() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRealtime, 0)
}

func (s *Function_typeContext) Time() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTime, 0)
}

func (s *Function_typeContext) Reg() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserReg, 0)
}

func (s *Function_typeContext) SVString() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSVString, 0)
}

func (s *Function_typeContext) Bits_type() IBits_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBits_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBits_typeContext)
}

func (s *Function_typeContext) User_type() IUser_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUser_typeContext)
}

func (s *Function_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterFunction_type(s)
	}
}

func (s *Function_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitFunction_type(s)
	}
}

func (p *SysVerilogHDLParser) Function_type() (localctx IFunction_typeContext) {
	localctx = NewFunction_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, SysVerilogHDLParserRULE_function_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1607)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserLogic:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1597)
			p.Match(SysVerilogHDLParserLogic)
		}

	case SysVerilogHDLParserInteger:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1598)
			p.Match(SysVerilogHDLParserInteger)
		}

	case SysVerilogHDLParserInt:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1599)
			p.Match(SysVerilogHDLParserInt)
		}

	case SysVerilogHDLParserReal:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1600)
			p.Match(SysVerilogHDLParserReal)
		}

	case SysVerilogHDLParserRealtime:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1601)
			p.Match(SysVerilogHDLParserRealtime)
		}

	case SysVerilogHDLParserTime:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1602)
			p.Match(SysVerilogHDLParserTime)
		}

	case SysVerilogHDLParserReg:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1603)
			p.Match(SysVerilogHDLParserReg)
		}

	case SysVerilogHDLParserSVString:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1604)
			p.Match(SysVerilogHDLParserSVString)
		}

	case SysVerilogHDLParserBit, SysVerilogHDLParserByte:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1605)
			p.Bits_type()
		}

	case SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1606)
			p.User_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunction_identifierContext is an interface to support dynamic dispatch.
type IFunction_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_identifierContext differentiates from other interfaces.
	IsFunction_identifierContext()
}

type Function_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_identifierContext() *Function_identifierContext {
	var p = new(Function_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_function_identifier
	return p
}

func (*Function_identifierContext) IsFunction_identifierContext() {}

func NewFunction_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_identifierContext {
	var p = new(Function_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_function_identifier

	return p
}

func (s *Function_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Function_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterFunction_identifier(s)
	}
}

func (s *Function_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitFunction_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Function_identifier() (localctx IFunction_identifierContext) {
	localctx = NewFunction_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, SysVerilogHDLParserRULE_function_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1609)
		p.Identifier()
	}

	return localctx
}

// IFunction_interfaceContext is an interface to support dynamic dispatch.
type IFunction_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_interfaceContext differentiates from other interfaces.
	IsFunction_interfaceContext()
}

type Function_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_interfaceContext() *Function_interfaceContext {
	var p = new(Function_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_function_interface
	return p
}

func (*Function_interfaceContext) IsFunction_interfaceContext() {}

func NewFunction_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_interfaceContext {
	var p = new(Function_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_function_interface

	return p
}

func (s *Function_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_interfaceContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Function_interfaceContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Function_interfaceContext) List_of_tf_interface_ports() IList_of_tf_interface_portsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_tf_interface_portsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_tf_interface_portsContext)
}

func (s *Function_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterFunction_interface(s)
	}
}

func (s *Function_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitFunction_interface(s)
	}
}

func (p *SysVerilogHDLParser) Function_interface() (localctx IFunction_interfaceContext) {
	localctx = NewFunction_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, SysVerilogHDLParserRULE_function_interface)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1611)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	p.SetState(1613)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-55)&-(0x1f+1)) == 0 && ((1<<uint((_la-55)))&((1<<(SysVerilogHDLParserAutomatic-55))|(1<<(SysVerilogHDLParserBit-55))|(1<<(SysVerilogHDLParserByte-55))|(1<<(SysVerilogHDLParserConst-55)))) != 0) || (((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(SysVerilogHDLParserInout-106))|(1<<(SysVerilogHDLParserInput-106))|(1<<(SysVerilogHDLParserInt-106))|(1<<(SysVerilogHDLParserInteger-106))|(1<<(SysVerilogHDLParserLogic-106))|(1<<(SysVerilogHDLParserNONE-106))|(1<<(SysVerilogHDLParserOutput-106)))) != 0) || (((_la-147)&-(0x1f+1)) == 0 && ((1<<uint((_la-147)))&((1<<(SysVerilogHDLParserReal-147))|(1<<(SysVerilogHDLParserRef-147))|(1<<(SysVerilogHDLParserReg-147))|(1<<(SysVerilogHDLParserSigned-147))|(1<<(SysVerilogHDLParserStatic-147))|(1<<(SysVerilogHDLParserSVString-147))|(1<<(SysVerilogHDLParserSupply0-147))|(1<<(SysVerilogHDLParserSupply1-147))|(1<<(SysVerilogHDLParserTime-147)))) != 0) || (((_la-180)&-(0x1f+1)) == 0 && ((1<<uint((_la-180)))&((1<<(SysVerilogHDLParserTri-180))|(1<<(SysVerilogHDLParserTri_and-180))|(1<<(SysVerilogHDLParserTri_or-180))|(1<<(SysVerilogHDLParserTri_reg-180))|(1<<(SysVerilogHDLParserTri0-180))|(1<<(SysVerilogHDLParserTri1-180))|(1<<(SysVerilogHDLParserUnsigned-180))|(1<<(SysVerilogHDLParserUwire-180))|(1<<(SysVerilogHDLParserWand-180))|(1<<(SysVerilogHDLParserWire-180))|(1<<(SysVerilogHDLParserWor-180))|(1<<(SysVerilogHDLParserEscaped_identifier-180))|(1<<(SysVerilogHDLParserSimple_identifier-180)))) != 0) || _la == SysVerilogHDLParserLeft_bracket || _la == SysVerilogHDLParserOpen_parenthesis {
		{
			p.SetState(1612)
			p.List_of_tf_interface_ports()
		}

	}
	{
		p.SetState(1615)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// IFunction_item_declaration_starContext is an interface to support dynamic dispatch.
type IFunction_item_declaration_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_item_declaration_starContext differentiates from other interfaces.
	IsFunction_item_declaration_starContext()
}

type Function_item_declaration_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_item_declaration_starContext() *Function_item_declaration_starContext {
	var p = new(Function_item_declaration_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_function_item_declaration_star
	return p
}

func (*Function_item_declaration_starContext) IsFunction_item_declaration_starContext() {}

func NewFunction_item_declaration_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_item_declaration_starContext {
	var p = new(Function_item_declaration_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_function_item_declaration_star

	return p
}

func (s *Function_item_declaration_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_item_declaration_starContext) AllFunction_item_declaration_semicolon() []IFunction_item_declaration_semicolonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_item_declaration_semicolonContext)(nil)).Elem())
	var tst = make([]IFunction_item_declaration_semicolonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_item_declaration_semicolonContext)
		}
	}

	return tst
}

func (s *Function_item_declaration_starContext) Function_item_declaration_semicolon(i int) IFunction_item_declaration_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_item_declaration_semicolonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_item_declaration_semicolonContext)
}

func (s *Function_item_declaration_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_item_declaration_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_item_declaration_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterFunction_item_declaration_star(s)
	}
}

func (s *Function_item_declaration_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitFunction_item_declaration_star(s)
	}
}

func (p *SysVerilogHDLParser) Function_item_declaration_star() (localctx IFunction_item_declaration_starContext) {
	localctx = NewFunction_item_declaration_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, SysVerilogHDLParserRULE_function_item_declaration_star)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1620)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1617)
				p.Function_item_declaration_semicolon()
			}

		}
		p.SetState(1622)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext())
	}

	return localctx
}

// IFunction_item_declaration_semicolonContext is an interface to support dynamic dispatch.
type IFunction_item_declaration_semicolonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_item_declaration_semicolonContext differentiates from other interfaces.
	IsFunction_item_declaration_semicolonContext()
}

type Function_item_declaration_semicolonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_item_declaration_semicolonContext() *Function_item_declaration_semicolonContext {
	var p = new(Function_item_declaration_semicolonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_function_item_declaration_semicolon
	return p
}

func (*Function_item_declaration_semicolonContext) IsFunction_item_declaration_semicolonContext() {}

func NewFunction_item_declaration_semicolonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_item_declaration_semicolonContext {
	var p = new(Function_item_declaration_semicolonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_function_item_declaration_semicolon

	return p
}

func (s *Function_item_declaration_semicolonContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_item_declaration_semicolonContext) Function_item_declaration() IFunction_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_item_declarationContext)
}

func (s *Function_item_declaration_semicolonContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Function_item_declaration_semicolonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_item_declaration_semicolonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_item_declaration_semicolonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterFunction_item_declaration_semicolon(s)
	}
}

func (s *Function_item_declaration_semicolonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitFunction_item_declaration_semicolon(s)
	}
}

func (p *SysVerilogHDLParser) Function_item_declaration_semicolon() (localctx IFunction_item_declaration_semicolonContext) {
	localctx = NewFunction_item_declaration_semicolonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, SysVerilogHDLParserRULE_function_item_declaration_semicolon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1623)
		p.Function_item_declaration()
	}
	{
		p.SetState(1624)
		p.Semicolon()
	}

	return localctx
}

// IFunction_item_declarationContext is an interface to support dynamic dispatch.
type IFunction_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_item_declarationContext differentiates from other interfaces.
	IsFunction_item_declarationContext()
}

type Function_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_item_declarationContext() *Function_item_declarationContext {
	var p = new(Function_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_function_item_declaration
	return p
}

func (*Function_item_declarationContext) IsFunction_item_declarationContext() {}

func NewFunction_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_item_declarationContext {
	var p = new(Function_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_function_item_declaration

	return p
}

func (s *Function_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_item_declarationContext) Block_item_declaration() IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Function_item_declarationContext) Port_declaration() IPort_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_declarationContext)
}

func (s *Function_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterFunction_item_declaration(s)
	}
}

func (s *Function_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitFunction_item_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Function_item_declaration() (localctx IFunction_item_declarationContext) {
	localctx = NewFunction_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, SysVerilogHDLParserRULE_function_item_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1628)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserAutomatic, SysVerilogHDLParserBit, SysVerilogHDLParserByte, SysVerilogHDLParserConst, SysVerilogHDLParserEvent_keyword, SysVerilogHDLParserInt, SysVerilogHDLParserInteger, SysVerilogHDLParserLocalparam, SysVerilogHDLParserLogic, SysVerilogHDLParserParameter, SysVerilogHDLParserReal, SysVerilogHDLParserRealtime, SysVerilogHDLParserReg, SysVerilogHDLParserStatic, SysVerilogHDLParserSVString, SysVerilogHDLParserTime, SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1626)
			p.Block_item_declaration()
		}

	case SysVerilogHDLParserInout, SysVerilogHDLParserInput, SysVerilogHDLParserOutput, SysVerilogHDLParserRef:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1627)
			p.Port_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunction_statementContext is an interface to support dynamic dispatch.
type IFunction_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_statementContext differentiates from other interfaces.
	IsFunction_statementContext()
}

type Function_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_statementContext() *Function_statementContext {
	var p = new(Function_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_function_statement
	return p
}

func (*Function_statementContext) IsFunction_statementContext() {}

func NewFunction_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_statementContext {
	var p = new(Function_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_function_statement

	return p
}

func (s *Function_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_statementContext) Statement_star() IStatement_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_starContext)
}

func (s *Function_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterFunction_statement(s)
	}
}

func (s *Function_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitFunction_statement(s)
	}
}

func (p *SysVerilogHDLParser) Function_statement() (localctx IFunction_statementContext) {
	localctx = NewFunction_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, SysVerilogHDLParserRULE_function_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1630)
		p.Statement_star()
	}

	return localctx
}

// IColon_function_identifierContext is an interface to support dynamic dispatch.
type IColon_function_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColon_function_identifierContext differentiates from other interfaces.
	IsColon_function_identifierContext()
}

type Colon_function_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColon_function_identifierContext() *Colon_function_identifierContext {
	var p = new(Colon_function_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_colon_function_identifier
	return p
}

func (*Colon_function_identifierContext) IsColon_function_identifierContext() {}

func NewColon_function_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Colon_function_identifierContext {
	var p = new(Colon_function_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_colon_function_identifier

	return p
}

func (s *Colon_function_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Colon_function_identifierContext) Colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserColon, 0)
}

func (s *Colon_function_identifierContext) Function_identifier() IFunction_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_identifierContext)
}

func (s *Colon_function_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Colon_function_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Colon_function_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterColon_function_identifier(s)
	}
}

func (s *Colon_function_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitColon_function_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Colon_function_identifier() (localctx IColon_function_identifierContext) {
	localctx = NewColon_function_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, SysVerilogHDLParserRULE_colon_function_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1632)
		p.Match(SysVerilogHDLParserColon)
	}
	{
		p.SetState(1633)
		p.Function_identifier()
	}

	return localctx
}

// ITask_declarationContext is an interface to support dynamic dispatch.
type ITask_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_declarationContext differentiates from other interfaces.
	IsTask_declarationContext()
}

type Task_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_declarationContext() *Task_declarationContext {
	var p = new(Task_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_task_declaration
	return p
}

func (*Task_declarationContext) IsTask_declarationContext() {}

func NewTask_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_declarationContext {
	var p = new(Task_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_task_declaration

	return p
}

func (s *Task_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_declarationContext) Task() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTask, 0)
}

func (s *Task_declarationContext) Task_identifier() ITask_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_identifierContext)
}

func (s *Task_declarationContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Task_declarationContext) Task_item_declaration_star() ITask_item_declaration_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_item_declaration_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_item_declaration_starContext)
}

func (s *Task_declarationContext) Task_statement() ITask_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_statementContext)
}

func (s *Task_declarationContext) Endtask() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEndtask, 0)
}

func (s *Task_declarationContext) Automatic() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserAutomatic, 0)
}

func (s *Task_declarationContext) Task_interface() ITask_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_interfaceContext)
}

func (s *Task_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTask_declaration(s)
	}
}

func (s *Task_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTask_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Task_declaration() (localctx ITask_declarationContext) {
	localctx = NewTask_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, SysVerilogHDLParserRULE_task_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1635)
		p.Match(SysVerilogHDLParserTask)
	}
	p.SetState(1637)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserAutomatic {
		{
			p.SetState(1636)
			p.Match(SysVerilogHDLParserAutomatic)
		}

	}
	{
		p.SetState(1639)
		p.Task_identifier()
	}
	p.SetState(1641)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserOpen_parenthesis {
		{
			p.SetState(1640)
			p.Task_interface()
		}

	}
	{
		p.SetState(1643)
		p.Semicolon()
	}
	{
		p.SetState(1644)
		p.Task_item_declaration_star()
	}
	{
		p.SetState(1645)
		p.Task_statement()
	}
	{
		p.SetState(1646)
		p.Match(SysVerilogHDLParserEndtask)
	}

	return localctx
}

// ITask_identifierContext is an interface to support dynamic dispatch.
type ITask_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_identifierContext differentiates from other interfaces.
	IsTask_identifierContext()
}

type Task_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_identifierContext() *Task_identifierContext {
	var p = new(Task_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_task_identifier
	return p
}

func (*Task_identifierContext) IsTask_identifierContext() {}

func NewTask_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_identifierContext {
	var p = new(Task_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_task_identifier

	return p
}

func (s *Task_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Task_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTask_identifier(s)
	}
}

func (s *Task_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTask_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Task_identifier() (localctx ITask_identifierContext) {
	localctx = NewTask_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, SysVerilogHDLParserRULE_task_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1648)
		p.Identifier()
	}

	return localctx
}

// ITask_interfaceContext is an interface to support dynamic dispatch.
type ITask_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_interfaceContext differentiates from other interfaces.
	IsTask_interfaceContext()
}

type Task_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_interfaceContext() *Task_interfaceContext {
	var p = new(Task_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_task_interface
	return p
}

func (*Task_interfaceContext) IsTask_interfaceContext() {}

func NewTask_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_interfaceContext {
	var p = new(Task_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_task_interface

	return p
}

func (s *Task_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_interfaceContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Task_interfaceContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Task_interfaceContext) List_of_tf_interface_ports() IList_of_tf_interface_portsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_tf_interface_portsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_tf_interface_portsContext)
}

func (s *Task_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTask_interface(s)
	}
}

func (s *Task_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTask_interface(s)
	}
}

func (p *SysVerilogHDLParser) Task_interface() (localctx ITask_interfaceContext) {
	localctx = NewTask_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, SysVerilogHDLParserRULE_task_interface)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1650)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	p.SetState(1652)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-55)&-(0x1f+1)) == 0 && ((1<<uint((_la-55)))&((1<<(SysVerilogHDLParserAutomatic-55))|(1<<(SysVerilogHDLParserBit-55))|(1<<(SysVerilogHDLParserByte-55))|(1<<(SysVerilogHDLParserConst-55)))) != 0) || (((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(SysVerilogHDLParserInout-106))|(1<<(SysVerilogHDLParserInput-106))|(1<<(SysVerilogHDLParserInt-106))|(1<<(SysVerilogHDLParserInteger-106))|(1<<(SysVerilogHDLParserLogic-106))|(1<<(SysVerilogHDLParserNONE-106))|(1<<(SysVerilogHDLParserOutput-106)))) != 0) || (((_la-147)&-(0x1f+1)) == 0 && ((1<<uint((_la-147)))&((1<<(SysVerilogHDLParserReal-147))|(1<<(SysVerilogHDLParserRef-147))|(1<<(SysVerilogHDLParserReg-147))|(1<<(SysVerilogHDLParserSigned-147))|(1<<(SysVerilogHDLParserStatic-147))|(1<<(SysVerilogHDLParserSVString-147))|(1<<(SysVerilogHDLParserSupply0-147))|(1<<(SysVerilogHDLParserSupply1-147))|(1<<(SysVerilogHDLParserTime-147)))) != 0) || (((_la-180)&-(0x1f+1)) == 0 && ((1<<uint((_la-180)))&((1<<(SysVerilogHDLParserTri-180))|(1<<(SysVerilogHDLParserTri_and-180))|(1<<(SysVerilogHDLParserTri_or-180))|(1<<(SysVerilogHDLParserTri_reg-180))|(1<<(SysVerilogHDLParserTri0-180))|(1<<(SysVerilogHDLParserTri1-180))|(1<<(SysVerilogHDLParserUnsigned-180))|(1<<(SysVerilogHDLParserUwire-180))|(1<<(SysVerilogHDLParserWand-180))|(1<<(SysVerilogHDLParserWire-180))|(1<<(SysVerilogHDLParserWor-180))|(1<<(SysVerilogHDLParserEscaped_identifier-180))|(1<<(SysVerilogHDLParserSimple_identifier-180)))) != 0) || _la == SysVerilogHDLParserLeft_bracket || _la == SysVerilogHDLParserOpen_parenthesis {
		{
			p.SetState(1651)
			p.List_of_tf_interface_ports()
		}

	}
	{
		p.SetState(1654)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// ITask_item_declaration_semicolonContext is an interface to support dynamic dispatch.
type ITask_item_declaration_semicolonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_item_declaration_semicolonContext differentiates from other interfaces.
	IsTask_item_declaration_semicolonContext()
}

type Task_item_declaration_semicolonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_item_declaration_semicolonContext() *Task_item_declaration_semicolonContext {
	var p = new(Task_item_declaration_semicolonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_task_item_declaration_semicolon
	return p
}

func (*Task_item_declaration_semicolonContext) IsTask_item_declaration_semicolonContext() {}

func NewTask_item_declaration_semicolonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_item_declaration_semicolonContext {
	var p = new(Task_item_declaration_semicolonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_task_item_declaration_semicolon

	return p
}

func (s *Task_item_declaration_semicolonContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_item_declaration_semicolonContext) Task_item_declaration() ITask_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_item_declarationContext)
}

func (s *Task_item_declaration_semicolonContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Task_item_declaration_semicolonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_item_declaration_semicolonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_item_declaration_semicolonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTask_item_declaration_semicolon(s)
	}
}

func (s *Task_item_declaration_semicolonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTask_item_declaration_semicolon(s)
	}
}

func (p *SysVerilogHDLParser) Task_item_declaration_semicolon() (localctx ITask_item_declaration_semicolonContext) {
	localctx = NewTask_item_declaration_semicolonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, SysVerilogHDLParserRULE_task_item_declaration_semicolon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1656)
		p.Task_item_declaration()
	}
	{
		p.SetState(1657)
		p.Semicolon()
	}

	return localctx
}

// ITask_item_declarationContext is an interface to support dynamic dispatch.
type ITask_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_item_declarationContext differentiates from other interfaces.
	IsTask_item_declarationContext()
}

type Task_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_item_declarationContext() *Task_item_declarationContext {
	var p = new(Task_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_task_item_declaration
	return p
}

func (*Task_item_declarationContext) IsTask_item_declarationContext() {}

func NewTask_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_item_declarationContext {
	var p = new(Task_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_task_item_declaration

	return p
}

func (s *Task_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_item_declarationContext) Block_item_declaration() IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Task_item_declarationContext) Port_declaration() IPort_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_declarationContext)
}

func (s *Task_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTask_item_declaration(s)
	}
}

func (s *Task_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTask_item_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Task_item_declaration() (localctx ITask_item_declarationContext) {
	localctx = NewTask_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, SysVerilogHDLParserRULE_task_item_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1661)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserAutomatic, SysVerilogHDLParserBit, SysVerilogHDLParserByte, SysVerilogHDLParserConst, SysVerilogHDLParserEvent_keyword, SysVerilogHDLParserInt, SysVerilogHDLParserInteger, SysVerilogHDLParserLocalparam, SysVerilogHDLParserLogic, SysVerilogHDLParserParameter, SysVerilogHDLParserReal, SysVerilogHDLParserRealtime, SysVerilogHDLParserReg, SysVerilogHDLParserStatic, SysVerilogHDLParserSVString, SysVerilogHDLParserTime, SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1659)
			p.Block_item_declaration()
		}

	case SysVerilogHDLParserInout, SysVerilogHDLParserInput, SysVerilogHDLParserOutput, SysVerilogHDLParserRef:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1660)
			p.Port_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITask_item_declaration_starContext is an interface to support dynamic dispatch.
type ITask_item_declaration_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_item_declaration_starContext differentiates from other interfaces.
	IsTask_item_declaration_starContext()
}

type Task_item_declaration_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_item_declaration_starContext() *Task_item_declaration_starContext {
	var p = new(Task_item_declaration_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_task_item_declaration_star
	return p
}

func (*Task_item_declaration_starContext) IsTask_item_declaration_starContext() {}

func NewTask_item_declaration_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_item_declaration_starContext {
	var p = new(Task_item_declaration_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_task_item_declaration_star

	return p
}

func (s *Task_item_declaration_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_item_declaration_starContext) AllTask_item_declaration_semicolon() []ITask_item_declaration_semicolonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITask_item_declaration_semicolonContext)(nil)).Elem())
	var tst = make([]ITask_item_declaration_semicolonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITask_item_declaration_semicolonContext)
		}
	}

	return tst
}

func (s *Task_item_declaration_starContext) Task_item_declaration_semicolon(i int) ITask_item_declaration_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_item_declaration_semicolonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITask_item_declaration_semicolonContext)
}

func (s *Task_item_declaration_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_item_declaration_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_item_declaration_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTask_item_declaration_star(s)
	}
}

func (s *Task_item_declaration_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTask_item_declaration_star(s)
	}
}

func (p *SysVerilogHDLParser) Task_item_declaration_star() (localctx ITask_item_declaration_starContext) {
	localctx = NewTask_item_declaration_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, SysVerilogHDLParserRULE_task_item_declaration_star)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1666)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1663)
				p.Task_item_declaration_semicolon()
			}

		}
		p.SetState(1668)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext())
	}

	return localctx
}

// ITask_statementContext is an interface to support dynamic dispatch.
type ITask_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_statementContext differentiates from other interfaces.
	IsTask_statementContext()
}

type Task_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_statementContext() *Task_statementContext {
	var p = new(Task_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_task_statement
	return p
}

func (*Task_statementContext) IsTask_statementContext() {}

func NewTask_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_statementContext {
	var p = new(Task_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_task_statement

	return p
}

func (s *Task_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_statementContext) Statement_star() IStatement_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_starContext)
}

func (s *Task_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTask_statement(s)
	}
}

func (s *Task_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTask_statement(s)
	}
}

func (p *SysVerilogHDLParser) Task_statement() (localctx ITask_statementContext) {
	localctx = NewTask_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, SysVerilogHDLParserRULE_task_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1669)
		p.Statement_star()
	}

	return localctx
}

// IStruct_item_semicolonContext is an interface to support dynamic dispatch.
type IStruct_item_semicolonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_item_semicolonContext differentiates from other interfaces.
	IsStruct_item_semicolonContext()
}

type Struct_item_semicolonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_item_semicolonContext() *Struct_item_semicolonContext {
	var p = new(Struct_item_semicolonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_struct_item_semicolon
	return p
}

func (*Struct_item_semicolonContext) IsStruct_item_semicolonContext() {}

func NewStruct_item_semicolonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_item_semicolonContext {
	var p = new(Struct_item_semicolonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_struct_item_semicolon

	return p
}

func (s *Struct_item_semicolonContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_item_semicolonContext) Struct_item() IStruct_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_itemContext)
}

func (s *Struct_item_semicolonContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Struct_item_semicolonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_item_semicolonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_item_semicolonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterStruct_item_semicolon(s)
	}
}

func (s *Struct_item_semicolonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitStruct_item_semicolon(s)
	}
}

func (p *SysVerilogHDLParser) Struct_item_semicolon() (localctx IStruct_item_semicolonContext) {
	localctx = NewStruct_item_semicolonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, SysVerilogHDLParserRULE_struct_item_semicolon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1671)
		p.Struct_item()
	}
	{
		p.SetState(1672)
		p.Semicolon()
	}

	return localctx
}

// IStruct_item_starContext is an interface to support dynamic dispatch.
type IStruct_item_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_item_starContext differentiates from other interfaces.
	IsStruct_item_starContext()
}

type Struct_item_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_item_starContext() *Struct_item_starContext {
	var p = new(Struct_item_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_struct_item_star
	return p
}

func (*Struct_item_starContext) IsStruct_item_starContext() {}

func NewStruct_item_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_item_starContext {
	var p = new(Struct_item_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_struct_item_star

	return p
}

func (s *Struct_item_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_item_starContext) AllStruct_item_semicolon() []IStruct_item_semicolonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStruct_item_semicolonContext)(nil)).Elem())
	var tst = make([]IStruct_item_semicolonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStruct_item_semicolonContext)
		}
	}

	return tst
}

func (s *Struct_item_starContext) Struct_item_semicolon(i int) IStruct_item_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_item_semicolonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStruct_item_semicolonContext)
}

func (s *Struct_item_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_item_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_item_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterStruct_item_star(s)
	}
}

func (s *Struct_item_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitStruct_item_star(s)
	}
}

func (p *SysVerilogHDLParser) Struct_item_star() (localctx IStruct_item_starContext) {
	localctx = NewStruct_item_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, SysVerilogHDLParserRULE_struct_item_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1677)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-55)&-(0x1f+1)) == 0 && ((1<<uint((_la-55)))&((1<<(SysVerilogHDLParserAutomatic-55))|(1<<(SysVerilogHDLParserBit-55))|(1<<(SysVerilogHDLParserByte-55))|(1<<(SysVerilogHDLParserConst-55)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SysVerilogHDLParserInt-109))|(1<<(SysVerilogHDLParserInteger-109))|(1<<(SysVerilogHDLParserLogic-109)))) != 0) || _la == SysVerilogHDLParserStatic || _la == SysVerilogHDLParserTime || _la == SysVerilogHDLParserEscaped_identifier || _la == SysVerilogHDLParserSimple_identifier {
		{
			p.SetState(1674)
			p.Struct_item_semicolon()
		}

		p.SetState(1679)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStruct_itemContext is an interface to support dynamic dispatch.
type IStruct_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_itemContext differentiates from other interfaces.
	IsStruct_itemContext()
}

type Struct_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_itemContext() *Struct_itemContext {
	var p = new(Struct_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_struct_item
	return p
}

func (*Struct_itemContext) IsStruct_itemContext() {}

func NewStruct_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_itemContext {
	var p = new(Struct_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_struct_item

	return p
}

func (s *Struct_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_itemContext) Logic_declaration() ILogic_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogic_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogic_declarationContext)
}

func (s *Struct_itemContext) Bits_declaration() IBits_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBits_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBits_declarationContext)
}

func (s *Struct_itemContext) Int_declaration() IInt_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_declarationContext)
}

func (s *Struct_itemContext) Integer_declaration() IInteger_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_declarationContext)
}

func (s *Struct_itemContext) Usertype_variable_declaration() IUsertype_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUsertype_variable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUsertype_variable_declarationContext)
}

func (s *Struct_itemContext) Time_declaration() ITime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITime_declarationContext)
}

func (s *Struct_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterStruct_item(s)
	}
}

func (s *Struct_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitStruct_item(s)
	}
}

func (p *SysVerilogHDLParser) Struct_item() (localctx IStruct_itemContext) {
	localctx = NewStruct_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, SysVerilogHDLParserRULE_struct_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1686)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1680)
			p.Logic_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1681)
			p.Bits_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1682)
			p.Int_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1683)
			p.Integer_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1684)
			p.Usertype_variable_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1685)
			p.Time_declaration()
		}

	}

	return localctx
}

// IStruct_typeContext is an interface to support dynamic dispatch.
type IStruct_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_typeContext differentiates from other interfaces.
	IsStruct_typeContext()
}

type Struct_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_typeContext() *Struct_typeContext {
	var p = new(Struct_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_struct_type
	return p
}

func (*Struct_typeContext) IsStruct_typeContext() {}

func NewStruct_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_typeContext {
	var p = new(Struct_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_struct_type

	return p
}

func (s *Struct_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_typeContext) Struct_keyword() IStruct_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_keywordContext)
}

func (s *Struct_typeContext) Left_curly_bracket() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserLeft_curly_bracket, 0)
}

func (s *Struct_typeContext) Struct_item_star() IStruct_item_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_item_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_item_starContext)
}

func (s *Struct_typeContext) Right_curly_bracket() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRight_curly_bracket, 0)
}

func (s *Struct_typeContext) Packed() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserPacked, 0)
}

func (s *Struct_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterStruct_type(s)
	}
}

func (s *Struct_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitStruct_type(s)
	}
}

func (p *SysVerilogHDLParser) Struct_type() (localctx IStruct_typeContext) {
	localctx = NewStruct_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, SysVerilogHDLParserRULE_struct_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1688)
		p.Struct_keyword()
	}
	p.SetState(1690)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserPacked {
		{
			p.SetState(1689)
			p.Match(SysVerilogHDLParserPacked)
		}

	}
	{
		p.SetState(1692)
		p.Match(SysVerilogHDLParserLeft_curly_bracket)
	}
	{
		p.SetState(1693)
		p.Struct_item_star()
	}
	{
		p.SetState(1694)
		p.Match(SysVerilogHDLParserRight_curly_bracket)
	}

	return localctx
}

// IEnum_typeContext is an interface to support dynamic dispatch.
type IEnum_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_typeContext differentiates from other interfaces.
	IsEnum_typeContext()
}

type Enum_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_typeContext() *Enum_typeContext {
	var p = new(Enum_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_enum_type
	return p
}

func (*Enum_typeContext) IsEnum_typeContext() {}

func NewEnum_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_typeContext {
	var p = new(Enum_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_enum_type

	return p
}

func (s *Enum_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_typeContext) Integer() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserInteger, 0)
}

func (s *Enum_typeContext) Logic() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserLogic, 0)
}

func (s *Enum_typeContext) Bits_type() IBits_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBits_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBits_typeContext)
}

func (s *Enum_typeContext) Int() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserInt, 0)
}

func (s *Enum_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEnum_type(s)
	}
}

func (s *Enum_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEnum_type(s)
	}
}

func (p *SysVerilogHDLParser) Enum_type() (localctx IEnum_typeContext) {
	localctx = NewEnum_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, SysVerilogHDLParserRULE_enum_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1700)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserInteger:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1696)
			p.Match(SysVerilogHDLParserInteger)
		}

	case SysVerilogHDLParserLogic:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1697)
			p.Match(SysVerilogHDLParserLogic)
		}

	case SysVerilogHDLParserBit, SysVerilogHDLParserByte:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1698)
			p.Bits_type()
		}

	case SysVerilogHDLParserInt:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1699)
			p.Match(SysVerilogHDLParserInt)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_of_enum_itemsContext is an interface to support dynamic dispatch.
type IList_of_enum_itemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_enum_itemsContext differentiates from other interfaces.
	IsList_of_enum_itemsContext()
}

type List_of_enum_itemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_enum_itemsContext() *List_of_enum_itemsContext {
	var p = new(List_of_enum_itemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_enum_items
	return p
}

func (*List_of_enum_itemsContext) IsList_of_enum_itemsContext() {}

func NewList_of_enum_itemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_enum_itemsContext {
	var p = new(List_of_enum_itemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_enum_items

	return p
}

func (s *List_of_enum_itemsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_enum_itemsContext) Enum_item() IEnum_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_itemContext)
}

func (s *List_of_enum_itemsContext) Comma_enum_item_star() IComma_enum_item_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_enum_item_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_enum_item_starContext)
}

func (s *List_of_enum_itemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_enum_itemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_enum_itemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_enum_items(s)
	}
}

func (s *List_of_enum_itemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_enum_items(s)
	}
}

func (p *SysVerilogHDLParser) List_of_enum_items() (localctx IList_of_enum_itemsContext) {
	localctx = NewList_of_enum_itemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, SysVerilogHDLParserRULE_list_of_enum_items)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1702)
		p.Enum_item()
	}
	{
		p.SetState(1703)
		p.Comma_enum_item_star()
	}

	return localctx
}

// IEnum_itemContext is an interface to support dynamic dispatch.
type IEnum_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_itemContext differentiates from other interfaces.
	IsEnum_itemContext()
}

type Enum_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_itemContext() *Enum_itemContext {
	var p = new(Enum_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_enum_item
	return p
}

func (*Enum_itemContext) IsEnum_itemContext() {}

func NewEnum_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_itemContext {
	var p = new(Enum_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_enum_item

	return p
}

func (s *Enum_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_itemContext) Enum_identifier() IEnum_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_identifierContext)
}

func (s *Enum_itemContext) Equal() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEqual, 0)
}

func (s *Enum_itemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Enum_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEnum_item(s)
	}
}

func (s *Enum_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEnum_item(s)
	}
}

func (p *SysVerilogHDLParser) Enum_item() (localctx IEnum_itemContext) {
	localctx = NewEnum_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, SysVerilogHDLParserRULE_enum_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1710)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1705)
			p.Enum_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1706)
			p.Enum_identifier()
		}
		{
			p.SetState(1707)
			p.Match(SysVerilogHDLParserEqual)
		}
		{
			p.SetState(1708)
			p.Expression()
		}

	}

	return localctx
}

// IEnum_identifierContext is an interface to support dynamic dispatch.
type IEnum_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_identifierContext differentiates from other interfaces.
	IsEnum_identifierContext()
}

type Enum_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_identifierContext() *Enum_identifierContext {
	var p = new(Enum_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_enum_identifier
	return p
}

func (*Enum_identifierContext) IsEnum_identifierContext() {}

func NewEnum_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_identifierContext {
	var p = new(Enum_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_enum_identifier

	return p
}

func (s *Enum_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Enum_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEnum_identifier(s)
	}
}

func (s *Enum_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEnum_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Enum_identifier() (localctx IEnum_identifierContext) {
	localctx = NewEnum_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, SysVerilogHDLParserRULE_enum_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1712)
		p.Identifier()
	}

	return localctx
}

// IComma_enum_item_starContext is an interface to support dynamic dispatch.
type IComma_enum_item_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_enum_item_starContext differentiates from other interfaces.
	IsComma_enum_item_starContext()
}

type Comma_enum_item_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_enum_item_starContext() *Comma_enum_item_starContext {
	var p = new(Comma_enum_item_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_enum_item_star
	return p
}

func (*Comma_enum_item_starContext) IsComma_enum_item_starContext() {}

func NewComma_enum_item_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_enum_item_starContext {
	var p = new(Comma_enum_item_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_enum_item_star

	return p
}

func (s *Comma_enum_item_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_enum_item_starContext) AllComma_enum_item() []IComma_enum_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_enum_itemContext)(nil)).Elem())
	var tst = make([]IComma_enum_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_enum_itemContext)
		}
	}

	return tst
}

func (s *Comma_enum_item_starContext) Comma_enum_item(i int) IComma_enum_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_enum_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_enum_itemContext)
}

func (s *Comma_enum_item_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_enum_item_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_enum_item_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_enum_item_star(s)
	}
}

func (s *Comma_enum_item_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_enum_item_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_enum_item_star() (localctx IComma_enum_item_starContext) {
	localctx = NewComma_enum_item_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, SysVerilogHDLParserRULE_comma_enum_item_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1717)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(1714)
			p.Comma_enum_item()
		}

		p.SetState(1719)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_enum_itemContext is an interface to support dynamic dispatch.
type IComma_enum_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_enum_itemContext differentiates from other interfaces.
	IsComma_enum_itemContext()
}

type Comma_enum_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_enum_itemContext() *Comma_enum_itemContext {
	var p = new(Comma_enum_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_enum_item
	return p
}

func (*Comma_enum_itemContext) IsComma_enum_itemContext() {}

func NewComma_enum_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_enum_itemContext {
	var p = new(Comma_enum_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_enum_item

	return p
}

func (s *Comma_enum_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_enum_itemContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_enum_itemContext) Enum_item() IEnum_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_itemContext)
}

func (s *Comma_enum_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_enum_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_enum_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_enum_item(s)
	}
}

func (s *Comma_enum_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_enum_item(s)
	}
}

func (p *SysVerilogHDLParser) Comma_enum_item() (localctx IComma_enum_itemContext) {
	localctx = NewComma_enum_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, SysVerilogHDLParserRULE_comma_enum_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1720)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(1721)
		p.Enum_item()
	}

	return localctx
}

// IEnumerated_typeContext is an interface to support dynamic dispatch.
type IEnumerated_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerated_typeContext differentiates from other interfaces.
	IsEnumerated_typeContext()
}

type Enumerated_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerated_typeContext() *Enumerated_typeContext {
	var p = new(Enumerated_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_enumerated_type
	return p
}

func (*Enumerated_typeContext) IsEnumerated_typeContext() {}

func NewEnumerated_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enumerated_typeContext {
	var p = new(Enumerated_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_enumerated_type

	return p
}

func (s *Enumerated_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Enumerated_typeContext) Enum() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEnum, 0)
}

func (s *Enumerated_typeContext) Left_curly_bracket() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserLeft_curly_bracket, 0)
}

func (s *Enumerated_typeContext) List_of_enum_items() IList_of_enum_itemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_enum_itemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_enum_itemsContext)
}

func (s *Enumerated_typeContext) Right_curly_bracket() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRight_curly_bracket, 0)
}

func (s *Enumerated_typeContext) Enum_type() IEnum_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_typeContext)
}

func (s *Enumerated_typeContext) Dimension() IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Enumerated_typeContext) Signed() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSigned, 0)
}

func (s *Enumerated_typeContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserUnsigned, 0)
}

func (s *Enumerated_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enumerated_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enumerated_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEnumerated_type(s)
	}
}

func (s *Enumerated_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEnumerated_type(s)
	}
}

func (p *SysVerilogHDLParser) Enumerated_type() (localctx IEnumerated_typeContext) {
	localctx = NewEnumerated_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, SysVerilogHDLParserRULE_enumerated_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1723)
		p.Match(SysVerilogHDLParserEnum)
	}
	p.SetState(1725)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserBit || _la == SysVerilogHDLParserByte || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SysVerilogHDLParserInt-109))|(1<<(SysVerilogHDLParserInteger-109))|(1<<(SysVerilogHDLParserLogic-109)))) != 0) {
		{
			p.SetState(1724)
			p.Enum_type()
		}

	}
	p.SetState(1728)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned {
		{
			p.SetState(1727)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1731)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserLeft_bracket {
		{
			p.SetState(1730)
			p.Dimension()
		}

	}
	{
		p.SetState(1733)
		p.Match(SysVerilogHDLParserLeft_curly_bracket)
	}
	{
		p.SetState(1734)
		p.List_of_enum_items()
	}
	{
		p.SetState(1735)
		p.Match(SysVerilogHDLParserRight_curly_bracket)
	}

	return localctx
}

// IModule_instantiationContext is an interface to support dynamic dispatch.
type IModule_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_instantiationContext differentiates from other interfaces.
	IsModule_instantiationContext()
}

type Module_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_instantiationContext() *Module_instantiationContext {
	var p = new(Module_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_module_instantiation
	return p
}

func (*Module_instantiationContext) IsModule_instantiationContext() {}

func NewModule_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_instantiationContext {
	var p = new(Module_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_module_instantiation

	return p
}

func (s *Module_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_instantiationContext) Module_identifier() IModule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_identifierContext)
}

func (s *Module_instantiationContext) List_of_module_instances() IList_of_module_instancesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_module_instancesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_module_instancesContext)
}

func (s *Module_instantiationContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Module_instantiationContext) Parameter_interface_assignments() IParameter_interface_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_interface_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_interface_assignmentsContext)
}

func (s *Module_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterModule_instantiation(s)
	}
}

func (s *Module_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitModule_instantiation(s)
	}
}

func (p *SysVerilogHDLParser) Module_instantiation() (localctx IModule_instantiationContext) {
	localctx = NewModule_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, SysVerilogHDLParserRULE_module_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1737)
		p.Module_identifier()
	}
	p.SetState(1739)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserHash {
		{
			p.SetState(1738)
			p.Parameter_interface_assignments()
		}

	}
	{
		p.SetState(1741)
		p.List_of_module_instances()
	}
	{
		p.SetState(1742)
		p.Semicolon()
	}

	return localctx
}

// IParameter_interface_assignmentsContext is an interface to support dynamic dispatch.
type IParameter_interface_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_interface_assignmentsContext differentiates from other interfaces.
	IsParameter_interface_assignmentsContext()
}

type Parameter_interface_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_interface_assignmentsContext() *Parameter_interface_assignmentsContext {
	var p = new(Parameter_interface_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_parameter_interface_assignments
	return p
}

func (*Parameter_interface_assignmentsContext) IsParameter_interface_assignmentsContext() {}

func NewParameter_interface_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_interface_assignmentsContext {
	var p = new(Parameter_interface_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_parameter_interface_assignments

	return p
}

func (s *Parameter_interface_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_interface_assignmentsContext) Hash() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserHash, 0)
}

func (s *Parameter_interface_assignmentsContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Parameter_interface_assignmentsContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Parameter_interface_assignmentsContext) List_of_interface_assignments() IList_of_interface_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_interface_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_interface_assignmentsContext)
}

func (s *Parameter_interface_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_interface_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_interface_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterParameter_interface_assignments(s)
	}
}

func (s *Parameter_interface_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitParameter_interface_assignments(s)
	}
}

func (p *SysVerilogHDLParser) Parameter_interface_assignments() (localctx IParameter_interface_assignmentsContext) {
	localctx = NewParameter_interface_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, SysVerilogHDLParserRULE_parameter_interface_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1744)
		p.Match(SysVerilogHDLParserHash)
	}
	{
		p.SetState(1745)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	p.SetState(1747)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SysVerilogHDLParserT__1)|(1<<SysVerilogHDLParserT__2)|(1<<SysVerilogHDLParserT__3)|(1<<SysVerilogHDLParserT__4)|(1<<SysVerilogHDLParserT__5)|(1<<SysVerilogHDLParserT__6)|(1<<SysVerilogHDLParserT__7)|(1<<SysVerilogHDLParserT__8)|(1<<SysVerilogHDLParserT__9)|(1<<SysVerilogHDLParserT__10)|(1<<SysVerilogHDLParserT__26)|(1<<SysVerilogHDLParserT__27))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(SysVerilogHDLParserBinary_number-42))|(1<<(SysVerilogHDLParserDecimal_number-42))|(1<<(SysVerilogHDLParserFixed_point_number-42))|(1<<(SysVerilogHDLParserHex_number-42))|(1<<(SysVerilogHDLParserOctal_number-42))|(1<<(SysVerilogHDLParserReal_exp_form-42)))) != 0) || _la == SysVerilogHDLParserInt || _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned || (((_la-201)&-(0x1f+1)) == 0 && ((1<<uint((_la-201)))&((1<<(SysVerilogHDLParserDollar_Identifier-201))|(1<<(SysVerilogHDLParserEscaped_identifier-201))|(1<<(SysVerilogHDLParserSimple_identifier-201))|(1<<(SysVerilogHDLParserString_literal-201))|(1<<(SysVerilogHDLParserDot-201))|(1<<(SysVerilogHDLParserLeft_curly_bracket-201))|(1<<(SysVerilogHDLParserOpen_parenthesis-201))|(1<<(SysVerilogHDLParserQuote-201))|(1<<(SysVerilogHDLParserTilde-201)))) != 0) {
		{
			p.SetState(1746)
			p.List_of_interface_assignments()
		}

	}
	{
		p.SetState(1749)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// IList_of_interface_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_interface_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_interface_assignmentsContext differentiates from other interfaces.
	IsList_of_interface_assignmentsContext()
}

type List_of_interface_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_interface_assignmentsContext() *List_of_interface_assignmentsContext {
	var p = new(List_of_interface_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_interface_assignments
	return p
}

func (*List_of_interface_assignmentsContext) IsList_of_interface_assignmentsContext() {}

func NewList_of_interface_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_interface_assignmentsContext {
	var p = new(List_of_interface_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_interface_assignments

	return p
}

func (s *List_of_interface_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_interface_assignmentsContext) List_of_ordered_interface_assignments() IList_of_ordered_interface_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_ordered_interface_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_ordered_interface_assignmentsContext)
}

func (s *List_of_interface_assignmentsContext) List_of_named_interface_assignments() IList_of_named_interface_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_named_interface_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_named_interface_assignmentsContext)
}

func (s *List_of_interface_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_interface_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_interface_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_interface_assignments(s)
	}
}

func (s *List_of_interface_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_interface_assignments(s)
	}
}

func (p *SysVerilogHDLParser) List_of_interface_assignments() (localctx IList_of_interface_assignmentsContext) {
	localctx = NewList_of_interface_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, SysVerilogHDLParserRULE_list_of_interface_assignments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1753)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserT__1, SysVerilogHDLParserT__2, SysVerilogHDLParserT__3, SysVerilogHDLParserT__4, SysVerilogHDLParserT__5, SysVerilogHDLParserT__6, SysVerilogHDLParserT__7, SysVerilogHDLParserT__8, SysVerilogHDLParserT__9, SysVerilogHDLParserT__10, SysVerilogHDLParserT__26, SysVerilogHDLParserT__27, SysVerilogHDLParserBinary_number, SysVerilogHDLParserDecimal_number, SysVerilogHDLParserFixed_point_number, SysVerilogHDLParserHex_number, SysVerilogHDLParserOctal_number, SysVerilogHDLParserReal_exp_form, SysVerilogHDLParserInt, SysVerilogHDLParserSigned, SysVerilogHDLParserUnsigned, SysVerilogHDLParserDollar_Identifier, SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier, SysVerilogHDLParserString_literal, SysVerilogHDLParserLeft_curly_bracket, SysVerilogHDLParserOpen_parenthesis, SysVerilogHDLParserQuote, SysVerilogHDLParserTilde:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1751)
			p.List_of_ordered_interface_assignments()
		}

	case SysVerilogHDLParserDot:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1752)
			p.List_of_named_interface_assignments()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_of_ordered_interface_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_ordered_interface_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_ordered_interface_assignmentsContext differentiates from other interfaces.
	IsList_of_ordered_interface_assignmentsContext()
}

type List_of_ordered_interface_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_ordered_interface_assignmentsContext() *List_of_ordered_interface_assignmentsContext {
	var p = new(List_of_ordered_interface_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_ordered_interface_assignments
	return p
}

func (*List_of_ordered_interface_assignmentsContext) IsList_of_ordered_interface_assignmentsContext() {
}

func NewList_of_ordered_interface_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_ordered_interface_assignmentsContext {
	var p = new(List_of_ordered_interface_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_ordered_interface_assignments

	return p
}

func (s *List_of_ordered_interface_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_ordered_interface_assignmentsContext) Ordered_interface_assignment() IOrdered_interface_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrdered_interface_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrdered_interface_assignmentContext)
}

func (s *List_of_ordered_interface_assignmentsContext) Comma_ordered_interface_assignment_star() IComma_ordered_interface_assignment_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_ordered_interface_assignment_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_ordered_interface_assignment_starContext)
}

func (s *List_of_ordered_interface_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_ordered_interface_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_ordered_interface_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_ordered_interface_assignments(s)
	}
}

func (s *List_of_ordered_interface_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_ordered_interface_assignments(s)
	}
}

func (p *SysVerilogHDLParser) List_of_ordered_interface_assignments() (localctx IList_of_ordered_interface_assignmentsContext) {
	localctx = NewList_of_ordered_interface_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, SysVerilogHDLParserRULE_list_of_ordered_interface_assignments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1755)
		p.Ordered_interface_assignment()
	}
	{
		p.SetState(1756)
		p.Comma_ordered_interface_assignment_star()
	}

	return localctx
}

// IComma_ordered_interface_assignment_starContext is an interface to support dynamic dispatch.
type IComma_ordered_interface_assignment_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_ordered_interface_assignment_starContext differentiates from other interfaces.
	IsComma_ordered_interface_assignment_starContext()
}

type Comma_ordered_interface_assignment_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_ordered_interface_assignment_starContext() *Comma_ordered_interface_assignment_starContext {
	var p = new(Comma_ordered_interface_assignment_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_ordered_interface_assignment_star
	return p
}

func (*Comma_ordered_interface_assignment_starContext) IsComma_ordered_interface_assignment_starContext() {
}

func NewComma_ordered_interface_assignment_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_ordered_interface_assignment_starContext {
	var p = new(Comma_ordered_interface_assignment_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_ordered_interface_assignment_star

	return p
}

func (s *Comma_ordered_interface_assignment_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_ordered_interface_assignment_starContext) AllComma_ordered_interface_assignment() []IComma_ordered_interface_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_ordered_interface_assignmentContext)(nil)).Elem())
	var tst = make([]IComma_ordered_interface_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_ordered_interface_assignmentContext)
		}
	}

	return tst
}

func (s *Comma_ordered_interface_assignment_starContext) Comma_ordered_interface_assignment(i int) IComma_ordered_interface_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_ordered_interface_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_ordered_interface_assignmentContext)
}

func (s *Comma_ordered_interface_assignment_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_ordered_interface_assignment_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_ordered_interface_assignment_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_ordered_interface_assignment_star(s)
	}
}

func (s *Comma_ordered_interface_assignment_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_ordered_interface_assignment_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_ordered_interface_assignment_star() (localctx IComma_ordered_interface_assignment_starContext) {
	localctx = NewComma_ordered_interface_assignment_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, SysVerilogHDLParserRULE_comma_ordered_interface_assignment_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1761)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(1758)
			p.Comma_ordered_interface_assignment()
		}

		p.SetState(1763)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_ordered_interface_assignmentContext is an interface to support dynamic dispatch.
type IComma_ordered_interface_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_ordered_interface_assignmentContext differentiates from other interfaces.
	IsComma_ordered_interface_assignmentContext()
}

type Comma_ordered_interface_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_ordered_interface_assignmentContext() *Comma_ordered_interface_assignmentContext {
	var p = new(Comma_ordered_interface_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_ordered_interface_assignment
	return p
}

func (*Comma_ordered_interface_assignmentContext) IsComma_ordered_interface_assignmentContext() {}

func NewComma_ordered_interface_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_ordered_interface_assignmentContext {
	var p = new(Comma_ordered_interface_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_ordered_interface_assignment

	return p
}

func (s *Comma_ordered_interface_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_ordered_interface_assignmentContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_ordered_interface_assignmentContext) Ordered_interface_assignment() IOrdered_interface_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrdered_interface_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrdered_interface_assignmentContext)
}

func (s *Comma_ordered_interface_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_ordered_interface_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_ordered_interface_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_ordered_interface_assignment(s)
	}
}

func (s *Comma_ordered_interface_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_ordered_interface_assignment(s)
	}
}

func (p *SysVerilogHDLParser) Comma_ordered_interface_assignment() (localctx IComma_ordered_interface_assignmentContext) {
	localctx = NewComma_ordered_interface_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, SysVerilogHDLParserRULE_comma_ordered_interface_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1764)
		p.Match(SysVerilogHDLParserComma)
	}
	p.SetState(1766)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SysVerilogHDLParserT__1)|(1<<SysVerilogHDLParserT__2)|(1<<SysVerilogHDLParserT__3)|(1<<SysVerilogHDLParserT__4)|(1<<SysVerilogHDLParserT__5)|(1<<SysVerilogHDLParserT__6)|(1<<SysVerilogHDLParserT__7)|(1<<SysVerilogHDLParserT__8)|(1<<SysVerilogHDLParserT__9)|(1<<SysVerilogHDLParserT__10)|(1<<SysVerilogHDLParserT__26)|(1<<SysVerilogHDLParserT__27))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(SysVerilogHDLParserBinary_number-42))|(1<<(SysVerilogHDLParserDecimal_number-42))|(1<<(SysVerilogHDLParserFixed_point_number-42))|(1<<(SysVerilogHDLParserHex_number-42))|(1<<(SysVerilogHDLParserOctal_number-42))|(1<<(SysVerilogHDLParserReal_exp_form-42)))) != 0) || _la == SysVerilogHDLParserInt || _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned || (((_la-201)&-(0x1f+1)) == 0 && ((1<<uint((_la-201)))&((1<<(SysVerilogHDLParserDollar_Identifier-201))|(1<<(SysVerilogHDLParserEscaped_identifier-201))|(1<<(SysVerilogHDLParserSimple_identifier-201))|(1<<(SysVerilogHDLParserString_literal-201))|(1<<(SysVerilogHDLParserLeft_curly_bracket-201))|(1<<(SysVerilogHDLParserOpen_parenthesis-201))|(1<<(SysVerilogHDLParserQuote-201))|(1<<(SysVerilogHDLParserTilde-201)))) != 0) {
		{
			p.SetState(1765)
			p.Ordered_interface_assignment()
		}

	}

	return localctx
}

// IOrdered_interface_assignmentContext is an interface to support dynamic dispatch.
type IOrdered_interface_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrdered_interface_assignmentContext differentiates from other interfaces.
	IsOrdered_interface_assignmentContext()
}

type Ordered_interface_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdered_interface_assignmentContext() *Ordered_interface_assignmentContext {
	var p = new(Ordered_interface_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_ordered_interface_assignment
	return p
}

func (*Ordered_interface_assignmentContext) IsOrdered_interface_assignmentContext() {}

func NewOrdered_interface_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordered_interface_assignmentContext {
	var p = new(Ordered_interface_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_ordered_interface_assignment

	return p
}

func (s *Ordered_interface_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordered_interface_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Ordered_interface_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordered_interface_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ordered_interface_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterOrdered_interface_assignment(s)
	}
}

func (s *Ordered_interface_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitOrdered_interface_assignment(s)
	}
}

func (p *SysVerilogHDLParser) Ordered_interface_assignment() (localctx IOrdered_interface_assignmentContext) {
	localctx = NewOrdered_interface_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, SysVerilogHDLParserRULE_ordered_interface_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1768)
		p.Expression()
	}

	return localctx
}

// IList_of_named_interface_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_named_interface_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_named_interface_assignmentsContext differentiates from other interfaces.
	IsList_of_named_interface_assignmentsContext()
}

type List_of_named_interface_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_named_interface_assignmentsContext() *List_of_named_interface_assignmentsContext {
	var p = new(List_of_named_interface_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_named_interface_assignments
	return p
}

func (*List_of_named_interface_assignmentsContext) IsList_of_named_interface_assignmentsContext() {}

func NewList_of_named_interface_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_named_interface_assignmentsContext {
	var p = new(List_of_named_interface_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_named_interface_assignments

	return p
}

func (s *List_of_named_interface_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_named_interface_assignmentsContext) Named_interface_assignment() INamed_interface_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamed_interface_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamed_interface_assignmentContext)
}

func (s *List_of_named_interface_assignmentsContext) Comma_named_interface_assignment_star() IComma_named_interface_assignment_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_named_interface_assignment_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_named_interface_assignment_starContext)
}

func (s *List_of_named_interface_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_named_interface_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_named_interface_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_named_interface_assignments(s)
	}
}

func (s *List_of_named_interface_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_named_interface_assignments(s)
	}
}

func (p *SysVerilogHDLParser) List_of_named_interface_assignments() (localctx IList_of_named_interface_assignmentsContext) {
	localctx = NewList_of_named_interface_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, SysVerilogHDLParserRULE_list_of_named_interface_assignments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1770)
		p.Named_interface_assignment()
	}
	{
		p.SetState(1771)
		p.Comma_named_interface_assignment_star()
	}

	return localctx
}

// IComma_named_interface_assignment_starContext is an interface to support dynamic dispatch.
type IComma_named_interface_assignment_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_named_interface_assignment_starContext differentiates from other interfaces.
	IsComma_named_interface_assignment_starContext()
}

type Comma_named_interface_assignment_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_named_interface_assignment_starContext() *Comma_named_interface_assignment_starContext {
	var p = new(Comma_named_interface_assignment_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_named_interface_assignment_star
	return p
}

func (*Comma_named_interface_assignment_starContext) IsComma_named_interface_assignment_starContext() {
}

func NewComma_named_interface_assignment_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_named_interface_assignment_starContext {
	var p = new(Comma_named_interface_assignment_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_named_interface_assignment_star

	return p
}

func (s *Comma_named_interface_assignment_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_named_interface_assignment_starContext) AllComma_named_interface_assignment() []IComma_named_interface_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_named_interface_assignmentContext)(nil)).Elem())
	var tst = make([]IComma_named_interface_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_named_interface_assignmentContext)
		}
	}

	return tst
}

func (s *Comma_named_interface_assignment_starContext) Comma_named_interface_assignment(i int) IComma_named_interface_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_named_interface_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_named_interface_assignmentContext)
}

func (s *Comma_named_interface_assignment_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_named_interface_assignment_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_named_interface_assignment_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_named_interface_assignment_star(s)
	}
}

func (s *Comma_named_interface_assignment_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_named_interface_assignment_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_named_interface_assignment_star() (localctx IComma_named_interface_assignment_starContext) {
	localctx = NewComma_named_interface_assignment_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, SysVerilogHDLParserRULE_comma_named_interface_assignment_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1776)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(1773)
			p.Comma_named_interface_assignment()
		}

		p.SetState(1778)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_named_interface_assignmentContext is an interface to support dynamic dispatch.
type IComma_named_interface_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_named_interface_assignmentContext differentiates from other interfaces.
	IsComma_named_interface_assignmentContext()
}

type Comma_named_interface_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_named_interface_assignmentContext() *Comma_named_interface_assignmentContext {
	var p = new(Comma_named_interface_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_named_interface_assignment
	return p
}

func (*Comma_named_interface_assignmentContext) IsComma_named_interface_assignmentContext() {}

func NewComma_named_interface_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_named_interface_assignmentContext {
	var p = new(Comma_named_interface_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_named_interface_assignment

	return p
}

func (s *Comma_named_interface_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_named_interface_assignmentContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_named_interface_assignmentContext) Named_interface_assignment() INamed_interface_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamed_interface_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamed_interface_assignmentContext)
}

func (s *Comma_named_interface_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_named_interface_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_named_interface_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_named_interface_assignment(s)
	}
}

func (s *Comma_named_interface_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_named_interface_assignment(s)
	}
}

func (p *SysVerilogHDLParser) Comma_named_interface_assignment() (localctx IComma_named_interface_assignmentContext) {
	localctx = NewComma_named_interface_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, SysVerilogHDLParserRULE_comma_named_interface_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1779)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(1780)
		p.Named_interface_assignment()
	}

	return localctx
}

// INamed_interface_assignmentContext is an interface to support dynamic dispatch.
type INamed_interface_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamed_interface_assignmentContext differentiates from other interfaces.
	IsNamed_interface_assignmentContext()
}

type Named_interface_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_interface_assignmentContext() *Named_interface_assignmentContext {
	var p = new(Named_interface_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_named_interface_assignment
	return p
}

func (*Named_interface_assignmentContext) IsNamed_interface_assignmentContext() {}

func NewNamed_interface_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_interface_assignmentContext {
	var p = new(Named_interface_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_named_interface_assignment

	return p
}

func (s *Named_interface_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_interface_assignmentContext) Dot() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDot, 0)
}

func (s *Named_interface_assignmentContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Named_interface_assignmentContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Named_interface_assignmentContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Named_interface_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Named_interface_assignmentContext) Star() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserStar, 0)
}

func (s *Named_interface_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_interface_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_interface_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterNamed_interface_assignment(s)
	}
}

func (s *Named_interface_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitNamed_interface_assignment(s)
	}
}

func (p *SysVerilogHDLParser) Named_interface_assignment() (localctx INamed_interface_assignmentContext) {
	localctx = NewNamed_interface_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, SysVerilogHDLParserRULE_named_interface_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1793)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1782)
			p.Match(SysVerilogHDLParserDot)
		}
		{
			p.SetState(1783)
			p.Identifier()
		}
		p.SetState(1789)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SysVerilogHDLParserOpen_parenthesis {
			{
				p.SetState(1784)
				p.Match(SysVerilogHDLParserOpen_parenthesis)
			}
			p.SetState(1786)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SysVerilogHDLParserT__1)|(1<<SysVerilogHDLParserT__2)|(1<<SysVerilogHDLParserT__3)|(1<<SysVerilogHDLParserT__4)|(1<<SysVerilogHDLParserT__5)|(1<<SysVerilogHDLParserT__6)|(1<<SysVerilogHDLParserT__7)|(1<<SysVerilogHDLParserT__8)|(1<<SysVerilogHDLParserT__9)|(1<<SysVerilogHDLParserT__10)|(1<<SysVerilogHDLParserT__26)|(1<<SysVerilogHDLParserT__27))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(SysVerilogHDLParserBinary_number-42))|(1<<(SysVerilogHDLParserDecimal_number-42))|(1<<(SysVerilogHDLParserFixed_point_number-42))|(1<<(SysVerilogHDLParserHex_number-42))|(1<<(SysVerilogHDLParserOctal_number-42))|(1<<(SysVerilogHDLParserReal_exp_form-42)))) != 0) || _la == SysVerilogHDLParserInt || _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned || (((_la-201)&-(0x1f+1)) == 0 && ((1<<uint((_la-201)))&((1<<(SysVerilogHDLParserDollar_Identifier-201))|(1<<(SysVerilogHDLParserEscaped_identifier-201))|(1<<(SysVerilogHDLParserSimple_identifier-201))|(1<<(SysVerilogHDLParserString_literal-201))|(1<<(SysVerilogHDLParserLeft_curly_bracket-201))|(1<<(SysVerilogHDLParserOpen_parenthesis-201))|(1<<(SysVerilogHDLParserQuote-201))|(1<<(SysVerilogHDLParserTilde-201)))) != 0) {
				{
					p.SetState(1785)
					p.Expression()
				}

			}
			{
				p.SetState(1788)
				p.Match(SysVerilogHDLParserClose_parenthesis)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1791)
			p.Match(SysVerilogHDLParserDot)
		}
		{
			p.SetState(1792)
			p.Match(SysVerilogHDLParserStar)
		}

	}

	return localctx
}

// IList_of_module_instancesContext is an interface to support dynamic dispatch.
type IList_of_module_instancesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_module_instancesContext differentiates from other interfaces.
	IsList_of_module_instancesContext()
}

type List_of_module_instancesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_module_instancesContext() *List_of_module_instancesContext {
	var p = new(List_of_module_instancesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_module_instances
	return p
}

func (*List_of_module_instancesContext) IsList_of_module_instancesContext() {}

func NewList_of_module_instancesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_module_instancesContext {
	var p = new(List_of_module_instancesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_module_instances

	return p
}

func (s *List_of_module_instancesContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_module_instancesContext) Module_instance() IModule_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_instanceContext)
}

func (s *List_of_module_instancesContext) Comma_module_instance_star() IComma_module_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_module_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_module_instance_starContext)
}

func (s *List_of_module_instancesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_module_instancesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_module_instancesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_module_instances(s)
	}
}

func (s *List_of_module_instancesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_module_instances(s)
	}
}

func (p *SysVerilogHDLParser) List_of_module_instances() (localctx IList_of_module_instancesContext) {
	localctx = NewList_of_module_instancesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, SysVerilogHDLParserRULE_list_of_module_instances)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1795)
		p.Module_instance()
	}
	{
		p.SetState(1796)
		p.Comma_module_instance_star()
	}

	return localctx
}

// IComma_module_instance_starContext is an interface to support dynamic dispatch.
type IComma_module_instance_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_module_instance_starContext differentiates from other interfaces.
	IsComma_module_instance_starContext()
}

type Comma_module_instance_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_module_instance_starContext() *Comma_module_instance_starContext {
	var p = new(Comma_module_instance_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_module_instance_star
	return p
}

func (*Comma_module_instance_starContext) IsComma_module_instance_starContext() {}

func NewComma_module_instance_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_module_instance_starContext {
	var p = new(Comma_module_instance_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_module_instance_star

	return p
}

func (s *Comma_module_instance_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_module_instance_starContext) AllComma_module_instance() []IComma_module_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_module_instanceContext)(nil)).Elem())
	var tst = make([]IComma_module_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_module_instanceContext)
		}
	}

	return tst
}

func (s *Comma_module_instance_starContext) Comma_module_instance(i int) IComma_module_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_module_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_module_instanceContext)
}

func (s *Comma_module_instance_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_module_instance_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_module_instance_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_module_instance_star(s)
	}
}

func (s *Comma_module_instance_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_module_instance_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_module_instance_star() (localctx IComma_module_instance_starContext) {
	localctx = NewComma_module_instance_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, SysVerilogHDLParserRULE_comma_module_instance_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1801)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(1798)
			p.Comma_module_instance()
		}

		p.SetState(1803)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_module_instanceContext is an interface to support dynamic dispatch.
type IComma_module_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_module_instanceContext differentiates from other interfaces.
	IsComma_module_instanceContext()
}

type Comma_module_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_module_instanceContext() *Comma_module_instanceContext {
	var p = new(Comma_module_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_module_instance
	return p
}

func (*Comma_module_instanceContext) IsComma_module_instanceContext() {}

func NewComma_module_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_module_instanceContext {
	var p = new(Comma_module_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_module_instance

	return p
}

func (s *Comma_module_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_module_instanceContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_module_instanceContext) Module_instance() IModule_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_instanceContext)
}

func (s *Comma_module_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_module_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_module_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_module_instance(s)
	}
}

func (s *Comma_module_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_module_instance(s)
	}
}

func (p *SysVerilogHDLParser) Comma_module_instance() (localctx IComma_module_instanceContext) {
	localctx = NewComma_module_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, SysVerilogHDLParserRULE_comma_module_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1804)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(1805)
		p.Module_instance()
	}

	return localctx
}

// IModule_instanceContext is an interface to support dynamic dispatch.
type IModule_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_instanceContext differentiates from other interfaces.
	IsModule_instanceContext()
}

type Module_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_instanceContext() *Module_instanceContext {
	var p = new(Module_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_module_instance
	return p
}

func (*Module_instanceContext) IsModule_instanceContext() {}

func NewModule_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_instanceContext {
	var p = new(Module_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_module_instance

	return p
}

func (s *Module_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_instanceContext) Module_instance_identifier() IModule_instance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_instance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_instance_identifierContext)
}

func (s *Module_instanceContext) Port_interface_assignments() IPort_interface_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_interface_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_interface_assignmentsContext)
}

func (s *Module_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterModule_instance(s)
	}
}

func (s *Module_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitModule_instance(s)
	}
}

func (p *SysVerilogHDLParser) Module_instance() (localctx IModule_instanceContext) {
	localctx = NewModule_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, SysVerilogHDLParserRULE_module_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1807)
		p.Module_instance_identifier()
	}
	p.SetState(1809)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserOpen_parenthesis {
		{
			p.SetState(1808)
			p.Port_interface_assignments()
		}

	}

	return localctx
}

// IModule_instance_identifierContext is an interface to support dynamic dispatch.
type IModule_instance_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_instance_identifierContext differentiates from other interfaces.
	IsModule_instance_identifierContext()
}

type Module_instance_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_instance_identifierContext() *Module_instance_identifierContext {
	var p = new(Module_instance_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_module_instance_identifier
	return p
}

func (*Module_instance_identifierContext) IsModule_instance_identifierContext() {}

func NewModule_instance_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_instance_identifierContext {
	var p = new(Module_instance_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_module_instance_identifier

	return p
}

func (s *Module_instance_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_instance_identifierContext) Arrayed_identifier() IArrayed_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayed_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayed_identifierContext)
}

func (s *Module_instance_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_instance_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_instance_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterModule_instance_identifier(s)
	}
}

func (s *Module_instance_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitModule_instance_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Module_instance_identifier() (localctx IModule_instance_identifierContext) {
	localctx = NewModule_instance_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, SysVerilogHDLParserRULE_module_instance_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1811)
		p.Arrayed_identifier()
	}

	return localctx
}

// IArrayed_identifierContext is an interface to support dynamic dispatch.
type IArrayed_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayed_identifierContext differentiates from other interfaces.
	IsArrayed_identifierContext()
}

type Arrayed_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayed_identifierContext() *Arrayed_identifierContext {
	var p = new(Arrayed_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_arrayed_identifier
	return p
}

func (*Arrayed_identifierContext) IsArrayed_identifierContext() {}

func NewArrayed_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arrayed_identifierContext {
	var p = new(Arrayed_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_arrayed_identifier

	return p
}

func (s *Arrayed_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Arrayed_identifierContext) Simple_arrayed_identifier() ISimple_arrayed_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_arrayed_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_arrayed_identifierContext)
}

func (s *Arrayed_identifierContext) Escaped_arrayed_identifier() IEscaped_arrayed_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscaped_arrayed_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEscaped_arrayed_identifierContext)
}

func (s *Arrayed_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arrayed_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Arrayed_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterArrayed_identifier(s)
	}
}

func (s *Arrayed_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitArrayed_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Arrayed_identifier() (localctx IArrayed_identifierContext) {
	localctx = NewArrayed_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, SysVerilogHDLParserRULE_arrayed_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1815)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1813)
			p.Simple_arrayed_identifier()
		}

	case SysVerilogHDLParserEscaped_identifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1814)
			p.Escaped_arrayed_identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISimple_arrayed_identifierContext is an interface to support dynamic dispatch.
type ISimple_arrayed_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_arrayed_identifierContext differentiates from other interfaces.
	IsSimple_arrayed_identifierContext()
}

type Simple_arrayed_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_arrayed_identifierContext() *Simple_arrayed_identifierContext {
	var p = new(Simple_arrayed_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_simple_arrayed_identifier
	return p
}

func (*Simple_arrayed_identifierContext) IsSimple_arrayed_identifierContext() {}

func NewSimple_arrayed_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_arrayed_identifierContext {
	var p = new(Simple_arrayed_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_simple_arrayed_identifier

	return p
}

func (s *Simple_arrayed_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_arrayed_identifierContext) Simple_identifier() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSimple_identifier, 0)
}

func (s *Simple_arrayed_identifierContext) Dimension() IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Simple_arrayed_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_arrayed_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_arrayed_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterSimple_arrayed_identifier(s)
	}
}

func (s *Simple_arrayed_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitSimple_arrayed_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Simple_arrayed_identifier() (localctx ISimple_arrayed_identifierContext) {
	localctx = NewSimple_arrayed_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, SysVerilogHDLParserRULE_simple_arrayed_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1817)
		p.Match(SysVerilogHDLParserSimple_identifier)
	}
	p.SetState(1819)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserLeft_bracket {
		{
			p.SetState(1818)
			p.Dimension()
		}

	}

	return localctx
}

// IEscaped_arrayed_identifierContext is an interface to support dynamic dispatch.
type IEscaped_arrayed_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEscaped_arrayed_identifierContext differentiates from other interfaces.
	IsEscaped_arrayed_identifierContext()
}

type Escaped_arrayed_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEscaped_arrayed_identifierContext() *Escaped_arrayed_identifierContext {
	var p = new(Escaped_arrayed_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_escaped_arrayed_identifier
	return p
}

func (*Escaped_arrayed_identifierContext) IsEscaped_arrayed_identifierContext() {}

func NewEscaped_arrayed_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Escaped_arrayed_identifierContext {
	var p = new(Escaped_arrayed_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_escaped_arrayed_identifier

	return p
}

func (s *Escaped_arrayed_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Escaped_arrayed_identifierContext) Escaped_identifier() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEscaped_identifier, 0)
}

func (s *Escaped_arrayed_identifierContext) Dimension() IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Escaped_arrayed_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Escaped_arrayed_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Escaped_arrayed_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEscaped_arrayed_identifier(s)
	}
}

func (s *Escaped_arrayed_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEscaped_arrayed_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Escaped_arrayed_identifier() (localctx IEscaped_arrayed_identifierContext) {
	localctx = NewEscaped_arrayed_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, SysVerilogHDLParserRULE_escaped_arrayed_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1821)
		p.Match(SysVerilogHDLParserEscaped_identifier)
	}
	p.SetState(1823)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserLeft_bracket {
		{
			p.SetState(1822)
			p.Dimension()
		}

	}

	return localctx
}

// IPort_interface_assignmentsContext is an interface to support dynamic dispatch.
type IPort_interface_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_interface_assignmentsContext differentiates from other interfaces.
	IsPort_interface_assignmentsContext()
}

type Port_interface_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_interface_assignmentsContext() *Port_interface_assignmentsContext {
	var p = new(Port_interface_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_port_interface_assignments
	return p
}

func (*Port_interface_assignmentsContext) IsPort_interface_assignmentsContext() {}

func NewPort_interface_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_interface_assignmentsContext {
	var p = new(Port_interface_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_port_interface_assignments

	return p
}

func (s *Port_interface_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_interface_assignmentsContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Port_interface_assignmentsContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Port_interface_assignmentsContext) List_of_interface_assignments() IList_of_interface_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_interface_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_interface_assignmentsContext)
}

func (s *Port_interface_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_interface_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_interface_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPort_interface_assignments(s)
	}
}

func (s *Port_interface_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPort_interface_assignments(s)
	}
}

func (p *SysVerilogHDLParser) Port_interface_assignments() (localctx IPort_interface_assignmentsContext) {
	localctx = NewPort_interface_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, SysVerilogHDLParserRULE_port_interface_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1825)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	p.SetState(1827)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SysVerilogHDLParserT__1)|(1<<SysVerilogHDLParserT__2)|(1<<SysVerilogHDLParserT__3)|(1<<SysVerilogHDLParserT__4)|(1<<SysVerilogHDLParserT__5)|(1<<SysVerilogHDLParserT__6)|(1<<SysVerilogHDLParserT__7)|(1<<SysVerilogHDLParserT__8)|(1<<SysVerilogHDLParserT__9)|(1<<SysVerilogHDLParserT__10)|(1<<SysVerilogHDLParserT__26)|(1<<SysVerilogHDLParserT__27))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(SysVerilogHDLParserBinary_number-42))|(1<<(SysVerilogHDLParserDecimal_number-42))|(1<<(SysVerilogHDLParserFixed_point_number-42))|(1<<(SysVerilogHDLParserHex_number-42))|(1<<(SysVerilogHDLParserOctal_number-42))|(1<<(SysVerilogHDLParserReal_exp_form-42)))) != 0) || _la == SysVerilogHDLParserInt || _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned || (((_la-201)&-(0x1f+1)) == 0 && ((1<<uint((_la-201)))&((1<<(SysVerilogHDLParserDollar_Identifier-201))|(1<<(SysVerilogHDLParserEscaped_identifier-201))|(1<<(SysVerilogHDLParserSimple_identifier-201))|(1<<(SysVerilogHDLParserString_literal-201))|(1<<(SysVerilogHDLParserDot-201))|(1<<(SysVerilogHDLParserLeft_curly_bracket-201))|(1<<(SysVerilogHDLParserOpen_parenthesis-201))|(1<<(SysVerilogHDLParserQuote-201))|(1<<(SysVerilogHDLParserTilde-201)))) != 0) {
		{
			p.SetState(1826)
			p.List_of_interface_assignments()
		}

	}
	{
		p.SetState(1829)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// IDelayContext is an interface to support dynamic dispatch.
type IDelayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelayContext differentiates from other interfaces.
	IsDelayContext()
}

type DelayContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelayContext() *DelayContext {
	var p = new(DelayContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_delay
	return p
}

func (*DelayContext) IsDelayContext() {}

func NewDelayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelayContext {
	var p = new(DelayContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_delay

	return p
}

func (s *DelayContext) GetParser() antlr.Parser { return s.parser }

func (s *DelayContext) Hash() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserHash, 0)
}

func (s *DelayContext) Delay_value() IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *DelayContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *DelayContext) List_of_delay_values() IList_of_delay_valuesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_delay_valuesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_delay_valuesContext)
}

func (s *DelayContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *DelayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDelay(s)
	}
}

func (s *DelayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDelay(s)
	}
}

func (p *SysVerilogHDLParser) Delay() (localctx IDelayContext) {
	localctx = NewDelayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, SysVerilogHDLParserRULE_delay)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1838)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1831)
			p.Match(SysVerilogHDLParserHash)
		}
		{
			p.SetState(1832)
			p.Delay_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1833)
			p.Match(SysVerilogHDLParserHash)
		}
		{
			p.SetState(1834)
			p.Match(SysVerilogHDLParserOpen_parenthesis)
		}
		{
			p.SetState(1835)
			p.List_of_delay_values()
		}
		{
			p.SetState(1836)
			p.Match(SysVerilogHDLParserClose_parenthesis)
		}

	}

	return localctx
}

// IList_of_delay_valuesContext is an interface to support dynamic dispatch.
type IList_of_delay_valuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_delay_valuesContext differentiates from other interfaces.
	IsList_of_delay_valuesContext()
}

type List_of_delay_valuesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_delay_valuesContext() *List_of_delay_valuesContext {
	var p = new(List_of_delay_valuesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_delay_values
	return p
}

func (*List_of_delay_valuesContext) IsList_of_delay_valuesContext() {}

func NewList_of_delay_valuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_delay_valuesContext {
	var p = new(List_of_delay_valuesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_delay_values

	return p
}

func (s *List_of_delay_valuesContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_delay_valuesContext) Delay_value() IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *List_of_delay_valuesContext) Comma_delay_value_star() IComma_delay_value_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_delay_value_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_delay_value_starContext)
}

func (s *List_of_delay_valuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_delay_valuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_delay_valuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_delay_values(s)
	}
}

func (s *List_of_delay_valuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_delay_values(s)
	}
}

func (p *SysVerilogHDLParser) List_of_delay_values() (localctx IList_of_delay_valuesContext) {
	localctx = NewList_of_delay_valuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, SysVerilogHDLParserRULE_list_of_delay_values)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1840)
		p.Delay_value()
	}
	{
		p.SetState(1841)
		p.Comma_delay_value_star()
	}

	return localctx
}

// IComma_delay_value_starContext is an interface to support dynamic dispatch.
type IComma_delay_value_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_delay_value_starContext differentiates from other interfaces.
	IsComma_delay_value_starContext()
}

type Comma_delay_value_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_delay_value_starContext() *Comma_delay_value_starContext {
	var p = new(Comma_delay_value_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_delay_value_star
	return p
}

func (*Comma_delay_value_starContext) IsComma_delay_value_starContext() {}

func NewComma_delay_value_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_delay_value_starContext {
	var p = new(Comma_delay_value_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_delay_value_star

	return p
}

func (s *Comma_delay_value_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_delay_value_starContext) AllComma_delay_value() []IComma_delay_valueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_delay_valueContext)(nil)).Elem())
	var tst = make([]IComma_delay_valueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_delay_valueContext)
		}
	}

	return tst
}

func (s *Comma_delay_value_starContext) Comma_delay_value(i int) IComma_delay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_delay_valueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_delay_valueContext)
}

func (s *Comma_delay_value_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_delay_value_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_delay_value_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_delay_value_star(s)
	}
}

func (s *Comma_delay_value_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_delay_value_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_delay_value_star() (localctx IComma_delay_value_starContext) {
	localctx = NewComma_delay_value_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, SysVerilogHDLParserRULE_comma_delay_value_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1846)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(1843)
			p.Comma_delay_value()
		}

		p.SetState(1848)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_delay_valueContext is an interface to support dynamic dispatch.
type IComma_delay_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_delay_valueContext differentiates from other interfaces.
	IsComma_delay_valueContext()
}

type Comma_delay_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_delay_valueContext() *Comma_delay_valueContext {
	var p = new(Comma_delay_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_delay_value
	return p
}

func (*Comma_delay_valueContext) IsComma_delay_valueContext() {}

func NewComma_delay_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_delay_valueContext {
	var p = new(Comma_delay_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_delay_value

	return p
}

func (s *Comma_delay_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_delay_valueContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_delay_valueContext) Delay_value() IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *Comma_delay_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_delay_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_delay_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_delay_value(s)
	}
}

func (s *Comma_delay_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_delay_value(s)
	}
}

func (p *SysVerilogHDLParser) Comma_delay_value() (localctx IComma_delay_valueContext) {
	localctx = NewComma_delay_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, SysVerilogHDLParserRULE_comma_delay_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1849)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(1850)
		p.Delay_value()
	}

	return localctx
}

// IDelay_valueContext is an interface to support dynamic dispatch.
type IDelay_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_valueContext differentiates from other interfaces.
	IsDelay_valueContext()
}

type Delay_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_valueContext() *Delay_valueContext {
	var p = new(Delay_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_delay_value
	return p
}

func (*Delay_valueContext) IsDelay_valueContext() {}

func NewDelay_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_valueContext {
	var p = new(Delay_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_delay_value

	return p
}

func (s *Delay_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_valueContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Delay_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDelay_value(s)
	}
}

func (s *Delay_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDelay_value(s)
	}
}

func (p *SysVerilogHDLParser) Delay_value() (localctx IDelay_valueContext) {
	localctx = NewDelay_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, SysVerilogHDLParserRULE_delay_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1852)
		p.Expression()
	}

	return localctx
}

// IPulldown_strengthContext is an interface to support dynamic dispatch.
type IPulldown_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPulldown_strengthContext differentiates from other interfaces.
	IsPulldown_strengthContext()
}

type Pulldown_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPulldown_strengthContext() *Pulldown_strengthContext {
	var p = new(Pulldown_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_pulldown_strength
	return p
}

func (*Pulldown_strengthContext) IsPulldown_strengthContext() {}

func NewPulldown_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pulldown_strengthContext {
	var p = new(Pulldown_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_pulldown_strength

	return p
}

func (s *Pulldown_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Pulldown_strengthContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Pulldown_strengthContext) Strength0() IStrength0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength0Context)
}

func (s *Pulldown_strengthContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Pulldown_strengthContext) Strength1() IStrength1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength1Context)
}

func (s *Pulldown_strengthContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Pulldown_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pulldown_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pulldown_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPulldown_strength(s)
	}
}

func (s *Pulldown_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPulldown_strength(s)
	}
}

func (p *SysVerilogHDLParser) Pulldown_strength() (localctx IPulldown_strengthContext) {
	localctx = NewPulldown_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, SysVerilogHDLParserRULE_pulldown_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1870)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1854)
			p.Match(SysVerilogHDLParserOpen_parenthesis)
		}
		{
			p.SetState(1855)
			p.Strength0()
		}
		{
			p.SetState(1856)
			p.Match(SysVerilogHDLParserComma)
		}
		{
			p.SetState(1857)
			p.Strength1()
		}
		{
			p.SetState(1858)
			p.Match(SysVerilogHDLParserClose_parenthesis)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1860)
			p.Match(SysVerilogHDLParserOpen_parenthesis)
		}
		{
			p.SetState(1861)
			p.Strength1()
		}
		{
			p.SetState(1862)
			p.Match(SysVerilogHDLParserComma)
		}
		{
			p.SetState(1863)
			p.Strength0()
		}
		{
			p.SetState(1864)
			p.Match(SysVerilogHDLParserClose_parenthesis)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1866)
			p.Match(SysVerilogHDLParserOpen_parenthesis)
		}
		{
			p.SetState(1867)
			p.Strength0()
		}
		{
			p.SetState(1868)
			p.Match(SysVerilogHDLParserClose_parenthesis)
		}

	}

	return localctx
}

// IPullup_strengthContext is an interface to support dynamic dispatch.
type IPullup_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPullup_strengthContext differentiates from other interfaces.
	IsPullup_strengthContext()
}

type Pullup_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPullup_strengthContext() *Pullup_strengthContext {
	var p = new(Pullup_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_pullup_strength
	return p
}

func (*Pullup_strengthContext) IsPullup_strengthContext() {}

func NewPullup_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pullup_strengthContext {
	var p = new(Pullup_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_pullup_strength

	return p
}

func (s *Pullup_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Pullup_strengthContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Pullup_strengthContext) Strength0() IStrength0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength0Context)
}

func (s *Pullup_strengthContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Pullup_strengthContext) Strength1() IStrength1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength1Context)
}

func (s *Pullup_strengthContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Pullup_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pullup_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pullup_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPullup_strength(s)
	}
}

func (s *Pullup_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPullup_strength(s)
	}
}

func (p *SysVerilogHDLParser) Pullup_strength() (localctx IPullup_strengthContext) {
	localctx = NewPullup_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, SysVerilogHDLParserRULE_pullup_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1888)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1872)
			p.Match(SysVerilogHDLParserOpen_parenthesis)
		}
		{
			p.SetState(1873)
			p.Strength0()
		}
		{
			p.SetState(1874)
			p.Match(SysVerilogHDLParserComma)
		}
		{
			p.SetState(1875)
			p.Strength1()
		}
		{
			p.SetState(1876)
			p.Match(SysVerilogHDLParserClose_parenthesis)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1878)
			p.Match(SysVerilogHDLParserOpen_parenthesis)
		}
		{
			p.SetState(1879)
			p.Strength1()
		}
		{
			p.SetState(1880)
			p.Match(SysVerilogHDLParserComma)
		}
		{
			p.SetState(1881)
			p.Strength0()
		}
		{
			p.SetState(1882)
			p.Match(SysVerilogHDLParserClose_parenthesis)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1884)
			p.Match(SysVerilogHDLParserOpen_parenthesis)
		}
		{
			p.SetState(1885)
			p.Strength1()
		}
		{
			p.SetState(1886)
			p.Match(SysVerilogHDLParserClose_parenthesis)
		}

	}

	return localctx
}

// IGate_instance_identifierContext is an interface to support dynamic dispatch.
type IGate_instance_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGate_instance_identifierContext differentiates from other interfaces.
	IsGate_instance_identifierContext()
}

type Gate_instance_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGate_instance_identifierContext() *Gate_instance_identifierContext {
	var p = new(Gate_instance_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_gate_instance_identifier
	return p
}

func (*Gate_instance_identifierContext) IsGate_instance_identifierContext() {}

func NewGate_instance_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Gate_instance_identifierContext {
	var p = new(Gate_instance_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_gate_instance_identifier

	return p
}

func (s *Gate_instance_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Gate_instance_identifierContext) Arrayed_identifier() IArrayed_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayed_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayed_identifierContext)
}

func (s *Gate_instance_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Gate_instance_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Gate_instance_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGate_instance_identifier(s)
	}
}

func (s *Gate_instance_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGate_instance_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Gate_instance_identifier() (localctx IGate_instance_identifierContext) {
	localctx = NewGate_instance_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, SysVerilogHDLParserRULE_gate_instance_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1890)
		p.Arrayed_identifier()
	}

	return localctx
}

// IGate_instantiationContext is an interface to support dynamic dispatch.
type IGate_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGate_instantiationContext differentiates from other interfaces.
	IsGate_instantiationContext()
}

type Gate_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGate_instantiationContext() *Gate_instantiationContext {
	var p = new(Gate_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_gate_instantiation
	return p
}

func (*Gate_instantiationContext) IsGate_instantiationContext() {}

func NewGate_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Gate_instantiationContext {
	var p = new(Gate_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_gate_instantiation

	return p
}

func (s *Gate_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Gate_instantiationContext) Cmos_instantiation() ICmos_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmos_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmos_instantiationContext)
}

func (s *Gate_instantiationContext) Mos_instantiation() IMos_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMos_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMos_instantiationContext)
}

func (s *Gate_instantiationContext) Pass_instantiation() IPass_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_instantiationContext)
}

func (s *Gate_instantiationContext) Pulldown_instantiation() IPulldown_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPulldown_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPulldown_instantiationContext)
}

func (s *Gate_instantiationContext) Pullup_instantiation() IPullup_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPullup_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPullup_instantiationContext)
}

func (s *Gate_instantiationContext) Enable_instantiation() IEnable_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_instantiationContext)
}

func (s *Gate_instantiationContext) N_input_instantiation() IN_input_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_input_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_input_instantiationContext)
}

func (s *Gate_instantiationContext) N_output_instantiation() IN_output_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_output_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_output_instantiationContext)
}

func (s *Gate_instantiationContext) Pass_enable_instantiation() IPass_enable_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_enable_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_enable_instantiationContext)
}

func (s *Gate_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Gate_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Gate_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGate_instantiation(s)
	}
}

func (s *Gate_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGate_instantiation(s)
	}
}

func (p *SysVerilogHDLParser) Gate_instantiation() (localctx IGate_instantiationContext) {
	localctx = NewGate_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, SysVerilogHDLParserRULE_gate_instantiation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1901)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserCmos, SysVerilogHDLParserRcmos:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1892)
			p.Cmos_instantiation()
		}

	case SysVerilogHDLParserNmos, SysVerilogHDLParserPmos, SysVerilogHDLParserRnmos, SysVerilogHDLParserRpmos:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1893)
			p.Mos_instantiation()
		}

	case SysVerilogHDLParserRtran, SysVerilogHDLParserTran:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1894)
			p.Pass_instantiation()
		}

	case SysVerilogHDLParserPulldown:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1895)
			p.Pulldown_instantiation()
		}

	case SysVerilogHDLParserPullup:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1896)
			p.Pullup_instantiation()
		}

	case SysVerilogHDLParserBufif0, SysVerilogHDLParserBufif1, SysVerilogHDLParserNotif0, SysVerilogHDLParserNotif1:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1897)
			p.Enable_instantiation()
		}

	case SysVerilogHDLParserAnd, SysVerilogHDLParserNand, SysVerilogHDLParserNor, SysVerilogHDLParserOr, SysVerilogHDLParserXnor, SysVerilogHDLParserXor:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1898)
			p.N_input_instantiation()
		}

	case SysVerilogHDLParserBuf, SysVerilogHDLParserNot:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1899)
			p.N_output_instantiation()
		}

	case SysVerilogHDLParserRtranif0, SysVerilogHDLParserRtranif1, SysVerilogHDLParserTranif0, SysVerilogHDLParserTranif1:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1900)
			p.Pass_enable_instantiation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnable_gatetypeContext is an interface to support dynamic dispatch.
type IEnable_gatetypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_gatetypeContext differentiates from other interfaces.
	IsEnable_gatetypeContext()
}

type Enable_gatetypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_gatetypeContext() *Enable_gatetypeContext {
	var p = new(Enable_gatetypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_enable_gatetype
	return p
}

func (*Enable_gatetypeContext) IsEnable_gatetypeContext() {}

func NewEnable_gatetypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_gatetypeContext {
	var p = new(Enable_gatetypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_enable_gatetype

	return p
}

func (s *Enable_gatetypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_gatetypeContext) Bufif0() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserBufif0, 0)
}

func (s *Enable_gatetypeContext) Bufif1() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserBufif1, 0)
}

func (s *Enable_gatetypeContext) Notif0() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserNotif0, 0)
}

func (s *Enable_gatetypeContext) Notif1() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserNotif1, 0)
}

func (s *Enable_gatetypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_gatetypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_gatetypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEnable_gatetype(s)
	}
}

func (s *Enable_gatetypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEnable_gatetype(s)
	}
}

func (p *SysVerilogHDLParser) Enable_gatetype() (localctx IEnable_gatetypeContext) {
	localctx = NewEnable_gatetypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, SysVerilogHDLParserRULE_enable_gatetype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1903)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SysVerilogHDLParserBufif0 || _la == SysVerilogHDLParserBufif1 || _la == SysVerilogHDLParserNotif0 || _la == SysVerilogHDLParserNotif1) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMos_switchtypeContext is an interface to support dynamic dispatch.
type IMos_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMos_switchtypeContext differentiates from other interfaces.
	IsMos_switchtypeContext()
}

type Mos_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMos_switchtypeContext() *Mos_switchtypeContext {
	var p = new(Mos_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_mos_switchtype
	return p
}

func (*Mos_switchtypeContext) IsMos_switchtypeContext() {}

func NewMos_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mos_switchtypeContext {
	var p = new(Mos_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_mos_switchtype

	return p
}

func (s *Mos_switchtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Mos_switchtypeContext) Nmos() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserNmos, 0)
}

func (s *Mos_switchtypeContext) Pmos() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserPmos, 0)
}

func (s *Mos_switchtypeContext) Rnmos() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRnmos, 0)
}

func (s *Mos_switchtypeContext) Rpmos() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRpmos, 0)
}

func (s *Mos_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mos_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mos_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterMos_switchtype(s)
	}
}

func (s *Mos_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitMos_switchtype(s)
	}
}

func (p *SysVerilogHDLParser) Mos_switchtype() (localctx IMos_switchtypeContext) {
	localctx = NewMos_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, SysVerilogHDLParserRULE_mos_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1905)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-124)&-(0x1f+1)) == 0 && ((1<<uint((_la-124)))&((1<<(SysVerilogHDLParserNmos-124))|(1<<(SysVerilogHDLParserPmos-124))|(1<<(SysVerilogHDLParserRnmos-124))|(1<<(SysVerilogHDLParserRpmos-124)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICmos_switchtypeContext is an interface to support dynamic dispatch.
type ICmos_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmos_switchtypeContext differentiates from other interfaces.
	IsCmos_switchtypeContext()
}

type Cmos_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmos_switchtypeContext() *Cmos_switchtypeContext {
	var p = new(Cmos_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_cmos_switchtype
	return p
}

func (*Cmos_switchtypeContext) IsCmos_switchtypeContext() {}

func NewCmos_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmos_switchtypeContext {
	var p = new(Cmos_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_cmos_switchtype

	return p
}

func (s *Cmos_switchtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmos_switchtypeContext) Cmos() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserCmos, 0)
}

func (s *Cmos_switchtypeContext) Rcmos() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRcmos, 0)
}

func (s *Cmos_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmos_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmos_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterCmos_switchtype(s)
	}
}

func (s *Cmos_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitCmos_switchtype(s)
	}
}

func (p *SysVerilogHDLParser) Cmos_switchtype() (localctx ICmos_switchtypeContext) {
	localctx = NewCmos_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, SysVerilogHDLParserRULE_cmos_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1907)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SysVerilogHDLParserCmos || _la == SysVerilogHDLParserRcmos) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IN_output_gatetypeContext is an interface to support dynamic dispatch.
type IN_output_gatetypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_output_gatetypeContext differentiates from other interfaces.
	IsN_output_gatetypeContext()
}

type N_output_gatetypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_output_gatetypeContext() *N_output_gatetypeContext {
	var p = new(N_output_gatetypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_n_output_gatetype
	return p
}

func (*N_output_gatetypeContext) IsN_output_gatetypeContext() {}

func NewN_output_gatetypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_output_gatetypeContext {
	var p = new(N_output_gatetypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_n_output_gatetype

	return p
}

func (s *N_output_gatetypeContext) GetParser() antlr.Parser { return s.parser }

func (s *N_output_gatetypeContext) Buf() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserBuf, 0)
}

func (s *N_output_gatetypeContext) Not() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserNot, 0)
}

func (s *N_output_gatetypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_output_gatetypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_output_gatetypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterN_output_gatetype(s)
	}
}

func (s *N_output_gatetypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitN_output_gatetype(s)
	}
}

func (p *SysVerilogHDLParser) N_output_gatetype() (localctx IN_output_gatetypeContext) {
	localctx = NewN_output_gatetypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, SysVerilogHDLParserRULE_n_output_gatetype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1909)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SysVerilogHDLParserBuf || _la == SysVerilogHDLParserNot) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IN_input_gatetypeContext is an interface to support dynamic dispatch.
type IN_input_gatetypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_input_gatetypeContext differentiates from other interfaces.
	IsN_input_gatetypeContext()
}

type N_input_gatetypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_input_gatetypeContext() *N_input_gatetypeContext {
	var p = new(N_input_gatetypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_n_input_gatetype
	return p
}

func (*N_input_gatetypeContext) IsN_input_gatetypeContext() {}

func NewN_input_gatetypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_input_gatetypeContext {
	var p = new(N_input_gatetypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_n_input_gatetype

	return p
}

func (s *N_input_gatetypeContext) GetParser() antlr.Parser { return s.parser }

func (s *N_input_gatetypeContext) And() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserAnd, 0)
}

func (s *N_input_gatetypeContext) Nand() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserNand, 0)
}

func (s *N_input_gatetypeContext) Or() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOr, 0)
}

func (s *N_input_gatetypeContext) Nor() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserNor, 0)
}

func (s *N_input_gatetypeContext) Xor() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserXor, 0)
}

func (s *N_input_gatetypeContext) Xnor() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserXnor, 0)
}

func (s *N_input_gatetypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_input_gatetypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_input_gatetypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterN_input_gatetype(s)
	}
}

func (s *N_input_gatetypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitN_input_gatetype(s)
	}
}

func (p *SysVerilogHDLParser) N_input_gatetype() (localctx IN_input_gatetypeContext) {
	localctx = NewN_input_gatetypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, SysVerilogHDLParserRULE_n_input_gatetype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1911)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SysVerilogHDLParserAnd || (((_la-122)&-(0x1f+1)) == 0 && ((1<<uint((_la-122)))&((1<<(SysVerilogHDLParserNand-122))|(1<<(SysVerilogHDLParserNor-122))|(1<<(SysVerilogHDLParserOr-122)))) != 0) || _la == SysVerilogHDLParserXnor || _la == SysVerilogHDLParserXor) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPass_switchtypeContext is an interface to support dynamic dispatch.
type IPass_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_switchtypeContext differentiates from other interfaces.
	IsPass_switchtypeContext()
}

type Pass_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_switchtypeContext() *Pass_switchtypeContext {
	var p = new(Pass_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_pass_switchtype
	return p
}

func (*Pass_switchtypeContext) IsPass_switchtypeContext() {}

func NewPass_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_switchtypeContext {
	var p = new(Pass_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_pass_switchtype

	return p
}

func (s *Pass_switchtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_switchtypeContext) Tran() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTran, 0)
}

func (s *Pass_switchtypeContext) Rtran() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRtran, 0)
}

func (s *Pass_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPass_switchtype(s)
	}
}

func (s *Pass_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPass_switchtype(s)
	}
}

func (p *SysVerilogHDLParser) Pass_switchtype() (localctx IPass_switchtypeContext) {
	localctx = NewPass_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, SysVerilogHDLParserRULE_pass_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1913)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SysVerilogHDLParserRtran || _la == SysVerilogHDLParserTran) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPass_enable_switchtypeContext is an interface to support dynamic dispatch.
type IPass_enable_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_enable_switchtypeContext differentiates from other interfaces.
	IsPass_enable_switchtypeContext()
}

type Pass_enable_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_enable_switchtypeContext() *Pass_enable_switchtypeContext {
	var p = new(Pass_enable_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_pass_enable_switchtype
	return p
}

func (*Pass_enable_switchtypeContext) IsPass_enable_switchtypeContext() {}

func NewPass_enable_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_enable_switchtypeContext {
	var p = new(Pass_enable_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_pass_enable_switchtype

	return p
}

func (s *Pass_enable_switchtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_enable_switchtypeContext) Tranif0() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTranif0, 0)
}

func (s *Pass_enable_switchtypeContext) Tranif1() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTranif1, 0)
}

func (s *Pass_enable_switchtypeContext) Rtranif1() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRtranif1, 0)
}

func (s *Pass_enable_switchtypeContext) Rtranif0() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRtranif0, 0)
}

func (s *Pass_enable_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_enable_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_enable_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPass_enable_switchtype(s)
	}
}

func (s *Pass_enable_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPass_enable_switchtype(s)
	}
}

func (p *SysVerilogHDLParser) Pass_enable_switchtype() (localctx IPass_enable_switchtypeContext) {
	localctx = NewPass_enable_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, SysVerilogHDLParserRULE_pass_enable_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1915)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-157)&-(0x1f+1)) == 0 && ((1<<uint((_la-157)))&((1<<(SysVerilogHDLParserRtranif0-157))|(1<<(SysVerilogHDLParserRtranif1-157))|(1<<(SysVerilogHDLParserTranif0-157))|(1<<(SysVerilogHDLParserTranif1-157)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPulldown_instantiationContext is an interface to support dynamic dispatch.
type IPulldown_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPulldown_instantiationContext differentiates from other interfaces.
	IsPulldown_instantiationContext()
}

type Pulldown_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPulldown_instantiationContext() *Pulldown_instantiationContext {
	var p = new(Pulldown_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_pulldown_instantiation
	return p
}

func (*Pulldown_instantiationContext) IsPulldown_instantiationContext() {}

func NewPulldown_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pulldown_instantiationContext {
	var p = new(Pulldown_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_pulldown_instantiation

	return p
}

func (s *Pulldown_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Pulldown_instantiationContext) Pulldown() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserPulldown, 0)
}

func (s *Pulldown_instantiationContext) List_of_pull_gate_instance() IList_of_pull_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_pull_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_pull_gate_instanceContext)
}

func (s *Pulldown_instantiationContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Pulldown_instantiationContext) Pulldown_strength() IPulldown_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPulldown_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPulldown_strengthContext)
}

func (s *Pulldown_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pulldown_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pulldown_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPulldown_instantiation(s)
	}
}

func (s *Pulldown_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPulldown_instantiation(s)
	}
}

func (p *SysVerilogHDLParser) Pulldown_instantiation() (localctx IPulldown_instantiationContext) {
	localctx = NewPulldown_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, SysVerilogHDLParserRULE_pulldown_instantiation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1917)
		p.Match(SysVerilogHDLParserPulldown)
	}
	p.SetState(1919)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1918)
			p.Pulldown_strength()
		}

	}
	{
		p.SetState(1921)
		p.List_of_pull_gate_instance()
	}
	{
		p.SetState(1922)
		p.Semicolon()
	}

	return localctx
}

// IPullup_instantiationContext is an interface to support dynamic dispatch.
type IPullup_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPullup_instantiationContext differentiates from other interfaces.
	IsPullup_instantiationContext()
}

type Pullup_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPullup_instantiationContext() *Pullup_instantiationContext {
	var p = new(Pullup_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_pullup_instantiation
	return p
}

func (*Pullup_instantiationContext) IsPullup_instantiationContext() {}

func NewPullup_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pullup_instantiationContext {
	var p = new(Pullup_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_pullup_instantiation

	return p
}

func (s *Pullup_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Pullup_instantiationContext) Pullup() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserPullup, 0)
}

func (s *Pullup_instantiationContext) List_of_pull_gate_instance() IList_of_pull_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_pull_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_pull_gate_instanceContext)
}

func (s *Pullup_instantiationContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Pullup_instantiationContext) Pullup_strength() IPullup_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPullup_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPullup_strengthContext)
}

func (s *Pullup_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pullup_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pullup_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPullup_instantiation(s)
	}
}

func (s *Pullup_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPullup_instantiation(s)
	}
}

func (p *SysVerilogHDLParser) Pullup_instantiation() (localctx IPullup_instantiationContext) {
	localctx = NewPullup_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, SysVerilogHDLParserRULE_pullup_instantiation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1924)
		p.Match(SysVerilogHDLParserPullup)
	}
	p.SetState(1926)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1925)
			p.Pullup_strength()
		}

	}
	{
		p.SetState(1928)
		p.List_of_pull_gate_instance()
	}
	{
		p.SetState(1929)
		p.Semicolon()
	}

	return localctx
}

// IEnable_instantiationContext is an interface to support dynamic dispatch.
type IEnable_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_instantiationContext differentiates from other interfaces.
	IsEnable_instantiationContext()
}

type Enable_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_instantiationContext() *Enable_instantiationContext {
	var p = new(Enable_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_enable_instantiation
	return p
}

func (*Enable_instantiationContext) IsEnable_instantiationContext() {}

func NewEnable_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_instantiationContext {
	var p = new(Enable_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_enable_instantiation

	return p
}

func (s *Enable_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_instantiationContext) Enable_gatetype() IEnable_gatetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_gatetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_gatetypeContext)
}

func (s *Enable_instantiationContext) List_of_enable_gate_instance() IList_of_enable_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_enable_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_enable_gate_instanceContext)
}

func (s *Enable_instantiationContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Enable_instantiationContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *Enable_instantiationContext) Delay() IDelayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelayContext)
}

func (s *Enable_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEnable_instantiation(s)
	}
}

func (s *Enable_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEnable_instantiation(s)
	}
}

func (p *SysVerilogHDLParser) Enable_instantiation() (localctx IEnable_instantiationContext) {
	localctx = NewEnable_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, SysVerilogHDLParserRULE_enable_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1931)
		p.Enable_gatetype()
	}
	p.SetState(1933)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1932)
			p.Drive_strength()
		}

	}
	p.SetState(1936)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserHash {
		{
			p.SetState(1935)
			p.Delay()
		}

	}
	{
		p.SetState(1938)
		p.List_of_enable_gate_instance()
	}
	{
		p.SetState(1939)
		p.Semicolon()
	}

	return localctx
}

// IMos_instantiationContext is an interface to support dynamic dispatch.
type IMos_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMos_instantiationContext differentiates from other interfaces.
	IsMos_instantiationContext()
}

type Mos_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMos_instantiationContext() *Mos_instantiationContext {
	var p = new(Mos_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_mos_instantiation
	return p
}

func (*Mos_instantiationContext) IsMos_instantiationContext() {}

func NewMos_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mos_instantiationContext {
	var p = new(Mos_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_mos_instantiation

	return p
}

func (s *Mos_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Mos_instantiationContext) Mos_switchtype() IMos_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMos_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMos_switchtypeContext)
}

func (s *Mos_instantiationContext) List_of_mos_switch_instance() IList_of_mos_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_mos_switch_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_mos_switch_instanceContext)
}

func (s *Mos_instantiationContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Mos_instantiationContext) Delay() IDelayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelayContext)
}

func (s *Mos_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mos_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mos_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterMos_instantiation(s)
	}
}

func (s *Mos_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitMos_instantiation(s)
	}
}

func (p *SysVerilogHDLParser) Mos_instantiation() (localctx IMos_instantiationContext) {
	localctx = NewMos_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, SysVerilogHDLParserRULE_mos_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1941)
		p.Mos_switchtype()
	}
	p.SetState(1943)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserHash {
		{
			p.SetState(1942)
			p.Delay()
		}

	}
	{
		p.SetState(1945)
		p.List_of_mos_switch_instance()
	}
	{
		p.SetState(1946)
		p.Semicolon()
	}

	return localctx
}

// ICmos_instantiationContext is an interface to support dynamic dispatch.
type ICmos_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmos_instantiationContext differentiates from other interfaces.
	IsCmos_instantiationContext()
}

type Cmos_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmos_instantiationContext() *Cmos_instantiationContext {
	var p = new(Cmos_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_cmos_instantiation
	return p
}

func (*Cmos_instantiationContext) IsCmos_instantiationContext() {}

func NewCmos_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmos_instantiationContext {
	var p = new(Cmos_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_cmos_instantiation

	return p
}

func (s *Cmos_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmos_instantiationContext) Cmos_switchtype() ICmos_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmos_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmos_switchtypeContext)
}

func (s *Cmos_instantiationContext) List_of_cmos_switch_instance() IList_of_cmos_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_cmos_switch_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_cmos_switch_instanceContext)
}

func (s *Cmos_instantiationContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Cmos_instantiationContext) Delay() IDelayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelayContext)
}

func (s *Cmos_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmos_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmos_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterCmos_instantiation(s)
	}
}

func (s *Cmos_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitCmos_instantiation(s)
	}
}

func (p *SysVerilogHDLParser) Cmos_instantiation() (localctx ICmos_instantiationContext) {
	localctx = NewCmos_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, SysVerilogHDLParserRULE_cmos_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1948)
		p.Cmos_switchtype()
	}
	p.SetState(1950)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserHash {
		{
			p.SetState(1949)
			p.Delay()
		}

	}
	{
		p.SetState(1952)
		p.List_of_cmos_switch_instance()
	}
	{
		p.SetState(1953)
		p.Semicolon()
	}

	return localctx
}

// IN_output_instantiationContext is an interface to support dynamic dispatch.
type IN_output_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_output_instantiationContext differentiates from other interfaces.
	IsN_output_instantiationContext()
}

type N_output_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_output_instantiationContext() *N_output_instantiationContext {
	var p = new(N_output_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_n_output_instantiation
	return p
}

func (*N_output_instantiationContext) IsN_output_instantiationContext() {}

func NewN_output_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_output_instantiationContext {
	var p = new(N_output_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_n_output_instantiation

	return p
}

func (s *N_output_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *N_output_instantiationContext) N_output_gatetype() IN_output_gatetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_output_gatetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_output_gatetypeContext)
}

func (s *N_output_instantiationContext) List_of_n_output_gate_instance() IList_of_n_output_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_n_output_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_n_output_gate_instanceContext)
}

func (s *N_output_instantiationContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *N_output_instantiationContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *N_output_instantiationContext) Delay() IDelayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelayContext)
}

func (s *N_output_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_output_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_output_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterN_output_instantiation(s)
	}
}

func (s *N_output_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitN_output_instantiation(s)
	}
}

func (p *SysVerilogHDLParser) N_output_instantiation() (localctx IN_output_instantiationContext) {
	localctx = NewN_output_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, SysVerilogHDLParserRULE_n_output_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1955)
		p.N_output_gatetype()
	}
	p.SetState(1957)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1956)
			p.Drive_strength()
		}

	}
	p.SetState(1960)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserHash {
		{
			p.SetState(1959)
			p.Delay()
		}

	}
	{
		p.SetState(1962)
		p.List_of_n_output_gate_instance()
	}
	{
		p.SetState(1963)
		p.Semicolon()
	}

	return localctx
}

// IN_input_instantiationContext is an interface to support dynamic dispatch.
type IN_input_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_input_instantiationContext differentiates from other interfaces.
	IsN_input_instantiationContext()
}

type N_input_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_input_instantiationContext() *N_input_instantiationContext {
	var p = new(N_input_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_n_input_instantiation
	return p
}

func (*N_input_instantiationContext) IsN_input_instantiationContext() {}

func NewN_input_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_input_instantiationContext {
	var p = new(N_input_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_n_input_instantiation

	return p
}

func (s *N_input_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *N_input_instantiationContext) N_input_gatetype() IN_input_gatetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_input_gatetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_input_gatetypeContext)
}

func (s *N_input_instantiationContext) List_of_n_input_gate_instance() IList_of_n_input_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_n_input_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_n_input_gate_instanceContext)
}

func (s *N_input_instantiationContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *N_input_instantiationContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *N_input_instantiationContext) Delay() IDelayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelayContext)
}

func (s *N_input_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_input_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_input_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterN_input_instantiation(s)
	}
}

func (s *N_input_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitN_input_instantiation(s)
	}
}

func (p *SysVerilogHDLParser) N_input_instantiation() (localctx IN_input_instantiationContext) {
	localctx = NewN_input_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, SysVerilogHDLParserRULE_n_input_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1965)
		p.N_input_gatetype()
	}
	p.SetState(1967)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1966)
			p.Drive_strength()
		}

	}
	p.SetState(1970)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserHash {
		{
			p.SetState(1969)
			p.Delay()
		}

	}
	{
		p.SetState(1972)
		p.List_of_n_input_gate_instance()
	}
	{
		p.SetState(1973)
		p.Semicolon()
	}

	return localctx
}

// IPass_instantiationContext is an interface to support dynamic dispatch.
type IPass_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_instantiationContext differentiates from other interfaces.
	IsPass_instantiationContext()
}

type Pass_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_instantiationContext() *Pass_instantiationContext {
	var p = new(Pass_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_pass_instantiation
	return p
}

func (*Pass_instantiationContext) IsPass_instantiationContext() {}

func NewPass_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_instantiationContext {
	var p = new(Pass_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_pass_instantiation

	return p
}

func (s *Pass_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_instantiationContext) Pass_switchtype() IPass_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_switchtypeContext)
}

func (s *Pass_instantiationContext) List_of_pass_switch_instance() IList_of_pass_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_pass_switch_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_pass_switch_instanceContext)
}

func (s *Pass_instantiationContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Pass_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPass_instantiation(s)
	}
}

func (s *Pass_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPass_instantiation(s)
	}
}

func (p *SysVerilogHDLParser) Pass_instantiation() (localctx IPass_instantiationContext) {
	localctx = NewPass_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, SysVerilogHDLParserRULE_pass_instantiation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1975)
		p.Pass_switchtype()
	}
	{
		p.SetState(1976)
		p.List_of_pass_switch_instance()
	}
	{
		p.SetState(1977)
		p.Semicolon()
	}

	return localctx
}

// IPass_enable_instantiationContext is an interface to support dynamic dispatch.
type IPass_enable_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_enable_instantiationContext differentiates from other interfaces.
	IsPass_enable_instantiationContext()
}

type Pass_enable_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_enable_instantiationContext() *Pass_enable_instantiationContext {
	var p = new(Pass_enable_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_pass_enable_instantiation
	return p
}

func (*Pass_enable_instantiationContext) IsPass_enable_instantiationContext() {}

func NewPass_enable_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_enable_instantiationContext {
	var p = new(Pass_enable_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_pass_enable_instantiation

	return p
}

func (s *Pass_enable_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_enable_instantiationContext) Pass_enable_switchtype() IPass_enable_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_enable_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_enable_switchtypeContext)
}

func (s *Pass_enable_instantiationContext) List_of_pass_enable_switch_instance() IList_of_pass_enable_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_pass_enable_switch_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_pass_enable_switch_instanceContext)
}

func (s *Pass_enable_instantiationContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Pass_enable_instantiationContext) Delay() IDelayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelayContext)
}

func (s *Pass_enable_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_enable_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_enable_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPass_enable_instantiation(s)
	}
}

func (s *Pass_enable_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPass_enable_instantiation(s)
	}
}

func (p *SysVerilogHDLParser) Pass_enable_instantiation() (localctx IPass_enable_instantiationContext) {
	localctx = NewPass_enable_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, SysVerilogHDLParserRULE_pass_enable_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1979)
		p.Pass_enable_switchtype()
	}
	p.SetState(1981)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserHash {
		{
			p.SetState(1980)
			p.Delay()
		}

	}
	{
		p.SetState(1983)
		p.List_of_pass_enable_switch_instance()
	}
	{
		p.SetState(1984)
		p.Semicolon()
	}

	return localctx
}

// IList_of_pull_gate_instanceContext is an interface to support dynamic dispatch.
type IList_of_pull_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_pull_gate_instanceContext differentiates from other interfaces.
	IsList_of_pull_gate_instanceContext()
}

type List_of_pull_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_pull_gate_instanceContext() *List_of_pull_gate_instanceContext {
	var p = new(List_of_pull_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_pull_gate_instance
	return p
}

func (*List_of_pull_gate_instanceContext) IsList_of_pull_gate_instanceContext() {}

func NewList_of_pull_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_pull_gate_instanceContext {
	var p = new(List_of_pull_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_pull_gate_instance

	return p
}

func (s *List_of_pull_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_pull_gate_instanceContext) Pull_gate_instance() IPull_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPull_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPull_gate_instanceContext)
}

func (s *List_of_pull_gate_instanceContext) Comma_pull_gate_instance_star() IComma_pull_gate_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_pull_gate_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_pull_gate_instance_starContext)
}

func (s *List_of_pull_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_pull_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_pull_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_pull_gate_instance(s)
	}
}

func (s *List_of_pull_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_pull_gate_instance(s)
	}
}

func (p *SysVerilogHDLParser) List_of_pull_gate_instance() (localctx IList_of_pull_gate_instanceContext) {
	localctx = NewList_of_pull_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, SysVerilogHDLParserRULE_list_of_pull_gate_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1986)
		p.Pull_gate_instance()
	}
	{
		p.SetState(1987)
		p.Comma_pull_gate_instance_star()
	}

	return localctx
}

// IList_of_enable_gate_instanceContext is an interface to support dynamic dispatch.
type IList_of_enable_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_enable_gate_instanceContext differentiates from other interfaces.
	IsList_of_enable_gate_instanceContext()
}

type List_of_enable_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_enable_gate_instanceContext() *List_of_enable_gate_instanceContext {
	var p = new(List_of_enable_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_enable_gate_instance
	return p
}

func (*List_of_enable_gate_instanceContext) IsList_of_enable_gate_instanceContext() {}

func NewList_of_enable_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_enable_gate_instanceContext {
	var p = new(List_of_enable_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_enable_gate_instance

	return p
}

func (s *List_of_enable_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_enable_gate_instanceContext) Enable_gate_instance() IEnable_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_gate_instanceContext)
}

func (s *List_of_enable_gate_instanceContext) Comma_enable_gate_instance_star() IComma_enable_gate_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_enable_gate_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_enable_gate_instance_starContext)
}

func (s *List_of_enable_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_enable_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_enable_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_enable_gate_instance(s)
	}
}

func (s *List_of_enable_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_enable_gate_instance(s)
	}
}

func (p *SysVerilogHDLParser) List_of_enable_gate_instance() (localctx IList_of_enable_gate_instanceContext) {
	localctx = NewList_of_enable_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, SysVerilogHDLParserRULE_list_of_enable_gate_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1989)
		p.Enable_gate_instance()
	}
	{
		p.SetState(1990)
		p.Comma_enable_gate_instance_star()
	}

	return localctx
}

// IList_of_mos_switch_instanceContext is an interface to support dynamic dispatch.
type IList_of_mos_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_mos_switch_instanceContext differentiates from other interfaces.
	IsList_of_mos_switch_instanceContext()
}

type List_of_mos_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_mos_switch_instanceContext() *List_of_mos_switch_instanceContext {
	var p = new(List_of_mos_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_mos_switch_instance
	return p
}

func (*List_of_mos_switch_instanceContext) IsList_of_mos_switch_instanceContext() {}

func NewList_of_mos_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_mos_switch_instanceContext {
	var p = new(List_of_mos_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_mos_switch_instance

	return p
}

func (s *List_of_mos_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_mos_switch_instanceContext) Mos_switch_instance() IMos_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMos_switch_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMos_switch_instanceContext)
}

func (s *List_of_mos_switch_instanceContext) Comma_mos_switch_instance_star() IComma_mos_switch_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_mos_switch_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_mos_switch_instance_starContext)
}

func (s *List_of_mos_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_mos_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_mos_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_mos_switch_instance(s)
	}
}

func (s *List_of_mos_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_mos_switch_instance(s)
	}
}

func (p *SysVerilogHDLParser) List_of_mos_switch_instance() (localctx IList_of_mos_switch_instanceContext) {
	localctx = NewList_of_mos_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, SysVerilogHDLParserRULE_list_of_mos_switch_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1992)
		p.Mos_switch_instance()
	}
	{
		p.SetState(1993)
		p.Comma_mos_switch_instance_star()
	}

	return localctx
}

// IList_of_cmos_switch_instanceContext is an interface to support dynamic dispatch.
type IList_of_cmos_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_cmos_switch_instanceContext differentiates from other interfaces.
	IsList_of_cmos_switch_instanceContext()
}

type List_of_cmos_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_cmos_switch_instanceContext() *List_of_cmos_switch_instanceContext {
	var p = new(List_of_cmos_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_cmos_switch_instance
	return p
}

func (*List_of_cmos_switch_instanceContext) IsList_of_cmos_switch_instanceContext() {}

func NewList_of_cmos_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_cmos_switch_instanceContext {
	var p = new(List_of_cmos_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_cmos_switch_instance

	return p
}

func (s *List_of_cmos_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_cmos_switch_instanceContext) Cmos_switch_instance() ICmos_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmos_switch_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmos_switch_instanceContext)
}

func (s *List_of_cmos_switch_instanceContext) Comma_cmos_switch_instance_star() IComma_cmos_switch_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_cmos_switch_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_cmos_switch_instance_starContext)
}

func (s *List_of_cmos_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_cmos_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_cmos_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_cmos_switch_instance(s)
	}
}

func (s *List_of_cmos_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_cmos_switch_instance(s)
	}
}

func (p *SysVerilogHDLParser) List_of_cmos_switch_instance() (localctx IList_of_cmos_switch_instanceContext) {
	localctx = NewList_of_cmos_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, SysVerilogHDLParserRULE_list_of_cmos_switch_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1995)
		p.Cmos_switch_instance()
	}
	{
		p.SetState(1996)
		p.Comma_cmos_switch_instance_star()
	}

	return localctx
}

// IList_of_n_input_gate_instanceContext is an interface to support dynamic dispatch.
type IList_of_n_input_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_n_input_gate_instanceContext differentiates from other interfaces.
	IsList_of_n_input_gate_instanceContext()
}

type List_of_n_input_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_n_input_gate_instanceContext() *List_of_n_input_gate_instanceContext {
	var p = new(List_of_n_input_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_n_input_gate_instance
	return p
}

func (*List_of_n_input_gate_instanceContext) IsList_of_n_input_gate_instanceContext() {}

func NewList_of_n_input_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_n_input_gate_instanceContext {
	var p = new(List_of_n_input_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_n_input_gate_instance

	return p
}

func (s *List_of_n_input_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_n_input_gate_instanceContext) N_input_gate_instance() IN_input_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_input_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_input_gate_instanceContext)
}

func (s *List_of_n_input_gate_instanceContext) Comma_n_input_gate_instance_star() IComma_n_input_gate_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_n_input_gate_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_n_input_gate_instance_starContext)
}

func (s *List_of_n_input_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_n_input_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_n_input_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_n_input_gate_instance(s)
	}
}

func (s *List_of_n_input_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_n_input_gate_instance(s)
	}
}

func (p *SysVerilogHDLParser) List_of_n_input_gate_instance() (localctx IList_of_n_input_gate_instanceContext) {
	localctx = NewList_of_n_input_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, SysVerilogHDLParserRULE_list_of_n_input_gate_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1998)
		p.N_input_gate_instance()
	}
	{
		p.SetState(1999)
		p.Comma_n_input_gate_instance_star()
	}

	return localctx
}

// IList_of_n_output_gate_instanceContext is an interface to support dynamic dispatch.
type IList_of_n_output_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_n_output_gate_instanceContext differentiates from other interfaces.
	IsList_of_n_output_gate_instanceContext()
}

type List_of_n_output_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_n_output_gate_instanceContext() *List_of_n_output_gate_instanceContext {
	var p = new(List_of_n_output_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_n_output_gate_instance
	return p
}

func (*List_of_n_output_gate_instanceContext) IsList_of_n_output_gate_instanceContext() {}

func NewList_of_n_output_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_n_output_gate_instanceContext {
	var p = new(List_of_n_output_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_n_output_gate_instance

	return p
}

func (s *List_of_n_output_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_n_output_gate_instanceContext) N_output_gate_instance() IN_output_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_output_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_output_gate_instanceContext)
}

func (s *List_of_n_output_gate_instanceContext) Comma_n_output_gate_instance_star() IComma_n_output_gate_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_n_output_gate_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_n_output_gate_instance_starContext)
}

func (s *List_of_n_output_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_n_output_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_n_output_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_n_output_gate_instance(s)
	}
}

func (s *List_of_n_output_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_n_output_gate_instance(s)
	}
}

func (p *SysVerilogHDLParser) List_of_n_output_gate_instance() (localctx IList_of_n_output_gate_instanceContext) {
	localctx = NewList_of_n_output_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, SysVerilogHDLParserRULE_list_of_n_output_gate_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2001)
		p.N_output_gate_instance()
	}
	{
		p.SetState(2002)
		p.Comma_n_output_gate_instance_star()
	}

	return localctx
}

// IList_of_pass_switch_instanceContext is an interface to support dynamic dispatch.
type IList_of_pass_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_pass_switch_instanceContext differentiates from other interfaces.
	IsList_of_pass_switch_instanceContext()
}

type List_of_pass_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_pass_switch_instanceContext() *List_of_pass_switch_instanceContext {
	var p = new(List_of_pass_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_pass_switch_instance
	return p
}

func (*List_of_pass_switch_instanceContext) IsList_of_pass_switch_instanceContext() {}

func NewList_of_pass_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_pass_switch_instanceContext {
	var p = new(List_of_pass_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_pass_switch_instance

	return p
}

func (s *List_of_pass_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_pass_switch_instanceContext) Pass_switch_instance() IPass_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_switch_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_switch_instanceContext)
}

func (s *List_of_pass_switch_instanceContext) Comma_pass_switch_instance_star() IComma_pass_switch_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_pass_switch_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_pass_switch_instance_starContext)
}

func (s *List_of_pass_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_pass_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_pass_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_pass_switch_instance(s)
	}
}

func (s *List_of_pass_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_pass_switch_instance(s)
	}
}

func (p *SysVerilogHDLParser) List_of_pass_switch_instance() (localctx IList_of_pass_switch_instanceContext) {
	localctx = NewList_of_pass_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, SysVerilogHDLParserRULE_list_of_pass_switch_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2004)
		p.Pass_switch_instance()
	}
	{
		p.SetState(2005)
		p.Comma_pass_switch_instance_star()
	}

	return localctx
}

// IList_of_pass_enable_switch_instanceContext is an interface to support dynamic dispatch.
type IList_of_pass_enable_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_pass_enable_switch_instanceContext differentiates from other interfaces.
	IsList_of_pass_enable_switch_instanceContext()
}

type List_of_pass_enable_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_pass_enable_switch_instanceContext() *List_of_pass_enable_switch_instanceContext {
	var p = new(List_of_pass_enable_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_pass_enable_switch_instance
	return p
}

func (*List_of_pass_enable_switch_instanceContext) IsList_of_pass_enable_switch_instanceContext() {}

func NewList_of_pass_enable_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_pass_enable_switch_instanceContext {
	var p = new(List_of_pass_enable_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_pass_enable_switch_instance

	return p
}

func (s *List_of_pass_enable_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_pass_enable_switch_instanceContext) Pass_enable_switch_instance() IPass_enable_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_enable_switch_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_enable_switch_instanceContext)
}

func (s *List_of_pass_enable_switch_instanceContext) Comma_pass_enable_switch_instance_star() IComma_pass_enable_switch_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_pass_enable_switch_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_pass_enable_switch_instance_starContext)
}

func (s *List_of_pass_enable_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_pass_enable_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_pass_enable_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_pass_enable_switch_instance(s)
	}
}

func (s *List_of_pass_enable_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_pass_enable_switch_instance(s)
	}
}

func (p *SysVerilogHDLParser) List_of_pass_enable_switch_instance() (localctx IList_of_pass_enable_switch_instanceContext) {
	localctx = NewList_of_pass_enable_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, SysVerilogHDLParserRULE_list_of_pass_enable_switch_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2007)
		p.Pass_enable_switch_instance()
	}
	{
		p.SetState(2008)
		p.Comma_pass_enable_switch_instance_star()
	}

	return localctx
}

// IComma_pull_gate_instance_starContext is an interface to support dynamic dispatch.
type IComma_pull_gate_instance_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_pull_gate_instance_starContext differentiates from other interfaces.
	IsComma_pull_gate_instance_starContext()
}

type Comma_pull_gate_instance_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_pull_gate_instance_starContext() *Comma_pull_gate_instance_starContext {
	var p = new(Comma_pull_gate_instance_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_pull_gate_instance_star
	return p
}

func (*Comma_pull_gate_instance_starContext) IsComma_pull_gate_instance_starContext() {}

func NewComma_pull_gate_instance_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_pull_gate_instance_starContext {
	var p = new(Comma_pull_gate_instance_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_pull_gate_instance_star

	return p
}

func (s *Comma_pull_gate_instance_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_pull_gate_instance_starContext) AllComma_pull_gate_instance() []IComma_pull_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_pull_gate_instanceContext)(nil)).Elem())
	var tst = make([]IComma_pull_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_pull_gate_instanceContext)
		}
	}

	return tst
}

func (s *Comma_pull_gate_instance_starContext) Comma_pull_gate_instance(i int) IComma_pull_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_pull_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_pull_gate_instanceContext)
}

func (s *Comma_pull_gate_instance_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_pull_gate_instance_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_pull_gate_instance_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_pull_gate_instance_star(s)
	}
}

func (s *Comma_pull_gate_instance_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_pull_gate_instance_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_pull_gate_instance_star() (localctx IComma_pull_gate_instance_starContext) {
	localctx = NewComma_pull_gate_instance_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, SysVerilogHDLParserRULE_comma_pull_gate_instance_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2013)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(2010)
			p.Comma_pull_gate_instance()
		}

		p.SetState(2015)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_enable_gate_instance_starContext is an interface to support dynamic dispatch.
type IComma_enable_gate_instance_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_enable_gate_instance_starContext differentiates from other interfaces.
	IsComma_enable_gate_instance_starContext()
}

type Comma_enable_gate_instance_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_enable_gate_instance_starContext() *Comma_enable_gate_instance_starContext {
	var p = new(Comma_enable_gate_instance_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_enable_gate_instance_star
	return p
}

func (*Comma_enable_gate_instance_starContext) IsComma_enable_gate_instance_starContext() {}

func NewComma_enable_gate_instance_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_enable_gate_instance_starContext {
	var p = new(Comma_enable_gate_instance_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_enable_gate_instance_star

	return p
}

func (s *Comma_enable_gate_instance_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_enable_gate_instance_starContext) AllComma_enable_gate_instance() []IComma_enable_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_enable_gate_instanceContext)(nil)).Elem())
	var tst = make([]IComma_enable_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_enable_gate_instanceContext)
		}
	}

	return tst
}

func (s *Comma_enable_gate_instance_starContext) Comma_enable_gate_instance(i int) IComma_enable_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_enable_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_enable_gate_instanceContext)
}

func (s *Comma_enable_gate_instance_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_enable_gate_instance_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_enable_gate_instance_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_enable_gate_instance_star(s)
	}
}

func (s *Comma_enable_gate_instance_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_enable_gate_instance_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_enable_gate_instance_star() (localctx IComma_enable_gate_instance_starContext) {
	localctx = NewComma_enable_gate_instance_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, SysVerilogHDLParserRULE_comma_enable_gate_instance_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2019)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(2016)
			p.Comma_enable_gate_instance()
		}

		p.SetState(2021)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_mos_switch_instance_starContext is an interface to support dynamic dispatch.
type IComma_mos_switch_instance_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_mos_switch_instance_starContext differentiates from other interfaces.
	IsComma_mos_switch_instance_starContext()
}

type Comma_mos_switch_instance_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_mos_switch_instance_starContext() *Comma_mos_switch_instance_starContext {
	var p = new(Comma_mos_switch_instance_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_mos_switch_instance_star
	return p
}

func (*Comma_mos_switch_instance_starContext) IsComma_mos_switch_instance_starContext() {}

func NewComma_mos_switch_instance_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_mos_switch_instance_starContext {
	var p = new(Comma_mos_switch_instance_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_mos_switch_instance_star

	return p
}

func (s *Comma_mos_switch_instance_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_mos_switch_instance_starContext) AllComma_mos_switch_instance() []IComma_mos_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_mos_switch_instanceContext)(nil)).Elem())
	var tst = make([]IComma_mos_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_mos_switch_instanceContext)
		}
	}

	return tst
}

func (s *Comma_mos_switch_instance_starContext) Comma_mos_switch_instance(i int) IComma_mos_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_mos_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_mos_switch_instanceContext)
}

func (s *Comma_mos_switch_instance_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_mos_switch_instance_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_mos_switch_instance_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_mos_switch_instance_star(s)
	}
}

func (s *Comma_mos_switch_instance_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_mos_switch_instance_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_mos_switch_instance_star() (localctx IComma_mos_switch_instance_starContext) {
	localctx = NewComma_mos_switch_instance_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, SysVerilogHDLParserRULE_comma_mos_switch_instance_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2025)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(2022)
			p.Comma_mos_switch_instance()
		}

		p.SetState(2027)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_cmos_switch_instance_starContext is an interface to support dynamic dispatch.
type IComma_cmos_switch_instance_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_cmos_switch_instance_starContext differentiates from other interfaces.
	IsComma_cmos_switch_instance_starContext()
}

type Comma_cmos_switch_instance_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_cmos_switch_instance_starContext() *Comma_cmos_switch_instance_starContext {
	var p = new(Comma_cmos_switch_instance_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_cmos_switch_instance_star
	return p
}

func (*Comma_cmos_switch_instance_starContext) IsComma_cmos_switch_instance_starContext() {}

func NewComma_cmos_switch_instance_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_cmos_switch_instance_starContext {
	var p = new(Comma_cmos_switch_instance_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_cmos_switch_instance_star

	return p
}

func (s *Comma_cmos_switch_instance_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_cmos_switch_instance_starContext) AllComma_cmos_switch_instance() []IComma_cmos_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_cmos_switch_instanceContext)(nil)).Elem())
	var tst = make([]IComma_cmos_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_cmos_switch_instanceContext)
		}
	}

	return tst
}

func (s *Comma_cmos_switch_instance_starContext) Comma_cmos_switch_instance(i int) IComma_cmos_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_cmos_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_cmos_switch_instanceContext)
}

func (s *Comma_cmos_switch_instance_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_cmos_switch_instance_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_cmos_switch_instance_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_cmos_switch_instance_star(s)
	}
}

func (s *Comma_cmos_switch_instance_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_cmos_switch_instance_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_cmos_switch_instance_star() (localctx IComma_cmos_switch_instance_starContext) {
	localctx = NewComma_cmos_switch_instance_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, SysVerilogHDLParserRULE_comma_cmos_switch_instance_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2031)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(2028)
			p.Comma_cmos_switch_instance()
		}

		p.SetState(2033)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_n_input_gate_instance_starContext is an interface to support dynamic dispatch.
type IComma_n_input_gate_instance_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_n_input_gate_instance_starContext differentiates from other interfaces.
	IsComma_n_input_gate_instance_starContext()
}

type Comma_n_input_gate_instance_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_n_input_gate_instance_starContext() *Comma_n_input_gate_instance_starContext {
	var p = new(Comma_n_input_gate_instance_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_n_input_gate_instance_star
	return p
}

func (*Comma_n_input_gate_instance_starContext) IsComma_n_input_gate_instance_starContext() {}

func NewComma_n_input_gate_instance_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_n_input_gate_instance_starContext {
	var p = new(Comma_n_input_gate_instance_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_n_input_gate_instance_star

	return p
}

func (s *Comma_n_input_gate_instance_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_n_input_gate_instance_starContext) AllComma_n_input_gate_instance() []IComma_n_input_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_n_input_gate_instanceContext)(nil)).Elem())
	var tst = make([]IComma_n_input_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_n_input_gate_instanceContext)
		}
	}

	return tst
}

func (s *Comma_n_input_gate_instance_starContext) Comma_n_input_gate_instance(i int) IComma_n_input_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_n_input_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_n_input_gate_instanceContext)
}

func (s *Comma_n_input_gate_instance_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_n_input_gate_instance_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_n_input_gate_instance_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_n_input_gate_instance_star(s)
	}
}

func (s *Comma_n_input_gate_instance_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_n_input_gate_instance_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_n_input_gate_instance_star() (localctx IComma_n_input_gate_instance_starContext) {
	localctx = NewComma_n_input_gate_instance_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, SysVerilogHDLParserRULE_comma_n_input_gate_instance_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2037)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(2034)
			p.Comma_n_input_gate_instance()
		}

		p.SetState(2039)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_n_output_gate_instance_starContext is an interface to support dynamic dispatch.
type IComma_n_output_gate_instance_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_n_output_gate_instance_starContext differentiates from other interfaces.
	IsComma_n_output_gate_instance_starContext()
}

type Comma_n_output_gate_instance_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_n_output_gate_instance_starContext() *Comma_n_output_gate_instance_starContext {
	var p = new(Comma_n_output_gate_instance_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_n_output_gate_instance_star
	return p
}

func (*Comma_n_output_gate_instance_starContext) IsComma_n_output_gate_instance_starContext() {}

func NewComma_n_output_gate_instance_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_n_output_gate_instance_starContext {
	var p = new(Comma_n_output_gate_instance_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_n_output_gate_instance_star

	return p
}

func (s *Comma_n_output_gate_instance_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_n_output_gate_instance_starContext) AllComma_n_output_gate_instance() []IComma_n_output_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_n_output_gate_instanceContext)(nil)).Elem())
	var tst = make([]IComma_n_output_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_n_output_gate_instanceContext)
		}
	}

	return tst
}

func (s *Comma_n_output_gate_instance_starContext) Comma_n_output_gate_instance(i int) IComma_n_output_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_n_output_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_n_output_gate_instanceContext)
}

func (s *Comma_n_output_gate_instance_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_n_output_gate_instance_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_n_output_gate_instance_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_n_output_gate_instance_star(s)
	}
}

func (s *Comma_n_output_gate_instance_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_n_output_gate_instance_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_n_output_gate_instance_star() (localctx IComma_n_output_gate_instance_starContext) {
	localctx = NewComma_n_output_gate_instance_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, SysVerilogHDLParserRULE_comma_n_output_gate_instance_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2043)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(2040)
			p.Comma_n_output_gate_instance()
		}

		p.SetState(2045)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_pass_switch_instance_starContext is an interface to support dynamic dispatch.
type IComma_pass_switch_instance_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_pass_switch_instance_starContext differentiates from other interfaces.
	IsComma_pass_switch_instance_starContext()
}

type Comma_pass_switch_instance_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_pass_switch_instance_starContext() *Comma_pass_switch_instance_starContext {
	var p = new(Comma_pass_switch_instance_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_pass_switch_instance_star
	return p
}

func (*Comma_pass_switch_instance_starContext) IsComma_pass_switch_instance_starContext() {}

func NewComma_pass_switch_instance_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_pass_switch_instance_starContext {
	var p = new(Comma_pass_switch_instance_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_pass_switch_instance_star

	return p
}

func (s *Comma_pass_switch_instance_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_pass_switch_instance_starContext) AllComma_pass_switch_instance() []IComma_pass_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_pass_switch_instanceContext)(nil)).Elem())
	var tst = make([]IComma_pass_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_pass_switch_instanceContext)
		}
	}

	return tst
}

func (s *Comma_pass_switch_instance_starContext) Comma_pass_switch_instance(i int) IComma_pass_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_pass_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_pass_switch_instanceContext)
}

func (s *Comma_pass_switch_instance_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_pass_switch_instance_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_pass_switch_instance_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_pass_switch_instance_star(s)
	}
}

func (s *Comma_pass_switch_instance_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_pass_switch_instance_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_pass_switch_instance_star() (localctx IComma_pass_switch_instance_starContext) {
	localctx = NewComma_pass_switch_instance_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, SysVerilogHDLParserRULE_comma_pass_switch_instance_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2049)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(2046)
			p.Comma_pass_switch_instance()
		}

		p.SetState(2051)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_pass_enable_switch_instance_starContext is an interface to support dynamic dispatch.
type IComma_pass_enable_switch_instance_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_pass_enable_switch_instance_starContext differentiates from other interfaces.
	IsComma_pass_enable_switch_instance_starContext()
}

type Comma_pass_enable_switch_instance_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_pass_enable_switch_instance_starContext() *Comma_pass_enable_switch_instance_starContext {
	var p = new(Comma_pass_enable_switch_instance_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_pass_enable_switch_instance_star
	return p
}

func (*Comma_pass_enable_switch_instance_starContext) IsComma_pass_enable_switch_instance_starContext() {
}

func NewComma_pass_enable_switch_instance_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_pass_enable_switch_instance_starContext {
	var p = new(Comma_pass_enable_switch_instance_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_pass_enable_switch_instance_star

	return p
}

func (s *Comma_pass_enable_switch_instance_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_pass_enable_switch_instance_starContext) AllComma_pass_enable_switch_instance() []IComma_pass_enable_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_pass_enable_switch_instanceContext)(nil)).Elem())
	var tst = make([]IComma_pass_enable_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_pass_enable_switch_instanceContext)
		}
	}

	return tst
}

func (s *Comma_pass_enable_switch_instance_starContext) Comma_pass_enable_switch_instance(i int) IComma_pass_enable_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_pass_enable_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_pass_enable_switch_instanceContext)
}

func (s *Comma_pass_enable_switch_instance_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_pass_enable_switch_instance_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_pass_enable_switch_instance_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_pass_enable_switch_instance_star(s)
	}
}

func (s *Comma_pass_enable_switch_instance_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_pass_enable_switch_instance_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_pass_enable_switch_instance_star() (localctx IComma_pass_enable_switch_instance_starContext) {
	localctx = NewComma_pass_enable_switch_instance_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, SysVerilogHDLParserRULE_comma_pass_enable_switch_instance_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2055)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(2052)
			p.Comma_pass_enable_switch_instance()
		}

		p.SetState(2057)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_pull_gate_instanceContext is an interface to support dynamic dispatch.
type IComma_pull_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_pull_gate_instanceContext differentiates from other interfaces.
	IsComma_pull_gate_instanceContext()
}

type Comma_pull_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_pull_gate_instanceContext() *Comma_pull_gate_instanceContext {
	var p = new(Comma_pull_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_pull_gate_instance
	return p
}

func (*Comma_pull_gate_instanceContext) IsComma_pull_gate_instanceContext() {}

func NewComma_pull_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_pull_gate_instanceContext {
	var p = new(Comma_pull_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_pull_gate_instance

	return p
}

func (s *Comma_pull_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_pull_gate_instanceContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_pull_gate_instanceContext) Pull_gate_instance() IPull_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPull_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPull_gate_instanceContext)
}

func (s *Comma_pull_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_pull_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_pull_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_pull_gate_instance(s)
	}
}

func (s *Comma_pull_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_pull_gate_instance(s)
	}
}

func (p *SysVerilogHDLParser) Comma_pull_gate_instance() (localctx IComma_pull_gate_instanceContext) {
	localctx = NewComma_pull_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, SysVerilogHDLParserRULE_comma_pull_gate_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2058)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2059)
		p.Pull_gate_instance()
	}

	return localctx
}

// IComma_enable_gate_instanceContext is an interface to support dynamic dispatch.
type IComma_enable_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_enable_gate_instanceContext differentiates from other interfaces.
	IsComma_enable_gate_instanceContext()
}

type Comma_enable_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_enable_gate_instanceContext() *Comma_enable_gate_instanceContext {
	var p = new(Comma_enable_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_enable_gate_instance
	return p
}

func (*Comma_enable_gate_instanceContext) IsComma_enable_gate_instanceContext() {}

func NewComma_enable_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_enable_gate_instanceContext {
	var p = new(Comma_enable_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_enable_gate_instance

	return p
}

func (s *Comma_enable_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_enable_gate_instanceContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_enable_gate_instanceContext) Enable_gate_instance() IEnable_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_gate_instanceContext)
}

func (s *Comma_enable_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_enable_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_enable_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_enable_gate_instance(s)
	}
}

func (s *Comma_enable_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_enable_gate_instance(s)
	}
}

func (p *SysVerilogHDLParser) Comma_enable_gate_instance() (localctx IComma_enable_gate_instanceContext) {
	localctx = NewComma_enable_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, SysVerilogHDLParserRULE_comma_enable_gate_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2061)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2062)
		p.Enable_gate_instance()
	}

	return localctx
}

// IComma_mos_switch_instanceContext is an interface to support dynamic dispatch.
type IComma_mos_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_mos_switch_instanceContext differentiates from other interfaces.
	IsComma_mos_switch_instanceContext()
}

type Comma_mos_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_mos_switch_instanceContext() *Comma_mos_switch_instanceContext {
	var p = new(Comma_mos_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_mos_switch_instance
	return p
}

func (*Comma_mos_switch_instanceContext) IsComma_mos_switch_instanceContext() {}

func NewComma_mos_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_mos_switch_instanceContext {
	var p = new(Comma_mos_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_mos_switch_instance

	return p
}

func (s *Comma_mos_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_mos_switch_instanceContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_mos_switch_instanceContext) Mos_switch_instance() IMos_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMos_switch_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMos_switch_instanceContext)
}

func (s *Comma_mos_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_mos_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_mos_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_mos_switch_instance(s)
	}
}

func (s *Comma_mos_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_mos_switch_instance(s)
	}
}

func (p *SysVerilogHDLParser) Comma_mos_switch_instance() (localctx IComma_mos_switch_instanceContext) {
	localctx = NewComma_mos_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, SysVerilogHDLParserRULE_comma_mos_switch_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2064)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2065)
		p.Mos_switch_instance()
	}

	return localctx
}

// IComma_cmos_switch_instanceContext is an interface to support dynamic dispatch.
type IComma_cmos_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_cmos_switch_instanceContext differentiates from other interfaces.
	IsComma_cmos_switch_instanceContext()
}

type Comma_cmos_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_cmos_switch_instanceContext() *Comma_cmos_switch_instanceContext {
	var p = new(Comma_cmos_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_cmos_switch_instance
	return p
}

func (*Comma_cmos_switch_instanceContext) IsComma_cmos_switch_instanceContext() {}

func NewComma_cmos_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_cmos_switch_instanceContext {
	var p = new(Comma_cmos_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_cmos_switch_instance

	return p
}

func (s *Comma_cmos_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_cmos_switch_instanceContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_cmos_switch_instanceContext) Cmos_switch_instance() ICmos_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmos_switch_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmos_switch_instanceContext)
}

func (s *Comma_cmos_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_cmos_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_cmos_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_cmos_switch_instance(s)
	}
}

func (s *Comma_cmos_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_cmos_switch_instance(s)
	}
}

func (p *SysVerilogHDLParser) Comma_cmos_switch_instance() (localctx IComma_cmos_switch_instanceContext) {
	localctx = NewComma_cmos_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, SysVerilogHDLParserRULE_comma_cmos_switch_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2067)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2068)
		p.Cmos_switch_instance()
	}

	return localctx
}

// IComma_n_input_gate_instanceContext is an interface to support dynamic dispatch.
type IComma_n_input_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_n_input_gate_instanceContext differentiates from other interfaces.
	IsComma_n_input_gate_instanceContext()
}

type Comma_n_input_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_n_input_gate_instanceContext() *Comma_n_input_gate_instanceContext {
	var p = new(Comma_n_input_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_n_input_gate_instance
	return p
}

func (*Comma_n_input_gate_instanceContext) IsComma_n_input_gate_instanceContext() {}

func NewComma_n_input_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_n_input_gate_instanceContext {
	var p = new(Comma_n_input_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_n_input_gate_instance

	return p
}

func (s *Comma_n_input_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_n_input_gate_instanceContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_n_input_gate_instanceContext) N_input_gate_instance() IN_input_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_input_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_input_gate_instanceContext)
}

func (s *Comma_n_input_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_n_input_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_n_input_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_n_input_gate_instance(s)
	}
}

func (s *Comma_n_input_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_n_input_gate_instance(s)
	}
}

func (p *SysVerilogHDLParser) Comma_n_input_gate_instance() (localctx IComma_n_input_gate_instanceContext) {
	localctx = NewComma_n_input_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, SysVerilogHDLParserRULE_comma_n_input_gate_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2070)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2071)
		p.N_input_gate_instance()
	}

	return localctx
}

// IComma_n_output_gate_instanceContext is an interface to support dynamic dispatch.
type IComma_n_output_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_n_output_gate_instanceContext differentiates from other interfaces.
	IsComma_n_output_gate_instanceContext()
}

type Comma_n_output_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_n_output_gate_instanceContext() *Comma_n_output_gate_instanceContext {
	var p = new(Comma_n_output_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_n_output_gate_instance
	return p
}

func (*Comma_n_output_gate_instanceContext) IsComma_n_output_gate_instanceContext() {}

func NewComma_n_output_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_n_output_gate_instanceContext {
	var p = new(Comma_n_output_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_n_output_gate_instance

	return p
}

func (s *Comma_n_output_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_n_output_gate_instanceContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_n_output_gate_instanceContext) N_output_gate_instance() IN_output_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_output_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_output_gate_instanceContext)
}

func (s *Comma_n_output_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_n_output_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_n_output_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_n_output_gate_instance(s)
	}
}

func (s *Comma_n_output_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_n_output_gate_instance(s)
	}
}

func (p *SysVerilogHDLParser) Comma_n_output_gate_instance() (localctx IComma_n_output_gate_instanceContext) {
	localctx = NewComma_n_output_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, SysVerilogHDLParserRULE_comma_n_output_gate_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2073)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2074)
		p.N_output_gate_instance()
	}

	return localctx
}

// IComma_pass_switch_instanceContext is an interface to support dynamic dispatch.
type IComma_pass_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_pass_switch_instanceContext differentiates from other interfaces.
	IsComma_pass_switch_instanceContext()
}

type Comma_pass_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_pass_switch_instanceContext() *Comma_pass_switch_instanceContext {
	var p = new(Comma_pass_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_pass_switch_instance
	return p
}

func (*Comma_pass_switch_instanceContext) IsComma_pass_switch_instanceContext() {}

func NewComma_pass_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_pass_switch_instanceContext {
	var p = new(Comma_pass_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_pass_switch_instance

	return p
}

func (s *Comma_pass_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_pass_switch_instanceContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_pass_switch_instanceContext) Pass_switch_instance() IPass_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_switch_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_switch_instanceContext)
}

func (s *Comma_pass_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_pass_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_pass_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_pass_switch_instance(s)
	}
}

func (s *Comma_pass_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_pass_switch_instance(s)
	}
}

func (p *SysVerilogHDLParser) Comma_pass_switch_instance() (localctx IComma_pass_switch_instanceContext) {
	localctx = NewComma_pass_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, SysVerilogHDLParserRULE_comma_pass_switch_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2076)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2077)
		p.Pass_switch_instance()
	}

	return localctx
}

// IComma_pass_enable_switch_instanceContext is an interface to support dynamic dispatch.
type IComma_pass_enable_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_pass_enable_switch_instanceContext differentiates from other interfaces.
	IsComma_pass_enable_switch_instanceContext()
}

type Comma_pass_enable_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_pass_enable_switch_instanceContext() *Comma_pass_enable_switch_instanceContext {
	var p = new(Comma_pass_enable_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_pass_enable_switch_instance
	return p
}

func (*Comma_pass_enable_switch_instanceContext) IsComma_pass_enable_switch_instanceContext() {}

func NewComma_pass_enable_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_pass_enable_switch_instanceContext {
	var p = new(Comma_pass_enable_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_pass_enable_switch_instance

	return p
}

func (s *Comma_pass_enable_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_pass_enable_switch_instanceContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_pass_enable_switch_instanceContext) Pass_enable_switch_instance() IPass_enable_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_enable_switch_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_enable_switch_instanceContext)
}

func (s *Comma_pass_enable_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_pass_enable_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_pass_enable_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_pass_enable_switch_instance(s)
	}
}

func (s *Comma_pass_enable_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_pass_enable_switch_instance(s)
	}
}

func (p *SysVerilogHDLParser) Comma_pass_enable_switch_instance() (localctx IComma_pass_enable_switch_instanceContext) {
	localctx = NewComma_pass_enable_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, SysVerilogHDLParserRULE_comma_pass_enable_switch_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2079)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2080)
		p.Pass_enable_switch_instance()
	}

	return localctx
}

// IPull_gate_instanceContext is an interface to support dynamic dispatch.
type IPull_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPull_gate_instanceContext differentiates from other interfaces.
	IsPull_gate_instanceContext()
}

type Pull_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPull_gate_instanceContext() *Pull_gate_instanceContext {
	var p = new(Pull_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_pull_gate_instance
	return p
}

func (*Pull_gate_instanceContext) IsPull_gate_instanceContext() {}

func NewPull_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pull_gate_instanceContext {
	var p = new(Pull_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_pull_gate_instance

	return p
}

func (s *Pull_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pull_gate_instanceContext) Pull_gate_interface() IPull_gate_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPull_gate_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPull_gate_interfaceContext)
}

func (s *Pull_gate_instanceContext) Gate_instance_identifier() IGate_instance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGate_instance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGate_instance_identifierContext)
}

func (s *Pull_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pull_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pull_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPull_gate_instance(s)
	}
}

func (s *Pull_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPull_gate_instance(s)
	}
}

func (p *SysVerilogHDLParser) Pull_gate_instance() (localctx IPull_gate_instanceContext) {
	localctx = NewPull_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, SysVerilogHDLParserRULE_pull_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2083)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserEscaped_identifier || _la == SysVerilogHDLParserSimple_identifier {
		{
			p.SetState(2082)
			p.Gate_instance_identifier()
		}

	}
	{
		p.SetState(2085)
		p.Pull_gate_interface()
	}

	return localctx
}

// IEnable_gate_instanceContext is an interface to support dynamic dispatch.
type IEnable_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_gate_instanceContext differentiates from other interfaces.
	IsEnable_gate_instanceContext()
}

type Enable_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_gate_instanceContext() *Enable_gate_instanceContext {
	var p = new(Enable_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_enable_gate_instance
	return p
}

func (*Enable_gate_instanceContext) IsEnable_gate_instanceContext() {}

func NewEnable_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_gate_instanceContext {
	var p = new(Enable_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_enable_gate_instance

	return p
}

func (s *Enable_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_gate_instanceContext) Enable_gate_interface() IEnable_gate_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_gate_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_gate_interfaceContext)
}

func (s *Enable_gate_instanceContext) Gate_instance_identifier() IGate_instance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGate_instance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGate_instance_identifierContext)
}

func (s *Enable_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEnable_gate_instance(s)
	}
}

func (s *Enable_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEnable_gate_instance(s)
	}
}

func (p *SysVerilogHDLParser) Enable_gate_instance() (localctx IEnable_gate_instanceContext) {
	localctx = NewEnable_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, SysVerilogHDLParserRULE_enable_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2088)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserEscaped_identifier || _la == SysVerilogHDLParserSimple_identifier {
		{
			p.SetState(2087)
			p.Gate_instance_identifier()
		}

	}
	{
		p.SetState(2090)
		p.Enable_gate_interface()
	}

	return localctx
}

// IMos_switch_instanceContext is an interface to support dynamic dispatch.
type IMos_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMos_switch_instanceContext differentiates from other interfaces.
	IsMos_switch_instanceContext()
}

type Mos_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMos_switch_instanceContext() *Mos_switch_instanceContext {
	var p = new(Mos_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_mos_switch_instance
	return p
}

func (*Mos_switch_instanceContext) IsMos_switch_instanceContext() {}

func NewMos_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mos_switch_instanceContext {
	var p = new(Mos_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_mos_switch_instance

	return p
}

func (s *Mos_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Mos_switch_instanceContext) Mos_switch_interface() IMos_switch_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMos_switch_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMos_switch_interfaceContext)
}

func (s *Mos_switch_instanceContext) Gate_instance_identifier() IGate_instance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGate_instance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGate_instance_identifierContext)
}

func (s *Mos_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mos_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mos_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterMos_switch_instance(s)
	}
}

func (s *Mos_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitMos_switch_instance(s)
	}
}

func (p *SysVerilogHDLParser) Mos_switch_instance() (localctx IMos_switch_instanceContext) {
	localctx = NewMos_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, SysVerilogHDLParserRULE_mos_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2093)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserEscaped_identifier || _la == SysVerilogHDLParserSimple_identifier {
		{
			p.SetState(2092)
			p.Gate_instance_identifier()
		}

	}
	{
		p.SetState(2095)
		p.Mos_switch_interface()
	}

	return localctx
}

// ICmos_switch_instanceContext is an interface to support dynamic dispatch.
type ICmos_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmos_switch_instanceContext differentiates from other interfaces.
	IsCmos_switch_instanceContext()
}

type Cmos_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmos_switch_instanceContext() *Cmos_switch_instanceContext {
	var p = new(Cmos_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_cmos_switch_instance
	return p
}

func (*Cmos_switch_instanceContext) IsCmos_switch_instanceContext() {}

func NewCmos_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmos_switch_instanceContext {
	var p = new(Cmos_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_cmos_switch_instance

	return p
}

func (s *Cmos_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmos_switch_instanceContext) Cmos_switch_interface() ICmos_switch_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmos_switch_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmos_switch_interfaceContext)
}

func (s *Cmos_switch_instanceContext) Gate_instance_identifier() IGate_instance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGate_instance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGate_instance_identifierContext)
}

func (s *Cmos_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmos_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmos_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterCmos_switch_instance(s)
	}
}

func (s *Cmos_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitCmos_switch_instance(s)
	}
}

func (p *SysVerilogHDLParser) Cmos_switch_instance() (localctx ICmos_switch_instanceContext) {
	localctx = NewCmos_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, SysVerilogHDLParserRULE_cmos_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2098)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserEscaped_identifier || _la == SysVerilogHDLParserSimple_identifier {
		{
			p.SetState(2097)
			p.Gate_instance_identifier()
		}

	}
	{
		p.SetState(2100)
		p.Cmos_switch_interface()
	}

	return localctx
}

// IN_input_gate_instanceContext is an interface to support dynamic dispatch.
type IN_input_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_input_gate_instanceContext differentiates from other interfaces.
	IsN_input_gate_instanceContext()
}

type N_input_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_input_gate_instanceContext() *N_input_gate_instanceContext {
	var p = new(N_input_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_n_input_gate_instance
	return p
}

func (*N_input_gate_instanceContext) IsN_input_gate_instanceContext() {}

func NewN_input_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_input_gate_instanceContext {
	var p = new(N_input_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_n_input_gate_instance

	return p
}

func (s *N_input_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *N_input_gate_instanceContext) N_input_gate_interface() IN_input_gate_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_input_gate_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_input_gate_interfaceContext)
}

func (s *N_input_gate_instanceContext) Gate_instance_identifier() IGate_instance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGate_instance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGate_instance_identifierContext)
}

func (s *N_input_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_input_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_input_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterN_input_gate_instance(s)
	}
}

func (s *N_input_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitN_input_gate_instance(s)
	}
}

func (p *SysVerilogHDLParser) N_input_gate_instance() (localctx IN_input_gate_instanceContext) {
	localctx = NewN_input_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, SysVerilogHDLParserRULE_n_input_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2103)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserEscaped_identifier || _la == SysVerilogHDLParserSimple_identifier {
		{
			p.SetState(2102)
			p.Gate_instance_identifier()
		}

	}
	{
		p.SetState(2105)
		p.N_input_gate_interface()
	}

	return localctx
}

// IN_output_gate_instanceContext is an interface to support dynamic dispatch.
type IN_output_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_output_gate_instanceContext differentiates from other interfaces.
	IsN_output_gate_instanceContext()
}

type N_output_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_output_gate_instanceContext() *N_output_gate_instanceContext {
	var p = new(N_output_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_n_output_gate_instance
	return p
}

func (*N_output_gate_instanceContext) IsN_output_gate_instanceContext() {}

func NewN_output_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_output_gate_instanceContext {
	var p = new(N_output_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_n_output_gate_instance

	return p
}

func (s *N_output_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *N_output_gate_instanceContext) N_output_gate_interface() IN_output_gate_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_output_gate_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_output_gate_interfaceContext)
}

func (s *N_output_gate_instanceContext) Gate_instance_identifier() IGate_instance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGate_instance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGate_instance_identifierContext)
}

func (s *N_output_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_output_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_output_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterN_output_gate_instance(s)
	}
}

func (s *N_output_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitN_output_gate_instance(s)
	}
}

func (p *SysVerilogHDLParser) N_output_gate_instance() (localctx IN_output_gate_instanceContext) {
	localctx = NewN_output_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, SysVerilogHDLParserRULE_n_output_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2108)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserEscaped_identifier || _la == SysVerilogHDLParserSimple_identifier {
		{
			p.SetState(2107)
			p.Gate_instance_identifier()
		}

	}
	{
		p.SetState(2110)
		p.N_output_gate_interface()
	}

	return localctx
}

// IPass_switch_instanceContext is an interface to support dynamic dispatch.
type IPass_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_switch_instanceContext differentiates from other interfaces.
	IsPass_switch_instanceContext()
}

type Pass_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_switch_instanceContext() *Pass_switch_instanceContext {
	var p = new(Pass_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_pass_switch_instance
	return p
}

func (*Pass_switch_instanceContext) IsPass_switch_instanceContext() {}

func NewPass_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_switch_instanceContext {
	var p = new(Pass_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_pass_switch_instance

	return p
}

func (s *Pass_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_switch_instanceContext) Pass_switch_interface() IPass_switch_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_switch_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_switch_interfaceContext)
}

func (s *Pass_switch_instanceContext) Gate_instance_identifier() IGate_instance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGate_instance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGate_instance_identifierContext)
}

func (s *Pass_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPass_switch_instance(s)
	}
}

func (s *Pass_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPass_switch_instance(s)
	}
}

func (p *SysVerilogHDLParser) Pass_switch_instance() (localctx IPass_switch_instanceContext) {
	localctx = NewPass_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, SysVerilogHDLParserRULE_pass_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2113)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserEscaped_identifier || _la == SysVerilogHDLParserSimple_identifier {
		{
			p.SetState(2112)
			p.Gate_instance_identifier()
		}

	}
	{
		p.SetState(2115)
		p.Pass_switch_interface()
	}

	return localctx
}

// IPass_enable_switch_instanceContext is an interface to support dynamic dispatch.
type IPass_enable_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_enable_switch_instanceContext differentiates from other interfaces.
	IsPass_enable_switch_instanceContext()
}

type Pass_enable_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_enable_switch_instanceContext() *Pass_enable_switch_instanceContext {
	var p = new(Pass_enable_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_pass_enable_switch_instance
	return p
}

func (*Pass_enable_switch_instanceContext) IsPass_enable_switch_instanceContext() {}

func NewPass_enable_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_enable_switch_instanceContext {
	var p = new(Pass_enable_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_pass_enable_switch_instance

	return p
}

func (s *Pass_enable_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_enable_switch_instanceContext) Pass_enable_switch_interface() IPass_enable_switch_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_enable_switch_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_enable_switch_interfaceContext)
}

func (s *Pass_enable_switch_instanceContext) Gate_instance_identifier() IGate_instance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGate_instance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGate_instance_identifierContext)
}

func (s *Pass_enable_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_enable_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_enable_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPass_enable_switch_instance(s)
	}
}

func (s *Pass_enable_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPass_enable_switch_instance(s)
	}
}

func (p *SysVerilogHDLParser) Pass_enable_switch_instance() (localctx IPass_enable_switch_instanceContext) {
	localctx = NewPass_enable_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, SysVerilogHDLParserRULE_pass_enable_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2118)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserEscaped_identifier || _la == SysVerilogHDLParserSimple_identifier {
		{
			p.SetState(2117)
			p.Gate_instance_identifier()
		}

	}
	{
		p.SetState(2120)
		p.Pass_enable_switch_interface()
	}

	return localctx
}

// IPull_gate_interfaceContext is an interface to support dynamic dispatch.
type IPull_gate_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPull_gate_interfaceContext differentiates from other interfaces.
	IsPull_gate_interfaceContext()
}

type Pull_gate_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPull_gate_interfaceContext() *Pull_gate_interfaceContext {
	var p = new(Pull_gate_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_pull_gate_interface
	return p
}

func (*Pull_gate_interfaceContext) IsPull_gate_interfaceContext() {}

func NewPull_gate_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pull_gate_interfaceContext {
	var p = new(Pull_gate_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_pull_gate_interface

	return p
}

func (s *Pull_gate_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pull_gate_interfaceContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Pull_gate_interfaceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Pull_gate_interfaceContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Pull_gate_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pull_gate_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pull_gate_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPull_gate_interface(s)
	}
}

func (s *Pull_gate_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPull_gate_interface(s)
	}
}

func (p *SysVerilogHDLParser) Pull_gate_interface() (localctx IPull_gate_interfaceContext) {
	localctx = NewPull_gate_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, SysVerilogHDLParserRULE_pull_gate_interface)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2122)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2123)
		p.Output_terminal()
	}
	{
		p.SetState(2124)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// IEnable_gate_interfaceContext is an interface to support dynamic dispatch.
type IEnable_gate_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_gate_interfaceContext differentiates from other interfaces.
	IsEnable_gate_interfaceContext()
}

type Enable_gate_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_gate_interfaceContext() *Enable_gate_interfaceContext {
	var p = new(Enable_gate_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_enable_gate_interface
	return p
}

func (*Enable_gate_interfaceContext) IsEnable_gate_interfaceContext() {}

func NewEnable_gate_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_gate_interfaceContext {
	var p = new(Enable_gate_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_enable_gate_interface

	return p
}

func (s *Enable_gate_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_gate_interfaceContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Enable_gate_interfaceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Enable_gate_interfaceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SysVerilogHDLParserComma)
}

func (s *Enable_gate_interfaceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, i)
}

func (s *Enable_gate_interfaceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *Enable_gate_interfaceContext) Enable_terminal() IEnable_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_terminalContext)
}

func (s *Enable_gate_interfaceContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Enable_gate_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_gate_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_gate_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEnable_gate_interface(s)
	}
}

func (s *Enable_gate_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEnable_gate_interface(s)
	}
}

func (p *SysVerilogHDLParser) Enable_gate_interface() (localctx IEnable_gate_interfaceContext) {
	localctx = NewEnable_gate_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, SysVerilogHDLParserRULE_enable_gate_interface)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2126)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2127)
		p.Output_terminal()
	}
	{
		p.SetState(2128)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2129)
		p.Input_terminal()
	}
	{
		p.SetState(2130)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2131)
		p.Enable_terminal()
	}
	{
		p.SetState(2132)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// IMos_switch_interfaceContext is an interface to support dynamic dispatch.
type IMos_switch_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMos_switch_interfaceContext differentiates from other interfaces.
	IsMos_switch_interfaceContext()
}

type Mos_switch_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMos_switch_interfaceContext() *Mos_switch_interfaceContext {
	var p = new(Mos_switch_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_mos_switch_interface
	return p
}

func (*Mos_switch_interfaceContext) IsMos_switch_interfaceContext() {}

func NewMos_switch_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mos_switch_interfaceContext {
	var p = new(Mos_switch_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_mos_switch_interface

	return p
}

func (s *Mos_switch_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Mos_switch_interfaceContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Mos_switch_interfaceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Mos_switch_interfaceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SysVerilogHDLParserComma)
}

func (s *Mos_switch_interfaceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, i)
}

func (s *Mos_switch_interfaceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *Mos_switch_interfaceContext) Enable_terminal() IEnable_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_terminalContext)
}

func (s *Mos_switch_interfaceContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Mos_switch_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mos_switch_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mos_switch_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterMos_switch_interface(s)
	}
}

func (s *Mos_switch_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitMos_switch_interface(s)
	}
}

func (p *SysVerilogHDLParser) Mos_switch_interface() (localctx IMos_switch_interfaceContext) {
	localctx = NewMos_switch_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, SysVerilogHDLParserRULE_mos_switch_interface)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2134)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2135)
		p.Output_terminal()
	}
	{
		p.SetState(2136)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2137)
		p.Input_terminal()
	}
	{
		p.SetState(2138)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2139)
		p.Enable_terminal()
	}
	{
		p.SetState(2140)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// ICmos_switch_interfaceContext is an interface to support dynamic dispatch.
type ICmos_switch_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmos_switch_interfaceContext differentiates from other interfaces.
	IsCmos_switch_interfaceContext()
}

type Cmos_switch_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmos_switch_interfaceContext() *Cmos_switch_interfaceContext {
	var p = new(Cmos_switch_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_cmos_switch_interface
	return p
}

func (*Cmos_switch_interfaceContext) IsCmos_switch_interfaceContext() {}

func NewCmos_switch_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmos_switch_interfaceContext {
	var p = new(Cmos_switch_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_cmos_switch_interface

	return p
}

func (s *Cmos_switch_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmos_switch_interfaceContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Cmos_switch_interfaceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Cmos_switch_interfaceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SysVerilogHDLParserComma)
}

func (s *Cmos_switch_interfaceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, i)
}

func (s *Cmos_switch_interfaceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *Cmos_switch_interfaceContext) Ncontrol_terminal() INcontrol_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INcontrol_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INcontrol_terminalContext)
}

func (s *Cmos_switch_interfaceContext) Pcontrol_terminal() IPcontrol_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPcontrol_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPcontrol_terminalContext)
}

func (s *Cmos_switch_interfaceContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Cmos_switch_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmos_switch_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmos_switch_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterCmos_switch_interface(s)
	}
}

func (s *Cmos_switch_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitCmos_switch_interface(s)
	}
}

func (p *SysVerilogHDLParser) Cmos_switch_interface() (localctx ICmos_switch_interfaceContext) {
	localctx = NewCmos_switch_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, SysVerilogHDLParserRULE_cmos_switch_interface)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2142)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2143)
		p.Output_terminal()
	}
	{
		p.SetState(2144)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2145)
		p.Input_terminal()
	}
	{
		p.SetState(2146)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2147)
		p.Ncontrol_terminal()
	}
	{
		p.SetState(2148)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2149)
		p.Pcontrol_terminal()
	}
	{
		p.SetState(2150)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// IN_input_gate_interfaceContext is an interface to support dynamic dispatch.
type IN_input_gate_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_input_gate_interfaceContext differentiates from other interfaces.
	IsN_input_gate_interfaceContext()
}

type N_input_gate_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_input_gate_interfaceContext() *N_input_gate_interfaceContext {
	var p = new(N_input_gate_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_n_input_gate_interface
	return p
}

func (*N_input_gate_interfaceContext) IsN_input_gate_interfaceContext() {}

func NewN_input_gate_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_input_gate_interfaceContext {
	var p = new(N_input_gate_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_n_input_gate_interface

	return p
}

func (s *N_input_gate_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *N_input_gate_interfaceContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *N_input_gate_interfaceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *N_input_gate_interfaceContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *N_input_gate_interfaceContext) List_of_input_terminals() IList_of_input_terminalsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_input_terminalsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_input_terminalsContext)
}

func (s *N_input_gate_interfaceContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *N_input_gate_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_input_gate_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_input_gate_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterN_input_gate_interface(s)
	}
}

func (s *N_input_gate_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitN_input_gate_interface(s)
	}
}

func (p *SysVerilogHDLParser) N_input_gate_interface() (localctx IN_input_gate_interfaceContext) {
	localctx = NewN_input_gate_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, SysVerilogHDLParserRULE_n_input_gate_interface)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2152)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2153)
		p.Output_terminal()
	}
	{
		p.SetState(2154)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2155)
		p.List_of_input_terminals()
	}
	{
		p.SetState(2156)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// IN_output_gate_interfaceContext is an interface to support dynamic dispatch.
type IN_output_gate_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_output_gate_interfaceContext differentiates from other interfaces.
	IsN_output_gate_interfaceContext()
}

type N_output_gate_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_output_gate_interfaceContext() *N_output_gate_interfaceContext {
	var p = new(N_output_gate_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_n_output_gate_interface
	return p
}

func (*N_output_gate_interfaceContext) IsN_output_gate_interfaceContext() {}

func NewN_output_gate_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_output_gate_interfaceContext {
	var p = new(N_output_gate_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_n_output_gate_interface

	return p
}

func (s *N_output_gate_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *N_output_gate_interfaceContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *N_output_gate_interfaceContext) List_of_output_terminals() IList_of_output_terminalsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_output_terminalsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_output_terminalsContext)
}

func (s *N_output_gate_interfaceContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *N_output_gate_interfaceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *N_output_gate_interfaceContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *N_output_gate_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_output_gate_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_output_gate_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterN_output_gate_interface(s)
	}
}

func (s *N_output_gate_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitN_output_gate_interface(s)
	}
}

func (p *SysVerilogHDLParser) N_output_gate_interface() (localctx IN_output_gate_interfaceContext) {
	localctx = NewN_output_gate_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, SysVerilogHDLParserRULE_n_output_gate_interface)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2158)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2159)
		p.List_of_output_terminals()
	}
	{
		p.SetState(2160)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2161)
		p.Input_terminal()
	}
	{
		p.SetState(2162)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// IPass_switch_interfaceContext is an interface to support dynamic dispatch.
type IPass_switch_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_switch_interfaceContext differentiates from other interfaces.
	IsPass_switch_interfaceContext()
}

type Pass_switch_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_switch_interfaceContext() *Pass_switch_interfaceContext {
	var p = new(Pass_switch_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_pass_switch_interface
	return p
}

func (*Pass_switch_interfaceContext) IsPass_switch_interfaceContext() {}

func NewPass_switch_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_switch_interfaceContext {
	var p = new(Pass_switch_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_pass_switch_interface

	return p
}

func (s *Pass_switch_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_switch_interfaceContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Pass_switch_interfaceContext) AllInout_terminal() []IInout_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem())
	var tst = make([]IInout_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInout_terminalContext)
		}
	}

	return tst
}

func (s *Pass_switch_interfaceContext) Inout_terminal(i int) IInout_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInout_terminalContext)
}

func (s *Pass_switch_interfaceContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Pass_switch_interfaceContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Pass_switch_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_switch_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_switch_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPass_switch_interface(s)
	}
}

func (s *Pass_switch_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPass_switch_interface(s)
	}
}

func (p *SysVerilogHDLParser) Pass_switch_interface() (localctx IPass_switch_interfaceContext) {
	localctx = NewPass_switch_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, SysVerilogHDLParserRULE_pass_switch_interface)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2164)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2165)
		p.Inout_terminal()
	}
	{
		p.SetState(2166)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2167)
		p.Inout_terminal()
	}
	{
		p.SetState(2168)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// IPass_enable_switch_interfaceContext is an interface to support dynamic dispatch.
type IPass_enable_switch_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_enable_switch_interfaceContext differentiates from other interfaces.
	IsPass_enable_switch_interfaceContext()
}

type Pass_enable_switch_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_enable_switch_interfaceContext() *Pass_enable_switch_interfaceContext {
	var p = new(Pass_enable_switch_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_pass_enable_switch_interface
	return p
}

func (*Pass_enable_switch_interfaceContext) IsPass_enable_switch_interfaceContext() {}

func NewPass_enable_switch_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_enable_switch_interfaceContext {
	var p = new(Pass_enable_switch_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_pass_enable_switch_interface

	return p
}

func (s *Pass_enable_switch_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_enable_switch_interfaceContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Pass_enable_switch_interfaceContext) AllInout_terminal() []IInout_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem())
	var tst = make([]IInout_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInout_terminalContext)
		}
	}

	return tst
}

func (s *Pass_enable_switch_interfaceContext) Inout_terminal(i int) IInout_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInout_terminalContext)
}

func (s *Pass_enable_switch_interfaceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SysVerilogHDLParserComma)
}

func (s *Pass_enable_switch_interfaceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, i)
}

func (s *Pass_enable_switch_interfaceContext) Enable_terminal() IEnable_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_terminalContext)
}

func (s *Pass_enable_switch_interfaceContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Pass_enable_switch_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_enable_switch_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_enable_switch_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPass_enable_switch_interface(s)
	}
}

func (s *Pass_enable_switch_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPass_enable_switch_interface(s)
	}
}

func (p *SysVerilogHDLParser) Pass_enable_switch_interface() (localctx IPass_enable_switch_interfaceContext) {
	localctx = NewPass_enable_switch_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, SysVerilogHDLParserRULE_pass_enable_switch_interface)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2170)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2171)
		p.Inout_terminal()
	}
	{
		p.SetState(2172)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2173)
		p.Inout_terminal()
	}
	{
		p.SetState(2174)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2175)
		p.Enable_terminal()
	}
	{
		p.SetState(2176)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// IList_of_input_terminalsContext is an interface to support dynamic dispatch.
type IList_of_input_terminalsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_input_terminalsContext differentiates from other interfaces.
	IsList_of_input_terminalsContext()
}

type List_of_input_terminalsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_input_terminalsContext() *List_of_input_terminalsContext {
	var p = new(List_of_input_terminalsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_input_terminals
	return p
}

func (*List_of_input_terminalsContext) IsList_of_input_terminalsContext() {}

func NewList_of_input_terminalsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_input_terminalsContext {
	var p = new(List_of_input_terminalsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_input_terminals

	return p
}

func (s *List_of_input_terminalsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_input_terminalsContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *List_of_input_terminalsContext) Comma_input_terminal_star() IComma_input_terminal_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_input_terminal_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_input_terminal_starContext)
}

func (s *List_of_input_terminalsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_input_terminalsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_input_terminalsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_input_terminals(s)
	}
}

func (s *List_of_input_terminalsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_input_terminals(s)
	}
}

func (p *SysVerilogHDLParser) List_of_input_terminals() (localctx IList_of_input_terminalsContext) {
	localctx = NewList_of_input_terminalsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, SysVerilogHDLParserRULE_list_of_input_terminals)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2178)
		p.Input_terminal()
	}
	{
		p.SetState(2179)
		p.Comma_input_terminal_star()
	}

	return localctx
}

// IList_of_output_terminalsContext is an interface to support dynamic dispatch.
type IList_of_output_terminalsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_output_terminalsContext differentiates from other interfaces.
	IsList_of_output_terminalsContext()
}

type List_of_output_terminalsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_output_terminalsContext() *List_of_output_terminalsContext {
	var p = new(List_of_output_terminalsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_output_terminals
	return p
}

func (*List_of_output_terminalsContext) IsList_of_output_terminalsContext() {}

func NewList_of_output_terminalsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_output_terminalsContext {
	var p = new(List_of_output_terminalsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_output_terminals

	return p
}

func (s *List_of_output_terminalsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_output_terminalsContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *List_of_output_terminalsContext) Comma_output_terminal_star() IComma_output_terminal_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_output_terminal_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_output_terminal_starContext)
}

func (s *List_of_output_terminalsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_output_terminalsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_output_terminalsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_output_terminals(s)
	}
}

func (s *List_of_output_terminalsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_output_terminals(s)
	}
}

func (p *SysVerilogHDLParser) List_of_output_terminals() (localctx IList_of_output_terminalsContext) {
	localctx = NewList_of_output_terminalsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, SysVerilogHDLParserRULE_list_of_output_terminals)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2181)
		p.Output_terminal()
	}
	{
		p.SetState(2182)
		p.Comma_output_terminal_star()
	}

	return localctx
}

// IComma_input_terminal_starContext is an interface to support dynamic dispatch.
type IComma_input_terminal_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_input_terminal_starContext differentiates from other interfaces.
	IsComma_input_terminal_starContext()
}

type Comma_input_terminal_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_input_terminal_starContext() *Comma_input_terminal_starContext {
	var p = new(Comma_input_terminal_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_input_terminal_star
	return p
}

func (*Comma_input_terminal_starContext) IsComma_input_terminal_starContext() {}

func NewComma_input_terminal_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_input_terminal_starContext {
	var p = new(Comma_input_terminal_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_input_terminal_star

	return p
}

func (s *Comma_input_terminal_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_input_terminal_starContext) AllComma_input_terminal() []IComma_input_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_input_terminalContext)(nil)).Elem())
	var tst = make([]IComma_input_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_input_terminalContext)
		}
	}

	return tst
}

func (s *Comma_input_terminal_starContext) Comma_input_terminal(i int) IComma_input_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_input_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_input_terminalContext)
}

func (s *Comma_input_terminal_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_input_terminal_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_input_terminal_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_input_terminal_star(s)
	}
}

func (s *Comma_input_terminal_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_input_terminal_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_input_terminal_star() (localctx IComma_input_terminal_starContext) {
	localctx = NewComma_input_terminal_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, SysVerilogHDLParserRULE_comma_input_terminal_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2187)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(2184)
			p.Comma_input_terminal()
		}

		p.SetState(2189)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_output_terminal_starContext is an interface to support dynamic dispatch.
type IComma_output_terminal_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_output_terminal_starContext differentiates from other interfaces.
	IsComma_output_terminal_starContext()
}

type Comma_output_terminal_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_output_terminal_starContext() *Comma_output_terminal_starContext {
	var p = new(Comma_output_terminal_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_output_terminal_star
	return p
}

func (*Comma_output_terminal_starContext) IsComma_output_terminal_starContext() {}

func NewComma_output_terminal_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_output_terminal_starContext {
	var p = new(Comma_output_terminal_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_output_terminal_star

	return p
}

func (s *Comma_output_terminal_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_output_terminal_starContext) AllComma_output_terminal() []IComma_output_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_output_terminalContext)(nil)).Elem())
	var tst = make([]IComma_output_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_output_terminalContext)
		}
	}

	return tst
}

func (s *Comma_output_terminal_starContext) Comma_output_terminal(i int) IComma_output_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_output_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_output_terminalContext)
}

func (s *Comma_output_terminal_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_output_terminal_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_output_terminal_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_output_terminal_star(s)
	}
}

func (s *Comma_output_terminal_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_output_terminal_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_output_terminal_star() (localctx IComma_output_terminal_starContext) {
	localctx = NewComma_output_terminal_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, SysVerilogHDLParserRULE_comma_output_terminal_star)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2193)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2190)
				p.Comma_output_terminal()
			}

		}
		p.SetState(2195)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext())
	}

	return localctx
}

// IComma_input_terminalContext is an interface to support dynamic dispatch.
type IComma_input_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_input_terminalContext differentiates from other interfaces.
	IsComma_input_terminalContext()
}

type Comma_input_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_input_terminalContext() *Comma_input_terminalContext {
	var p = new(Comma_input_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_input_terminal
	return p
}

func (*Comma_input_terminalContext) IsComma_input_terminalContext() {}

func NewComma_input_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_input_terminalContext {
	var p = new(Comma_input_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_input_terminal

	return p
}

func (s *Comma_input_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_input_terminalContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_input_terminalContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *Comma_input_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_input_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_input_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_input_terminal(s)
	}
}

func (s *Comma_input_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_input_terminal(s)
	}
}

func (p *SysVerilogHDLParser) Comma_input_terminal() (localctx IComma_input_terminalContext) {
	localctx = NewComma_input_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, SysVerilogHDLParserRULE_comma_input_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2196)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2197)
		p.Input_terminal()
	}

	return localctx
}

// IComma_output_terminalContext is an interface to support dynamic dispatch.
type IComma_output_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_output_terminalContext differentiates from other interfaces.
	IsComma_output_terminalContext()
}

type Comma_output_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_output_terminalContext() *Comma_output_terminalContext {
	var p = new(Comma_output_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_output_terminal
	return p
}

func (*Comma_output_terminalContext) IsComma_output_terminalContext() {}

func NewComma_output_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_output_terminalContext {
	var p = new(Comma_output_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_output_terminal

	return p
}

func (s *Comma_output_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_output_terminalContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_output_terminalContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Comma_output_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_output_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_output_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_output_terminal(s)
	}
}

func (s *Comma_output_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_output_terminal(s)
	}
}

func (p *SysVerilogHDLParser) Comma_output_terminal() (localctx IComma_output_terminalContext) {
	localctx = NewComma_output_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, SysVerilogHDLParserRULE_comma_output_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2199)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2200)
		p.Output_terminal()
	}

	return localctx
}

// IEnable_terminalContext is an interface to support dynamic dispatch.
type IEnable_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_terminalContext differentiates from other interfaces.
	IsEnable_terminalContext()
}

type Enable_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_terminalContext() *Enable_terminalContext {
	var p = new(Enable_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_enable_terminal
	return p
}

func (*Enable_terminalContext) IsEnable_terminalContext() {}

func NewEnable_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_terminalContext {
	var p = new(Enable_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_enable_terminal

	return p
}

func (s *Enable_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Enable_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEnable_terminal(s)
	}
}

func (s *Enable_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEnable_terminal(s)
	}
}

func (p *SysVerilogHDLParser) Enable_terminal() (localctx IEnable_terminalContext) {
	localctx = NewEnable_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, SysVerilogHDLParserRULE_enable_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2202)
		p.Expression()
	}

	return localctx
}

// IInput_terminalContext is an interface to support dynamic dispatch.
type IInput_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_terminalContext differentiates from other interfaces.
	IsInput_terminalContext()
}

type Input_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_terminalContext() *Input_terminalContext {
	var p = new(Input_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_input_terminal
	return p
}

func (*Input_terminalContext) IsInput_terminalContext() {}

func NewInput_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_terminalContext {
	var p = new(Input_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_input_terminal

	return p
}

func (s *Input_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Input_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterInput_terminal(s)
	}
}

func (s *Input_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitInput_terminal(s)
	}
}

func (p *SysVerilogHDLParser) Input_terminal() (localctx IInput_terminalContext) {
	localctx = NewInput_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, SysVerilogHDLParserRULE_input_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2204)
		p.Expression()
	}

	return localctx
}

// IInout_terminalContext is an interface to support dynamic dispatch.
type IInout_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInout_terminalContext differentiates from other interfaces.
	IsInout_terminalContext()
}

type Inout_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInout_terminalContext() *Inout_terminalContext {
	var p = new(Inout_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_inout_terminal
	return p
}

func (*Inout_terminalContext) IsInout_terminalContext() {}

func NewInout_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inout_terminalContext {
	var p = new(Inout_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_inout_terminal

	return p
}

func (s *Inout_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Inout_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Inout_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inout_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inout_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterInout_terminal(s)
	}
}

func (s *Inout_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitInout_terminal(s)
	}
}

func (p *SysVerilogHDLParser) Inout_terminal() (localctx IInout_terminalContext) {
	localctx = NewInout_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, SysVerilogHDLParserRULE_inout_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2206)
		p.Expression()
	}

	return localctx
}

// INcontrol_terminalContext is an interface to support dynamic dispatch.
type INcontrol_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNcontrol_terminalContext differentiates from other interfaces.
	IsNcontrol_terminalContext()
}

type Ncontrol_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNcontrol_terminalContext() *Ncontrol_terminalContext {
	var p = new(Ncontrol_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_ncontrol_terminal
	return p
}

func (*Ncontrol_terminalContext) IsNcontrol_terminalContext() {}

func NewNcontrol_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ncontrol_terminalContext {
	var p = new(Ncontrol_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_ncontrol_terminal

	return p
}

func (s *Ncontrol_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Ncontrol_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Ncontrol_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ncontrol_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ncontrol_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterNcontrol_terminal(s)
	}
}

func (s *Ncontrol_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitNcontrol_terminal(s)
	}
}

func (p *SysVerilogHDLParser) Ncontrol_terminal() (localctx INcontrol_terminalContext) {
	localctx = NewNcontrol_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, SysVerilogHDLParserRULE_ncontrol_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2208)
		p.Expression()
	}

	return localctx
}

// IOutput_terminalContext is an interface to support dynamic dispatch.
type IOutput_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_terminalContext differentiates from other interfaces.
	IsOutput_terminalContext()
}

type Output_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_terminalContext() *Output_terminalContext {
	var p = new(Output_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_output_terminal
	return p
}

func (*Output_terminalContext) IsOutput_terminalContext() {}

func NewOutput_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_terminalContext {
	var p = new(Output_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_output_terminal

	return p
}

func (s *Output_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Output_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterOutput_terminal(s)
	}
}

func (s *Output_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitOutput_terminal(s)
	}
}

func (p *SysVerilogHDLParser) Output_terminal() (localctx IOutput_terminalContext) {
	localctx = NewOutput_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, SysVerilogHDLParserRULE_output_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2210)
		p.Expression()
	}

	return localctx
}

// IPcontrol_terminalContext is an interface to support dynamic dispatch.
type IPcontrol_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPcontrol_terminalContext differentiates from other interfaces.
	IsPcontrol_terminalContext()
}

type Pcontrol_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPcontrol_terminalContext() *Pcontrol_terminalContext {
	var p = new(Pcontrol_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_pcontrol_terminal
	return p
}

func (*Pcontrol_terminalContext) IsPcontrol_terminalContext() {}

func NewPcontrol_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pcontrol_terminalContext {
	var p = new(Pcontrol_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_pcontrol_terminal

	return p
}

func (s *Pcontrol_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Pcontrol_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Pcontrol_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pcontrol_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pcontrol_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPcontrol_terminal(s)
	}
}

func (s *Pcontrol_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPcontrol_terminal(s)
	}
}

func (p *SysVerilogHDLParser) Pcontrol_terminal() (localctx IPcontrol_terminalContext) {
	localctx = NewPcontrol_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, SysVerilogHDLParserRULE_pcontrol_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2212)
		p.Expression()
	}

	return localctx
}

// IStatement_starContext is an interface to support dynamic dispatch.
type IStatement_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatement_starContext differentiates from other interfaces.
	IsStatement_starContext()
}

type Statement_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatement_starContext() *Statement_starContext {
	var p = new(Statement_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_statement_star
	return p
}

func (*Statement_starContext) IsStatement_starContext() {}

func NewStatement_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Statement_starContext {
	var p = new(Statement_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_statement_star

	return p
}

func (s *Statement_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Statement_starContext) AllStatement_semicolon() []IStatement_semicolonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatement_semicolonContext)(nil)).Elem())
	var tst = make([]IStatement_semicolonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatement_semicolonContext)
		}
	}

	return tst
}

func (s *Statement_starContext) Statement_semicolon(i int) IStatement_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_semicolonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatement_semicolonContext)
}

func (s *Statement_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Statement_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Statement_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterStatement_star(s)
	}
}

func (s *Statement_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitStatement_star(s)
	}
}

func (p *SysVerilogHDLParser) Statement_star() (localctx IStatement_starContext) {
	localctx = NewStatement_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, SysVerilogHDLParserRULE_statement_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2217)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SysVerilogHDLParserT__0)|(1<<SysVerilogHDLParserT__1)|(1<<SysVerilogHDLParserT__2)|(1<<SysVerilogHDLParserT__3)|(1<<SysVerilogHDLParserT__4)|(1<<SysVerilogHDLParserT__5)|(1<<SysVerilogHDLParserT__6)|(1<<SysVerilogHDLParserT__7)|(1<<SysVerilogHDLParserT__8)|(1<<SysVerilogHDLParserT__9)|(1<<SysVerilogHDLParserT__10)|(1<<SysVerilogHDLParserT__26)|(1<<SysVerilogHDLParserT__27))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(SysVerilogHDLParserBinary_number-42))|(1<<(SysVerilogHDLParserDecimal_number-42))|(1<<(SysVerilogHDLParserFixed_point_number-42))|(1<<(SysVerilogHDLParserHex_number-42))|(1<<(SysVerilogHDLParserOctal_number-42))|(1<<(SysVerilogHDLParserReal_exp_form-42))|(1<<(SysVerilogHDLParserAssert-42))|(1<<(SysVerilogHDLParserAssign-42))|(1<<(SysVerilogHDLParserAutomatic-42))|(1<<(SysVerilogHDLParserBegin-42))|(1<<(SysVerilogHDLParserBit-42))|(1<<(SysVerilogHDLParserByte-42))|(1<<(SysVerilogHDLParserCase_keyword-42))|(1<<(SysVerilogHDLParserCasez-42))|(1<<(SysVerilogHDLParserCasex-42))|(1<<(SysVerilogHDLParserConst-42))|(1<<(SysVerilogHDLParserDeassign-42)))) != 0) || (((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(SysVerilogHDLParserDisable-74))|(1<<(SysVerilogHDLParserDo-74))|(1<<(SysVerilogHDLParserFor-74))|(1<<(SysVerilogHDLParserForce-74))|(1<<(SysVerilogHDLParserForever-74))|(1<<(SysVerilogHDLParserFork-74))|(1<<(SysVerilogHDLParserGenvar-74))|(1<<(SysVerilogHDLParserIf-74)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SysVerilogHDLParserInt-109))|(1<<(SysVerilogHDLParserInteger-109))|(1<<(SysVerilogHDLParserLogic-109)))) != 0) || (((_la-150)&-(0x1f+1)) == 0 && ((1<<uint((_la-150)))&((1<<(SysVerilogHDLParserReg-150))|(1<<(SysVerilogHDLParserRelease-150))|(1<<(SysVerilogHDLParserRepeat-150))|(1<<(SysVerilogHDLParserReturn-150))|(1<<(SysVerilogHDLParserSigned-150))|(1<<(SysVerilogHDLParserStatic-150)))) != 0) || (((_la-188)&-(0x1f+1)) == 0 && ((1<<uint((_la-188)))&((1<<(SysVerilogHDLParserUnsigned-188))|(1<<(SysVerilogHDLParserWait-188))|(1<<(SysVerilogHDLParserWhile-188))|(1<<(SysVerilogHDLParserDollar_Identifier-188))|(1<<(SysVerilogHDLParserEscaped_identifier-188))|(1<<(SysVerilogHDLParserSimple_identifier-188))|(1<<(SysVerilogHDLParserString_literal-188))|(1<<(SysVerilogHDLParserAt-188))|(1<<(SysVerilogHDLParserDash_right_angle-188))|(1<<(SysVerilogHDLParserHash-188))|(1<<(SysVerilogHDLParserLeft_curly_bracket-188)))) != 0) || (((_la-221)&-(0x1f+1)) == 0 && ((1<<uint((_la-221)))&((1<<(SysVerilogHDLParserOpen_parenthesis-221))|(1<<(SysVerilogHDLParserQuote-221))|(1<<(SysVerilogHDLParserSemicolon-221))|(1<<(SysVerilogHDLParserTilde-221)))) != 0) {
		{
			p.SetState(2214)
			p.Statement_semicolon()
		}

		p.SetState(2219)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStatement_semicolonContext is an interface to support dynamic dispatch.
type IStatement_semicolonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatement_semicolonContext differentiates from other interfaces.
	IsStatement_semicolonContext()
}

type Statement_semicolonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatement_semicolonContext() *Statement_semicolonContext {
	var p = new(Statement_semicolonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_statement_semicolon
	return p
}

func (*Statement_semicolonContext) IsStatement_semicolonContext() {}

func NewStatement_semicolonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Statement_semicolonContext {
	var p = new(Statement_semicolonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_statement_semicolon

	return p
}

func (s *Statement_semicolonContext) GetParser() antlr.Parser { return s.parser }

func (s *Statement_semicolonContext) Attribute_instance_star() IAttribute_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instance_starContext)
}

func (s *Statement_semicolonContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Statement_semicolonContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Statement_semicolonContext) Null_statement() INull_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INull_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INull_statementContext)
}

func (s *Statement_semicolonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Statement_semicolonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Statement_semicolonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterStatement_semicolon(s)
	}
}

func (s *Statement_semicolonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitStatement_semicolon(s)
	}
}

func (p *SysVerilogHDLParser) Statement_semicolon() (localctx IStatement_semicolonContext) {
	localctx = NewStatement_semicolonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, SysVerilogHDLParserRULE_statement_semicolon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2226)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserT__1, SysVerilogHDLParserT__2, SysVerilogHDLParserT__3, SysVerilogHDLParserT__4, SysVerilogHDLParserT__5, SysVerilogHDLParserT__6, SysVerilogHDLParserT__7, SysVerilogHDLParserT__8, SysVerilogHDLParserT__9, SysVerilogHDLParserT__10, SysVerilogHDLParserT__26, SysVerilogHDLParserT__27, SysVerilogHDLParserBinary_number, SysVerilogHDLParserDecimal_number, SysVerilogHDLParserFixed_point_number, SysVerilogHDLParserHex_number, SysVerilogHDLParserOctal_number, SysVerilogHDLParserReal_exp_form, SysVerilogHDLParserAssert, SysVerilogHDLParserAssign, SysVerilogHDLParserAutomatic, SysVerilogHDLParserBegin, SysVerilogHDLParserBit, SysVerilogHDLParserByte, SysVerilogHDLParserCase_keyword, SysVerilogHDLParserCasez, SysVerilogHDLParserCasex, SysVerilogHDLParserConst, SysVerilogHDLParserDeassign, SysVerilogHDLParserDisable, SysVerilogHDLParserDo, SysVerilogHDLParserFor, SysVerilogHDLParserForce, SysVerilogHDLParserForever, SysVerilogHDLParserFork, SysVerilogHDLParserGenvar, SysVerilogHDLParserIf, SysVerilogHDLParserInt, SysVerilogHDLParserInteger, SysVerilogHDLParserLogic, SysVerilogHDLParserReg, SysVerilogHDLParserRelease, SysVerilogHDLParserRepeat, SysVerilogHDLParserReturn, SysVerilogHDLParserSigned, SysVerilogHDLParserStatic, SysVerilogHDLParserUnsigned, SysVerilogHDLParserWait, SysVerilogHDLParserWhile, SysVerilogHDLParserDollar_Identifier, SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier, SysVerilogHDLParserString_literal, SysVerilogHDLParserAt, SysVerilogHDLParserDash_right_angle, SysVerilogHDLParserHash, SysVerilogHDLParserLeft_curly_bracket, SysVerilogHDLParserOpen_parenthesis, SysVerilogHDLParserQuote, SysVerilogHDLParserTilde:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2220)
			p.Attribute_instance_star()
		}
		{
			p.SetState(2221)
			p.Statement()
		}
		p.SetState(2223)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2222)
				p.Semicolon()
			}

		}

	case SysVerilogHDLParserT__0, SysVerilogHDLParserSemicolon:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2225)
			p.Null_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Assignment_statement() IAssignment_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_statementContext)
}

func (s *StatementContext) Flow_control_statement() IFlow_control_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_control_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_control_statementContext)
}

func (s *StatementContext) Block_statement() IBlock_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_statementContext)
}

func (s *StatementContext) Task_call_statement() ITask_call_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_call_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_call_statementContext)
}

func (s *StatementContext) Event_statement() IEvent_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_statementContext)
}

func (s *StatementContext) Procedural_statement() IProcedural_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_statementContext)
}

func (s *StatementContext) Expression_statement() IExpression_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_statementContext)
}

func (s *StatementContext) Subroutine_statement() ISubroutine_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubroutine_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubroutine_statementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *SysVerilogHDLParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, SysVerilogHDLParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2236)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2228)
			p.Assignment_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2229)
			p.Flow_control_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2230)
			p.Block_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2231)
			p.Task_call_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2232)
			p.Event_statement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2233)
			p.Procedural_statement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2234)
			p.Expression_statement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2235)
			p.Subroutine_statement()
		}

	}

	return localctx
}

// IAssignment_statementContext is an interface to support dynamic dispatch.
type IAssignment_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_statementContext differentiates from other interfaces.
	IsAssignment_statementContext()
}

type Assignment_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_statementContext() *Assignment_statementContext {
	var p = new(Assignment_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_assignment_statement
	return p
}

func (*Assignment_statementContext) IsAssignment_statementContext() {}

func NewAssignment_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_statementContext {
	var p = new(Assignment_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_assignment_statement

	return p
}

func (s *Assignment_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_statementContext) Blocking_assignment() IBlocking_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlocking_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlocking_assignmentContext)
}

func (s *Assignment_statementContext) Nonblocking_assignment() INonblocking_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonblocking_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonblocking_assignmentContext)
}

func (s *Assignment_statementContext) Prefix_assignment() IPrefix_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefix_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrefix_assignmentContext)
}

func (s *Assignment_statementContext) Postfix_assignment() IPostfix_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfix_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfix_assignmentContext)
}

func (s *Assignment_statementContext) Operator_assignment() IOperator_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperator_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperator_assignmentContext)
}

func (s *Assignment_statementContext) Declarative_assignment() IDeclarative_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarative_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarative_assignmentContext)
}

func (s *Assignment_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAssignment_statement(s)
	}
}

func (s *Assignment_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAssignment_statement(s)
	}
}

func (p *SysVerilogHDLParser) Assignment_statement() (localctx IAssignment_statementContext) {
	localctx = NewAssignment_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, SysVerilogHDLParserRULE_assignment_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2244)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2238)
			p.Blocking_assignment()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2239)
			p.Nonblocking_assignment()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2240)
			p.Prefix_assignment()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2241)
			p.Postfix_assignment()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2242)
			p.Operator_assignment()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2243)
			p.Declarative_assignment()
		}

	}

	return localctx
}

// IFlow_control_statementContext is an interface to support dynamic dispatch.
type IFlow_control_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_control_statementContext differentiates from other interfaces.
	IsFlow_control_statementContext()
}

type Flow_control_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_control_statementContext() *Flow_control_statementContext {
	var p = new(Flow_control_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_flow_control_statement
	return p
}

func (*Flow_control_statementContext) IsFlow_control_statementContext() {}

func NewFlow_control_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_control_statementContext {
	var p = new(Flow_control_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_flow_control_statement

	return p
}

func (s *Flow_control_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_control_statementContext) Case_statement() ICase_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_statementContext)
}

func (s *Flow_control_statementContext) Conditional_statement() IConditional_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_statementContext)
}

func (s *Flow_control_statementContext) Loop_statement() ILoop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_statementContext)
}

func (s *Flow_control_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_control_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_control_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterFlow_control_statement(s)
	}
}

func (s *Flow_control_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitFlow_control_statement(s)
	}
}

func (p *SysVerilogHDLParser) Flow_control_statement() (localctx IFlow_control_statementContext) {
	localctx = NewFlow_control_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, SysVerilogHDLParserRULE_flow_control_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2249)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserCase_keyword, SysVerilogHDLParserCasez, SysVerilogHDLParserCasex:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2246)
			p.Case_statement()
		}

	case SysVerilogHDLParserIf:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2247)
			p.Conditional_statement()
		}

	case SysVerilogHDLParserDo, SysVerilogHDLParserFor, SysVerilogHDLParserForever, SysVerilogHDLParserRepeat, SysVerilogHDLParserWhile:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2248)
			p.Loop_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBlock_statementContext is an interface to support dynamic dispatch.
type IBlock_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_statementContext differentiates from other interfaces.
	IsBlock_statementContext()
}

type Block_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_statementContext() *Block_statementContext {
	var p = new(Block_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_block_statement
	return p
}

func (*Block_statementContext) IsBlock_statementContext() {}

func NewBlock_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_statementContext {
	var p = new(Block_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_block_statement

	return p
}

func (s *Block_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_statementContext) Par_block() IPar_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPar_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPar_blockContext)
}

func (s *Block_statementContext) Seq_block() ISeq_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeq_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeq_blockContext)
}

func (s *Block_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterBlock_statement(s)
	}
}

func (s *Block_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitBlock_statement(s)
	}
}

func (p *SysVerilogHDLParser) Block_statement() (localctx IBlock_statementContext) {
	localctx = NewBlock_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, SysVerilogHDLParserRULE_block_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2253)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserFork:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2251)
			p.Par_block()
		}

	case SysVerilogHDLParserBegin:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2252)
			p.Seq_block()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITask_call_statementContext is an interface to support dynamic dispatch.
type ITask_call_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_call_statementContext differentiates from other interfaces.
	IsTask_call_statementContext()
}

type Task_call_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_call_statementContext() *Task_call_statementContext {
	var p = new(Task_call_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_task_call_statement
	return p
}

func (*Task_call_statementContext) IsTask_call_statementContext() {}

func NewTask_call_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_call_statementContext {
	var p = new(Task_call_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_task_call_statement

	return p
}

func (s *Task_call_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_call_statementContext) Task_enable() ITask_enableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_enableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_enableContext)
}

func (s *Task_call_statementContext) System_task_enable() ISystem_task_enableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_task_enableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_task_enableContext)
}

func (s *Task_call_statementContext) Disable_statement() IDisable_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisable_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisable_statementContext)
}

func (s *Task_call_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_call_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_call_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTask_call_statement(s)
	}
}

func (s *Task_call_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTask_call_statement(s)
	}
}

func (p *SysVerilogHDLParser) Task_call_statement() (localctx ITask_call_statementContext) {
	localctx = NewTask_call_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, SysVerilogHDLParserRULE_task_call_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2258)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2255)
			p.Task_enable()
		}

	case SysVerilogHDLParserDollar_Identifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2256)
			p.System_task_enable()
		}

	case SysVerilogHDLParserDisable:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2257)
			p.Disable_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEvent_statementContext is an interface to support dynamic dispatch.
type IEvent_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_statementContext differentiates from other interfaces.
	IsEvent_statementContext()
}

type Event_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_statementContext() *Event_statementContext {
	var p = new(Event_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_event_statement
	return p
}

func (*Event_statementContext) IsEvent_statementContext() {}

func NewEvent_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_statementContext {
	var p = new(Event_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_event_statement

	return p
}

func (s *Event_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_statementContext) Event_trigger() IEvent_triggerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_triggerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_triggerContext)
}

func (s *Event_statementContext) Wait_statement() IWait_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWait_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWait_statementContext)
}

func (s *Event_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEvent_statement(s)
	}
}

func (s *Event_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEvent_statement(s)
	}
}

func (p *SysVerilogHDLParser) Event_statement() (localctx IEvent_statementContext) {
	localctx = NewEvent_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, SysVerilogHDLParserRULE_event_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2262)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserDash_right_angle:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2260)
			p.Event_trigger()
		}

	case SysVerilogHDLParserWait:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2261)
			p.Wait_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcedural_statementContext is an interface to support dynamic dispatch.
type IProcedural_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_statementContext differentiates from other interfaces.
	IsProcedural_statementContext()
}

type Procedural_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_statementContext() *Procedural_statementContext {
	var p = new(Procedural_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_procedural_statement
	return p
}

func (*Procedural_statementContext) IsProcedural_statementContext() {}

func NewProcedural_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_statementContext {
	var p = new(Procedural_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_procedural_statement

	return p
}

func (s *Procedural_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_statementContext) Procedural_continuous_assignments() IProcedural_continuous_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_continuous_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_continuous_assignmentsContext)
}

func (s *Procedural_statementContext) Procedural_timing_control_statement() IProcedural_timing_control_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_timing_control_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_timing_control_statementContext)
}

func (s *Procedural_statementContext) Procedural_assertion_statement() IProcedural_assertion_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_assertion_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_assertion_statementContext)
}

func (s *Procedural_statementContext) Property_statement() IProperty_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_statementContext)
}

func (s *Procedural_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterProcedural_statement(s)
	}
}

func (s *Procedural_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitProcedural_statement(s)
	}
}

func (p *SysVerilogHDLParser) Procedural_statement() (localctx IProcedural_statementContext) {
	localctx = NewProcedural_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, SysVerilogHDLParserRULE_procedural_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2268)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserAssign, SysVerilogHDLParserDeassign, SysVerilogHDLParserForce, SysVerilogHDLParserRelease:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2264)
			p.Procedural_continuous_assignments()
		}

	case SysVerilogHDLParserRepeat, SysVerilogHDLParserAt, SysVerilogHDLParserHash:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2265)
			p.Procedural_timing_control_statement()
		}

	case SysVerilogHDLParserAssert, SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2266)
			p.Procedural_assertion_statement()
		}

	case SysVerilogHDLParserDisable:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2267)
			p.Property_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpression_statementContext is an interface to support dynamic dispatch.
type IExpression_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpression_statementContext differentiates from other interfaces.
	IsExpression_statementContext()
}

type Expression_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_statementContext() *Expression_statementContext {
	var p = new(Expression_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_expression_statement
	return p
}

func (*Expression_statementContext) IsExpression_statementContext() {}

func NewExpression_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_statementContext {
	var p = new(Expression_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_expression_statement

	return p
}

func (s *Expression_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expression_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expression_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterExpression_statement(s)
	}
}

func (s *Expression_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitExpression_statement(s)
	}
}

func (p *SysVerilogHDLParser) Expression_statement() (localctx IExpression_statementContext) {
	localctx = NewExpression_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, SysVerilogHDLParserRULE_expression_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2270)
		p.Expression()
	}

	return localctx
}

// ISubroutine_statementContext is an interface to support dynamic dispatch.
type ISubroutine_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubroutine_statementContext differentiates from other interfaces.
	IsSubroutine_statementContext()
}

type Subroutine_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubroutine_statementContext() *Subroutine_statementContext {
	var p = new(Subroutine_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_subroutine_statement
	return p
}

func (*Subroutine_statementContext) IsSubroutine_statementContext() {}

func NewSubroutine_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subroutine_statementContext {
	var p = new(Subroutine_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_subroutine_statement

	return p
}

func (s *Subroutine_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Subroutine_statementContext) Return_statement() IReturn_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_statementContext)
}

func (s *Subroutine_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subroutine_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subroutine_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterSubroutine_statement(s)
	}
}

func (s *Subroutine_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitSubroutine_statement(s)
	}
}

func (p *SysVerilogHDLParser) Subroutine_statement() (localctx ISubroutine_statementContext) {
	localctx = NewSubroutine_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, SysVerilogHDLParserRULE_subroutine_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2272)
		p.Return_statement()
	}

	return localctx
}

// IReturn_statementContext is an interface to support dynamic dispatch.
type IReturn_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturn_statementContext differentiates from other interfaces.
	IsReturn_statementContext()
}

type Return_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_statementContext() *Return_statementContext {
	var p = new(Return_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_return_statement
	return p
}

func (*Return_statementContext) IsReturn_statementContext() {}

func NewReturn_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_statementContext {
	var p = new(Return_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_return_statement

	return p
}

func (s *Return_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_statementContext) Return() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserReturn, 0)
}

func (s *Return_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Return_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterReturn_statement(s)
	}
}

func (s *Return_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitReturn_statement(s)
	}
}

func (p *SysVerilogHDLParser) Return_statement() (localctx IReturn_statementContext) {
	localctx = NewReturn_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, SysVerilogHDLParserRULE_return_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2277)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2274)
			p.Match(SysVerilogHDLParserReturn)
		}
		{
			p.SetState(2275)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2276)
			p.Match(SysVerilogHDLParserReturn)
		}

	}

	return localctx
}

// INull_statementContext is an interface to support dynamic dispatch.
type INull_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNull_statementContext differentiates from other interfaces.
	IsNull_statementContext()
}

type Null_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_statementContext() *Null_statementContext {
	var p = new(Null_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_null_statement
	return p
}

func (*Null_statementContext) IsNull_statementContext() {}

func NewNull_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_statementContext {
	var p = new(Null_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_null_statement

	return p
}

func (s *Null_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Null_statementContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Null_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Null_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterNull_statement(s)
	}
}

func (s *Null_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitNull_statement(s)
	}
}

func (p *SysVerilogHDLParser) Null_statement() (localctx INull_statementContext) {
	localctx = NewNull_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, SysVerilogHDLParserRULE_null_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2279)
		p.Semicolon()
	}

	return localctx
}

// IProcedural_continuous_assignmentsContext is an interface to support dynamic dispatch.
type IProcedural_continuous_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_continuous_assignmentsContext differentiates from other interfaces.
	IsProcedural_continuous_assignmentsContext()
}

type Procedural_continuous_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_continuous_assignmentsContext() *Procedural_continuous_assignmentsContext {
	var p = new(Procedural_continuous_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_procedural_continuous_assignments
	return p
}

func (*Procedural_continuous_assignmentsContext) IsProcedural_continuous_assignmentsContext() {}

func NewProcedural_continuous_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_continuous_assignmentsContext {
	var p = new(Procedural_continuous_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_procedural_continuous_assignments

	return p
}

func (s *Procedural_continuous_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_continuous_assignmentsContext) Assign_statement() IAssign_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssign_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssign_statementContext)
}

func (s *Procedural_continuous_assignmentsContext) Deassign_statement() IDeassign_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeassign_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeassign_statementContext)
}

func (s *Procedural_continuous_assignmentsContext) Force_statement() IForce_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForce_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForce_statementContext)
}

func (s *Procedural_continuous_assignmentsContext) Release_statement() IRelease_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelease_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelease_statementContext)
}

func (s *Procedural_continuous_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_continuous_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_continuous_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterProcedural_continuous_assignments(s)
	}
}

func (s *Procedural_continuous_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitProcedural_continuous_assignments(s)
	}
}

func (p *SysVerilogHDLParser) Procedural_continuous_assignments() (localctx IProcedural_continuous_assignmentsContext) {
	localctx = NewProcedural_continuous_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, SysVerilogHDLParserRULE_procedural_continuous_assignments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2285)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserAssign:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2281)
			p.Assign_statement()
		}

	case SysVerilogHDLParserDeassign:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2282)
			p.Deassign_statement()
		}

	case SysVerilogHDLParserForce:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2283)
			p.Force_statement()
		}

	case SysVerilogHDLParserRelease:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2284)
			p.Release_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAssign_statementContext is an interface to support dynamic dispatch.
type IAssign_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssign_statementContext differentiates from other interfaces.
	IsAssign_statementContext()
}

type Assign_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssign_statementContext() *Assign_statementContext {
	var p = new(Assign_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_assign_statement
	return p
}

func (*Assign_statementContext) IsAssign_statementContext() {}

func NewAssign_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assign_statementContext {
	var p = new(Assign_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_assign_statement

	return p
}

func (s *Assign_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Assign_statementContext) Assign() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserAssign, 0)
}

func (s *Assign_statementContext) Assignment_statement() IAssignment_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_statementContext)
}

func (s *Assign_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assign_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assign_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAssign_statement(s)
	}
}

func (s *Assign_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAssign_statement(s)
	}
}

func (p *SysVerilogHDLParser) Assign_statement() (localctx IAssign_statementContext) {
	localctx = NewAssign_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, SysVerilogHDLParserRULE_assign_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2287)
		p.Match(SysVerilogHDLParserAssign)
	}
	{
		p.SetState(2288)
		p.Assignment_statement()
	}

	return localctx
}

// IDeassign_statementContext is an interface to support dynamic dispatch.
type IDeassign_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeassign_statementContext differentiates from other interfaces.
	IsDeassign_statementContext()
}

type Deassign_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeassign_statementContext() *Deassign_statementContext {
	var p = new(Deassign_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_deassign_statement
	return p
}

func (*Deassign_statementContext) IsDeassign_statementContext() {}

func NewDeassign_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Deassign_statementContext {
	var p = new(Deassign_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_deassign_statement

	return p
}

func (s *Deassign_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Deassign_statementContext) Deassign() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDeassign, 0)
}

func (s *Deassign_statementContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Deassign_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Deassign_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Deassign_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDeassign_statement(s)
	}
}

func (s *Deassign_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDeassign_statement(s)
	}
}

func (p *SysVerilogHDLParser) Deassign_statement() (localctx IDeassign_statementContext) {
	localctx = NewDeassign_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, SysVerilogHDLParserRULE_deassign_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2290)
		p.Match(SysVerilogHDLParserDeassign)
	}
	{
		p.SetState(2291)
		p.Variable_lvalue()
	}

	return localctx
}

// IForce_statementContext is an interface to support dynamic dispatch.
type IForce_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForce_statementContext differentiates from other interfaces.
	IsForce_statementContext()
}

type Force_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForce_statementContext() *Force_statementContext {
	var p = new(Force_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_force_statement
	return p
}

func (*Force_statementContext) IsForce_statementContext() {}

func NewForce_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Force_statementContext {
	var p = new(Force_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_force_statement

	return p
}

func (s *Force_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Force_statementContext) Force() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserForce, 0)
}

func (s *Force_statementContext) Assignment_statement() IAssignment_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_statementContext)
}

func (s *Force_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Force_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Force_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterForce_statement(s)
	}
}

func (s *Force_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitForce_statement(s)
	}
}

func (p *SysVerilogHDLParser) Force_statement() (localctx IForce_statementContext) {
	localctx = NewForce_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, SysVerilogHDLParserRULE_force_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2293)
		p.Match(SysVerilogHDLParserForce)
	}
	{
		p.SetState(2294)
		p.Assignment_statement()
	}

	return localctx
}

// IRelease_statementContext is an interface to support dynamic dispatch.
type IRelease_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelease_statementContext differentiates from other interfaces.
	IsRelease_statementContext()
}

type Release_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelease_statementContext() *Release_statementContext {
	var p = new(Release_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_release_statement
	return p
}

func (*Release_statementContext) IsRelease_statementContext() {}

func NewRelease_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Release_statementContext {
	var p = new(Release_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_release_statement

	return p
}

func (s *Release_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Release_statementContext) Release() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRelease, 0)
}

func (s *Release_statementContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Release_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Release_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Release_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterRelease_statement(s)
	}
}

func (s *Release_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitRelease_statement(s)
	}
}

func (p *SysVerilogHDLParser) Release_statement() (localctx IRelease_statementContext) {
	localctx = NewRelease_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, SysVerilogHDLParserRULE_release_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2296)
		p.Match(SysVerilogHDLParserRelease)
	}
	{
		p.SetState(2297)
		p.Variable_lvalue()
	}

	return localctx
}

// IProcedural_timing_control_statementContext is an interface to support dynamic dispatch.
type IProcedural_timing_control_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_timing_control_statementContext differentiates from other interfaces.
	IsProcedural_timing_control_statementContext()
}

type Procedural_timing_control_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_timing_control_statementContext() *Procedural_timing_control_statementContext {
	var p = new(Procedural_timing_control_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_procedural_timing_control_statement
	return p
}

func (*Procedural_timing_control_statementContext) IsProcedural_timing_control_statementContext() {}

func NewProcedural_timing_control_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_timing_control_statementContext {
	var p = new(Procedural_timing_control_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_procedural_timing_control_statement

	return p
}

func (s *Procedural_timing_control_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_timing_control_statementContext) Delay_or_event_control() IDelay_or_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_or_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_or_event_controlContext)
}

func (s *Procedural_timing_control_statementContext) Statement_semicolon() IStatement_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_semicolonContext)
}

func (s *Procedural_timing_control_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_timing_control_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_timing_control_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterProcedural_timing_control_statement(s)
	}
}

func (s *Procedural_timing_control_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitProcedural_timing_control_statement(s)
	}
}

func (p *SysVerilogHDLParser) Procedural_timing_control_statement() (localctx IProcedural_timing_control_statementContext) {
	localctx = NewProcedural_timing_control_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, SysVerilogHDLParserRULE_procedural_timing_control_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2299)
		p.Delay_or_event_control()
	}
	{
		p.SetState(2300)
		p.Statement_semicolon()
	}

	return localctx
}

// IProperty_statementContext is an interface to support dynamic dispatch.
type IProperty_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_statementContext differentiates from other interfaces.
	IsProperty_statementContext()
}

type Property_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_statementContext() *Property_statementContext {
	var p = new(Property_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_property_statement
	return p
}

func (*Property_statementContext) IsProperty_statementContext() {}

func NewProperty_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_statementContext {
	var p = new(Property_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_property_statement

	return p
}

func (s *Property_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_statementContext) Disable_condition_statement() IDisable_condition_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisable_condition_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisable_condition_statementContext)
}

func (s *Property_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Property_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterProperty_statement(s)
	}
}

func (s *Property_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitProperty_statement(s)
	}
}

func (p *SysVerilogHDLParser) Property_statement() (localctx IProperty_statementContext) {
	localctx = NewProperty_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, SysVerilogHDLParserRULE_property_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2302)
		p.Disable_condition_statement()
	}

	return localctx
}

// IDisable_condition_statementContext is an interface to support dynamic dispatch.
type IDisable_condition_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisable_condition_statementContext differentiates from other interfaces.
	IsDisable_condition_statementContext()
}

type Disable_condition_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisable_condition_statementContext() *Disable_condition_statementContext {
	var p = new(Disable_condition_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_disable_condition_statement
	return p
}

func (*Disable_condition_statementContext) IsDisable_condition_statementContext() {}

func NewDisable_condition_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Disable_condition_statementContext {
	var p = new(Disable_condition_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_disable_condition_statement

	return p
}

func (s *Disable_condition_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Disable_condition_statementContext) Disable() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDisable, 0)
}

func (s *Disable_condition_statementContext) Iff() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserIff, 0)
}

func (s *Disable_condition_statementContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Disable_condition_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Disable_condition_statementContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Disable_condition_statementContext) Property_expression() IProperty_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_expressionContext)
}

func (s *Disable_condition_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Disable_condition_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Disable_condition_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDisable_condition_statement(s)
	}
}

func (s *Disable_condition_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDisable_condition_statement(s)
	}
}

func (p *SysVerilogHDLParser) Disable_condition_statement() (localctx IDisable_condition_statementContext) {
	localctx = NewDisable_condition_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, SysVerilogHDLParserRULE_disable_condition_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2304)
		p.Match(SysVerilogHDLParserDisable)
	}
	{
		p.SetState(2305)
		p.Match(SysVerilogHDLParserIff)
	}
	{
		p.SetState(2306)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2307)
		p.Expression()
	}
	{
		p.SetState(2308)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}
	{
		p.SetState(2309)
		p.Property_expression()
	}

	return localctx
}

// IProperty_expressionContext is an interface to support dynamic dispatch.
type IProperty_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_expressionContext differentiates from other interfaces.
	IsProperty_expressionContext()
}

type Property_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_expressionContext() *Property_expressionContext {
	var p = new(Property_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_property_expression
	return p
}

func (*Property_expressionContext) IsProperty_expressionContext() {}

func NewProperty_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_expressionContext {
	var p = new(Property_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_property_expression

	return p
}

func (s *Property_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Property_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Property_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterProperty_expression(s)
	}
}

func (s *Property_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitProperty_expression(s)
	}
}

func (p *SysVerilogHDLParser) Property_expression() (localctx IProperty_expressionContext) {
	localctx = NewProperty_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, SysVerilogHDLParserRULE_property_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2311)
		p.Expression()
	}

	return localctx
}

// IProcedural_assertion_statementContext is an interface to support dynamic dispatch.
type IProcedural_assertion_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_assertion_statementContext differentiates from other interfaces.
	IsProcedural_assertion_statementContext()
}

type Procedural_assertion_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_assertion_statementContext() *Procedural_assertion_statementContext {
	var p = new(Procedural_assertion_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_procedural_assertion_statement
	return p
}

func (*Procedural_assertion_statementContext) IsProcedural_assertion_statementContext() {}

func NewProcedural_assertion_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_assertion_statementContext {
	var p = new(Procedural_assertion_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_procedural_assertion_statement

	return p
}

func (s *Procedural_assertion_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_assertion_statementContext) Assert_statement() IAssert_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssert_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssert_statementContext)
}

func (s *Procedural_assertion_statementContext) Assert_else_statement() IAssert_else_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssert_else_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssert_else_statementContext)
}

func (s *Procedural_assertion_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_assertion_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_assertion_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterProcedural_assertion_statement(s)
	}
}

func (s *Procedural_assertion_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitProcedural_assertion_statement(s)
	}
}

func (p *SysVerilogHDLParser) Procedural_assertion_statement() (localctx IProcedural_assertion_statementContext) {
	localctx = NewProcedural_assertion_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, SysVerilogHDLParserRULE_procedural_assertion_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2313)
		p.Assert_statement()
	}
	p.SetState(2315)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2314)
			p.Assert_else_statement()
		}

	}

	return localctx
}

// IAssert_else_statementContext is an interface to support dynamic dispatch.
type IAssert_else_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssert_else_statementContext differentiates from other interfaces.
	IsAssert_else_statementContext()
}

type Assert_else_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssert_else_statementContext() *Assert_else_statementContext {
	var p = new(Assert_else_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_assert_else_statement
	return p
}

func (*Assert_else_statementContext) IsAssert_else_statementContext() {}

func NewAssert_else_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assert_else_statementContext {
	var p = new(Assert_else_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_assert_else_statement

	return p
}

func (s *Assert_else_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Assert_else_statementContext) Else() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserElse, 0)
}

func (s *Assert_else_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Assert_else_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assert_else_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assert_else_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAssert_else_statement(s)
	}
}

func (s *Assert_else_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAssert_else_statement(s)
	}
}

func (p *SysVerilogHDLParser) Assert_else_statement() (localctx IAssert_else_statementContext) {
	localctx = NewAssert_else_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, SysVerilogHDLParserRULE_assert_else_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2317)
		p.Match(SysVerilogHDLParserElse)
	}
	{
		p.SetState(2318)
		p.Statement()
	}

	return localctx
}

// IAssert_statementContext is an interface to support dynamic dispatch.
type IAssert_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssert_statementContext differentiates from other interfaces.
	IsAssert_statementContext()
}

type Assert_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssert_statementContext() *Assert_statementContext {
	var p = new(Assert_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_assert_statement
	return p
}

func (*Assert_statementContext) IsAssert_statementContext() {}

func NewAssert_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assert_statementContext {
	var p = new(Assert_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_assert_statement

	return p
}

func (s *Assert_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Assert_statementContext) Assert() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserAssert, 0)
}

func (s *Assert_statementContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Assert_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Assert_statementContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Assert_statementContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Assert_statementContext) Colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserColon, 0)
}

func (s *Assert_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assert_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assert_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAssert_statement(s)
	}
}

func (s *Assert_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAssert_statement(s)
	}
}

func (p *SysVerilogHDLParser) Assert_statement() (localctx IAssert_statementContext) {
	localctx = NewAssert_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, SysVerilogHDLParserRULE_assert_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2323)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserEscaped_identifier || _la == SysVerilogHDLParserSimple_identifier {
		{
			p.SetState(2320)
			p.Hierarchical_identifier()
		}
		{
			p.SetState(2321)
			p.Match(SysVerilogHDLParserColon)
		}

	}
	{
		p.SetState(2325)
		p.Match(SysVerilogHDLParserAssert)
	}
	{
		p.SetState(2326)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2327)
		p.Expression()
	}
	{
		p.SetState(2328)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// ISystem_task_enableContext is an interface to support dynamic dispatch.
type ISystem_task_enableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_task_enableContext differentiates from other interfaces.
	IsSystem_task_enableContext()
}

type System_task_enableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_task_enableContext() *System_task_enableContext {
	var p = new(System_task_enableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_system_task_enable
	return p
}

func (*System_task_enableContext) IsSystem_task_enableContext() {}

func NewSystem_task_enableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_task_enableContext {
	var p = new(System_task_enableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_system_task_enable

	return p
}

func (s *System_task_enableContext) GetParser() antlr.Parser { return s.parser }

func (s *System_task_enableContext) System_task_identifier() ISystem_task_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_task_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_task_identifierContext)
}

func (s *System_task_enableContext) Task_interface_assignments() ITask_interface_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_interface_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_interface_assignmentsContext)
}

func (s *System_task_enableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_task_enableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_task_enableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterSystem_task_enable(s)
	}
}

func (s *System_task_enableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitSystem_task_enable(s)
	}
}

func (p *SysVerilogHDLParser) System_task_enable() (localctx ISystem_task_enableContext) {
	localctx = NewSystem_task_enableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, SysVerilogHDLParserRULE_system_task_enable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2330)
		p.System_task_identifier()
	}
	p.SetState(2332)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2331)
			p.Task_interface_assignments()
		}

	}

	return localctx
}

// ISystem_task_identifierContext is an interface to support dynamic dispatch.
type ISystem_task_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_task_identifierContext differentiates from other interfaces.
	IsSystem_task_identifierContext()
}

type System_task_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_task_identifierContext() *System_task_identifierContext {
	var p = new(System_task_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_system_task_identifier
	return p
}

func (*System_task_identifierContext) IsSystem_task_identifierContext() {}

func NewSystem_task_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_task_identifierContext {
	var p = new(System_task_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_system_task_identifier

	return p
}

func (s *System_task_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *System_task_identifierContext) Dollar_Identifier() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDollar_Identifier, 0)
}

func (s *System_task_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_task_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_task_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterSystem_task_identifier(s)
	}
}

func (s *System_task_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitSystem_task_identifier(s)
	}
}

func (p *SysVerilogHDLParser) System_task_identifier() (localctx ISystem_task_identifierContext) {
	localctx = NewSystem_task_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, SysVerilogHDLParserRULE_system_task_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2334)
		p.Match(SysVerilogHDLParserDollar_Identifier)
	}

	return localctx
}

// ITask_interface_assignmentsContext is an interface to support dynamic dispatch.
type ITask_interface_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_interface_assignmentsContext differentiates from other interfaces.
	IsTask_interface_assignmentsContext()
}

type Task_interface_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_interface_assignmentsContext() *Task_interface_assignmentsContext {
	var p = new(Task_interface_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_task_interface_assignments
	return p
}

func (*Task_interface_assignmentsContext) IsTask_interface_assignmentsContext() {}

func NewTask_interface_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_interface_assignmentsContext {
	var p = new(Task_interface_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_task_interface_assignments

	return p
}

func (s *Task_interface_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_interface_assignmentsContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Task_interface_assignmentsContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Task_interface_assignmentsContext) List_of_interface_assignments() IList_of_interface_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_interface_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_interface_assignmentsContext)
}

func (s *Task_interface_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_interface_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_interface_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTask_interface_assignments(s)
	}
}

func (s *Task_interface_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTask_interface_assignments(s)
	}
}

func (p *SysVerilogHDLParser) Task_interface_assignments() (localctx ITask_interface_assignmentsContext) {
	localctx = NewTask_interface_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, SysVerilogHDLParserRULE_task_interface_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2336)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	p.SetState(2338)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SysVerilogHDLParserT__1)|(1<<SysVerilogHDLParserT__2)|(1<<SysVerilogHDLParserT__3)|(1<<SysVerilogHDLParserT__4)|(1<<SysVerilogHDLParserT__5)|(1<<SysVerilogHDLParserT__6)|(1<<SysVerilogHDLParserT__7)|(1<<SysVerilogHDLParserT__8)|(1<<SysVerilogHDLParserT__9)|(1<<SysVerilogHDLParserT__10)|(1<<SysVerilogHDLParserT__26)|(1<<SysVerilogHDLParserT__27))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(SysVerilogHDLParserBinary_number-42))|(1<<(SysVerilogHDLParserDecimal_number-42))|(1<<(SysVerilogHDLParserFixed_point_number-42))|(1<<(SysVerilogHDLParserHex_number-42))|(1<<(SysVerilogHDLParserOctal_number-42))|(1<<(SysVerilogHDLParserReal_exp_form-42)))) != 0) || _la == SysVerilogHDLParserInt || _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned || (((_la-201)&-(0x1f+1)) == 0 && ((1<<uint((_la-201)))&((1<<(SysVerilogHDLParserDollar_Identifier-201))|(1<<(SysVerilogHDLParserEscaped_identifier-201))|(1<<(SysVerilogHDLParserSimple_identifier-201))|(1<<(SysVerilogHDLParserString_literal-201))|(1<<(SysVerilogHDLParserDot-201))|(1<<(SysVerilogHDLParserLeft_curly_bracket-201))|(1<<(SysVerilogHDLParserOpen_parenthesis-201))|(1<<(SysVerilogHDLParserQuote-201))|(1<<(SysVerilogHDLParserTilde-201)))) != 0) {
		{
			p.SetState(2337)
			p.List_of_interface_assignments()
		}

	}
	{
		p.SetState(2340)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// ITask_enableContext is an interface to support dynamic dispatch.
type ITask_enableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_enableContext differentiates from other interfaces.
	IsTask_enableContext()
}

type Task_enableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_enableContext() *Task_enableContext {
	var p = new(Task_enableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_task_enable
	return p
}

func (*Task_enableContext) IsTask_enableContext() {}

func NewTask_enableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_enableContext {
	var p = new(Task_enableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_task_enable

	return p
}

func (s *Task_enableContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_enableContext) Hierarchical_task_identifier() IHierarchical_task_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_task_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_task_identifierContext)
}

func (s *Task_enableContext) Task_interface_assignments() ITask_interface_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_interface_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_interface_assignmentsContext)
}

func (s *Task_enableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_enableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_enableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTask_enable(s)
	}
}

func (s *Task_enableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTask_enable(s)
	}
}

func (p *SysVerilogHDLParser) Task_enable() (localctx ITask_enableContext) {
	localctx = NewTask_enableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, SysVerilogHDLParserRULE_task_enable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2342)
		p.Hierarchical_task_identifier()
	}
	p.SetState(2344)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 175, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2343)
			p.Task_interface_assignments()
		}

	}

	return localctx
}

// IHierarchical_task_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_task_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_task_identifierContext differentiates from other interfaces.
	IsHierarchical_task_identifierContext()
}

type Hierarchical_task_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_task_identifierContext() *Hierarchical_task_identifierContext {
	var p = new(Hierarchical_task_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_task_identifier
	return p
}

func (*Hierarchical_task_identifierContext) IsHierarchical_task_identifierContext() {}

func NewHierarchical_task_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_task_identifierContext {
	var p = new(Hierarchical_task_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_task_identifier

	return p
}

func (s *Hierarchical_task_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_task_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_task_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_task_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_task_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterHierarchical_task_identifier(s)
	}
}

func (s *Hierarchical_task_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitHierarchical_task_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Hierarchical_task_identifier() (localctx IHierarchical_task_identifierContext) {
	localctx = NewHierarchical_task_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, SysVerilogHDLParserRULE_hierarchical_task_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2346)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IDisable_statementContext is an interface to support dynamic dispatch.
type IDisable_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisable_statementContext differentiates from other interfaces.
	IsDisable_statementContext()
}

type Disable_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisable_statementContext() *Disable_statementContext {
	var p = new(Disable_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_disable_statement
	return p
}

func (*Disable_statementContext) IsDisable_statementContext() {}

func NewDisable_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Disable_statementContext {
	var p = new(Disable_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_disable_statement

	return p
}

func (s *Disable_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Disable_statementContext) Disable() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDisable, 0)
}

func (s *Disable_statementContext) Hierarchical_task_identifier() IHierarchical_task_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_task_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_task_identifierContext)
}

func (s *Disable_statementContext) Hierarchical_block_identifier() IHierarchical_block_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_block_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_block_identifierContext)
}

func (s *Disable_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Disable_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Disable_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDisable_statement(s)
	}
}

func (s *Disable_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDisable_statement(s)
	}
}

func (p *SysVerilogHDLParser) Disable_statement() (localctx IDisable_statementContext) {
	localctx = NewDisable_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, SysVerilogHDLParserRULE_disable_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2352)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2348)
			p.Match(SysVerilogHDLParserDisable)
		}
		{
			p.SetState(2349)
			p.Hierarchical_task_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2350)
			p.Match(SysVerilogHDLParserDisable)
		}
		{
			p.SetState(2351)
			p.Hierarchical_block_identifier()
		}

	}

	return localctx
}

// IHierarchical_block_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_block_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_block_identifierContext differentiates from other interfaces.
	IsHierarchical_block_identifierContext()
}

type Hierarchical_block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_block_identifierContext() *Hierarchical_block_identifierContext {
	var p = new(Hierarchical_block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_block_identifier
	return p
}

func (*Hierarchical_block_identifierContext) IsHierarchical_block_identifierContext() {}

func NewHierarchical_block_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_block_identifierContext {
	var p = new(Hierarchical_block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_block_identifier

	return p
}

func (s *Hierarchical_block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_block_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterHierarchical_block_identifier(s)
	}
}

func (s *Hierarchical_block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitHierarchical_block_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Hierarchical_block_identifier() (localctx IHierarchical_block_identifierContext) {
	localctx = NewHierarchical_block_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, SysVerilogHDLParserRULE_hierarchical_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2354)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IVariable_lvalueContext is an interface to support dynamic dispatch.
type IVariable_lvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_lvalueContext differentiates from other interfaces.
	IsVariable_lvalueContext()
}

type Variable_lvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_lvalueContext() *Variable_lvalueContext {
	var p = new(Variable_lvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_variable_lvalue
	return p
}

func (*Variable_lvalueContext) IsVariable_lvalueContext() {}

func NewVariable_lvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_lvalueContext {
	var p = new(Variable_lvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_variable_lvalue

	return p
}

func (s *Variable_lvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_lvalueContext) Hierarchical_variable_lvalue() IHierarchical_variable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_variable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_variable_lvalueContext)
}

func (s *Variable_lvalueContext) Variable_concatenation() IVariable_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_concatenationContext)
}

func (s *Variable_lvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_lvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_lvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterVariable_lvalue(s)
	}
}

func (s *Variable_lvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitVariable_lvalue(s)
	}
}

func (p *SysVerilogHDLParser) Variable_lvalue() (localctx IVariable_lvalueContext) {
	localctx = NewVariable_lvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, SysVerilogHDLParserRULE_variable_lvalue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2358)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2356)
			p.Hierarchical_variable_lvalue()
		}

	case SysVerilogHDLParserLeft_curly_bracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2357)
			p.Variable_concatenation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHierarchical_variable_lvalueContext is an interface to support dynamic dispatch.
type IHierarchical_variable_lvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_variable_lvalueContext differentiates from other interfaces.
	IsHierarchical_variable_lvalueContext()
}

type Hierarchical_variable_lvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_variable_lvalueContext() *Hierarchical_variable_lvalueContext {
	var p = new(Hierarchical_variable_lvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_variable_lvalue
	return p
}

func (*Hierarchical_variable_lvalueContext) IsHierarchical_variable_lvalueContext() {}

func NewHierarchical_variable_lvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_variable_lvalueContext {
	var p = new(Hierarchical_variable_lvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_variable_lvalue

	return p
}

func (s *Hierarchical_variable_lvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_variable_lvalueContext) Primary_hierarchical_identifier() IPrimary_hierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_hierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_hierarchical_identifierContext)
}

func (s *Hierarchical_variable_lvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_variable_lvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_variable_lvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterHierarchical_variable_lvalue(s)
	}
}

func (s *Hierarchical_variable_lvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitHierarchical_variable_lvalue(s)
	}
}

func (p *SysVerilogHDLParser) Hierarchical_variable_lvalue() (localctx IHierarchical_variable_lvalueContext) {
	localctx = NewHierarchical_variable_lvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, SysVerilogHDLParserRULE_hierarchical_variable_lvalue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2360)
		p.Primary_hierarchical_identifier()
	}

	return localctx
}

// IVariable_concatenationContext is an interface to support dynamic dispatch.
type IVariable_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_concatenationContext differentiates from other interfaces.
	IsVariable_concatenationContext()
}

type Variable_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_concatenationContext() *Variable_concatenationContext {
	var p = new(Variable_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_variable_concatenation
	return p
}

func (*Variable_concatenationContext) IsVariable_concatenationContext() {}

func NewVariable_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_concatenationContext {
	var p = new(Variable_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_variable_concatenation

	return p
}

func (s *Variable_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_concatenationContext) Left_curly_bracket() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserLeft_curly_bracket, 0)
}

func (s *Variable_concatenationContext) Variable_concatenation_value() IVariable_concatenation_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_concatenation_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_concatenation_valueContext)
}

func (s *Variable_concatenationContext) Comma_vcv_star() IComma_vcv_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_vcv_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_vcv_starContext)
}

func (s *Variable_concatenationContext) Right_curly_bracket() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRight_curly_bracket, 0)
}

func (s *Variable_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterVariable_concatenation(s)
	}
}

func (s *Variable_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitVariable_concatenation(s)
	}
}

func (p *SysVerilogHDLParser) Variable_concatenation() (localctx IVariable_concatenationContext) {
	localctx = NewVariable_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, SysVerilogHDLParserRULE_variable_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2362)
		p.Match(SysVerilogHDLParserLeft_curly_bracket)
	}
	{
		p.SetState(2363)
		p.Variable_concatenation_value()
	}
	{
		p.SetState(2364)
		p.Comma_vcv_star()
	}
	{
		p.SetState(2365)
		p.Match(SysVerilogHDLParserRight_curly_bracket)
	}

	return localctx
}

// IVariable_concatenation_valueContext is an interface to support dynamic dispatch.
type IVariable_concatenation_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_concatenation_valueContext differentiates from other interfaces.
	IsVariable_concatenation_valueContext()
}

type Variable_concatenation_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_concatenation_valueContext() *Variable_concatenation_valueContext {
	var p = new(Variable_concatenation_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_variable_concatenation_value
	return p
}

func (*Variable_concatenation_valueContext) IsVariable_concatenation_valueContext() {}

func NewVariable_concatenation_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_concatenation_valueContext {
	var p = new(Variable_concatenation_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_variable_concatenation_value

	return p
}

func (s *Variable_concatenation_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_concatenation_valueContext) Primary_hierarchical_identifier() IPrimary_hierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_hierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_hierarchical_identifierContext)
}

func (s *Variable_concatenation_valueContext) Variable_concatenation() IVariable_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_concatenationContext)
}

func (s *Variable_concatenation_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_concatenation_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_concatenation_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterVariable_concatenation_value(s)
	}
}

func (s *Variable_concatenation_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitVariable_concatenation_value(s)
	}
}

func (p *SysVerilogHDLParser) Variable_concatenation_value() (localctx IVariable_concatenation_valueContext) {
	localctx = NewVariable_concatenation_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, SysVerilogHDLParserRULE_variable_concatenation_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2369)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2367)
			p.Primary_hierarchical_identifier()
		}

	case SysVerilogHDLParserLeft_curly_bracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2368)
			p.Variable_concatenation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IComma_vcv_starContext is an interface to support dynamic dispatch.
type IComma_vcv_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_vcv_starContext differentiates from other interfaces.
	IsComma_vcv_starContext()
}

type Comma_vcv_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_vcv_starContext() *Comma_vcv_starContext {
	var p = new(Comma_vcv_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_vcv_star
	return p
}

func (*Comma_vcv_starContext) IsComma_vcv_starContext() {}

func NewComma_vcv_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_vcv_starContext {
	var p = new(Comma_vcv_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_vcv_star

	return p
}

func (s *Comma_vcv_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_vcv_starContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SysVerilogHDLParserComma)
}

func (s *Comma_vcv_starContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, i)
}

func (s *Comma_vcv_starContext) AllVariable_concatenation_value() []IVariable_concatenation_valueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_concatenation_valueContext)(nil)).Elem())
	var tst = make([]IVariable_concatenation_valueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_concatenation_valueContext)
		}
	}

	return tst
}

func (s *Comma_vcv_starContext) Variable_concatenation_value(i int) IVariable_concatenation_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_concatenation_valueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_concatenation_valueContext)
}

func (s *Comma_vcv_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_vcv_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_vcv_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_vcv_star(s)
	}
}

func (s *Comma_vcv_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_vcv_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_vcv_star() (localctx IComma_vcv_starContext) {
	localctx = NewComma_vcv_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, SysVerilogHDLParserRULE_comma_vcv_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2375)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(2371)
			p.Match(SysVerilogHDLParserComma)
		}
		{
			p.SetState(2372)
			p.Variable_concatenation_value()
		}

		p.SetState(2377)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBlocking_assignmentContext is an interface to support dynamic dispatch.
type IBlocking_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlocking_assignmentContext differentiates from other interfaces.
	IsBlocking_assignmentContext()
}

type Blocking_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlocking_assignmentContext() *Blocking_assignmentContext {
	var p = new(Blocking_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_blocking_assignment
	return p
}

func (*Blocking_assignmentContext) IsBlocking_assignmentContext() {}

func NewBlocking_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Blocking_assignmentContext {
	var p = new(Blocking_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_blocking_assignment

	return p
}

func (s *Blocking_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Blocking_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Blocking_assignmentContext) Equal() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEqual, 0)
}

func (s *Blocking_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Blocking_assignmentContext) Delay_or_event_control() IDelay_or_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_or_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_or_event_controlContext)
}

func (s *Blocking_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Blocking_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Blocking_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterBlocking_assignment(s)
	}
}

func (s *Blocking_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitBlocking_assignment(s)
	}
}

func (p *SysVerilogHDLParser) Blocking_assignment() (localctx IBlocking_assignmentContext) {
	localctx = NewBlocking_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, SysVerilogHDLParserRULE_blocking_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2378)
		p.Variable_lvalue()
	}
	{
		p.SetState(2379)
		p.Match(SysVerilogHDLParserEqual)
	}
	p.SetState(2381)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserRepeat || _la == SysVerilogHDLParserAt || _la == SysVerilogHDLParserHash {
		{
			p.SetState(2380)
			p.Delay_or_event_control()
		}

	}
	{
		p.SetState(2383)
		p.Expression()
	}

	return localctx
}

// INonblocking_assignmentContext is an interface to support dynamic dispatch.
type INonblocking_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonblocking_assignmentContext differentiates from other interfaces.
	IsNonblocking_assignmentContext()
}

type Nonblocking_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonblocking_assignmentContext() *Nonblocking_assignmentContext {
	var p = new(Nonblocking_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_nonblocking_assignment
	return p
}

func (*Nonblocking_assignmentContext) IsNonblocking_assignmentContext() {}

func NewNonblocking_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nonblocking_assignmentContext {
	var p = new(Nonblocking_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_nonblocking_assignment

	return p
}

func (s *Nonblocking_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Nonblocking_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Nonblocking_assignmentContext) Left_angle_equals() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserLeft_angle_equals, 0)
}

func (s *Nonblocking_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Nonblocking_assignmentContext) Delay_or_event_control() IDelay_or_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_or_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_or_event_controlContext)
}

func (s *Nonblocking_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nonblocking_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nonblocking_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterNonblocking_assignment(s)
	}
}

func (s *Nonblocking_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitNonblocking_assignment(s)
	}
}

func (p *SysVerilogHDLParser) Nonblocking_assignment() (localctx INonblocking_assignmentContext) {
	localctx = NewNonblocking_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, SysVerilogHDLParserRULE_nonblocking_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2385)
		p.Variable_lvalue()
	}
	{
		p.SetState(2386)
		p.Match(SysVerilogHDLParserLeft_angle_equals)
	}
	p.SetState(2388)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserRepeat || _la == SysVerilogHDLParserAt || _la == SysVerilogHDLParserHash {
		{
			p.SetState(2387)
			p.Delay_or_event_control()
		}

	}
	{
		p.SetState(2390)
		p.Expression()
	}

	return localctx
}

// IPrefix_assignmentContext is an interface to support dynamic dispatch.
type IPrefix_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrefix_assignmentContext differentiates from other interfaces.
	IsPrefix_assignmentContext()
}

type Prefix_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefix_assignmentContext() *Prefix_assignmentContext {
	var p = new(Prefix_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_prefix_assignment
	return p
}

func (*Prefix_assignmentContext) IsPrefix_assignmentContext() {}

func NewPrefix_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Prefix_assignmentContext {
	var p = new(Prefix_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_prefix_assignment

	return p
}

func (s *Prefix_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Prefix_assignmentContext) Unary_assign_operator() IUnary_assign_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_assign_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_assign_operatorContext)
}

func (s *Prefix_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Prefix_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Prefix_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Prefix_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPrefix_assignment(s)
	}
}

func (s *Prefix_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPrefix_assignment(s)
	}
}

func (p *SysVerilogHDLParser) Prefix_assignment() (localctx IPrefix_assignmentContext) {
	localctx = NewPrefix_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, SysVerilogHDLParserRULE_prefix_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2392)
		p.Unary_assign_operator()
	}
	{
		p.SetState(2393)
		p.Variable_lvalue()
	}

	return localctx
}

// IPostfix_assignmentContext is an interface to support dynamic dispatch.
type IPostfix_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfix_assignmentContext differentiates from other interfaces.
	IsPostfix_assignmentContext()
}

type Postfix_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfix_assignmentContext() *Postfix_assignmentContext {
	var p = new(Postfix_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_postfix_assignment
	return p
}

func (*Postfix_assignmentContext) IsPostfix_assignmentContext() {}

func NewPostfix_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Postfix_assignmentContext {
	var p = new(Postfix_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_postfix_assignment

	return p
}

func (s *Postfix_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Postfix_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Postfix_assignmentContext) Unary_assign_operator() IUnary_assign_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_assign_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_assign_operatorContext)
}

func (s *Postfix_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Postfix_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Postfix_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPostfix_assignment(s)
	}
}

func (s *Postfix_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPostfix_assignment(s)
	}
}

func (p *SysVerilogHDLParser) Postfix_assignment() (localctx IPostfix_assignmentContext) {
	localctx = NewPostfix_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, SysVerilogHDLParserRULE_postfix_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2395)
		p.Variable_lvalue()
	}
	{
		p.SetState(2396)
		p.Unary_assign_operator()
	}

	return localctx
}

// IOperator_assignmentContext is an interface to support dynamic dispatch.
type IOperator_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperator_assignmentContext differentiates from other interfaces.
	IsOperator_assignmentContext()
}

type Operator_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperator_assignmentContext() *Operator_assignmentContext {
	var p = new(Operator_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_operator_assignment
	return p
}

func (*Operator_assignmentContext) IsOperator_assignmentContext() {}

func NewOperator_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Operator_assignmentContext {
	var p = new(Operator_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_operator_assignment

	return p
}

func (s *Operator_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Operator_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Operator_assignmentContext) Binary_assign_operator() IBinary_assign_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_assign_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinary_assign_operatorContext)
}

func (s *Operator_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Operator_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Operator_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Operator_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterOperator_assignment(s)
	}
}

func (s *Operator_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitOperator_assignment(s)
	}
}

func (p *SysVerilogHDLParser) Operator_assignment() (localctx IOperator_assignmentContext) {
	localctx = NewOperator_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, SysVerilogHDLParserRULE_operator_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2398)
		p.Variable_lvalue()
	}
	{
		p.SetState(2399)
		p.Binary_assign_operator()
	}
	{
		p.SetState(2400)
		p.Expression()
	}

	return localctx
}

// IDeclarative_assignmentContext is an interface to support dynamic dispatch.
type IDeclarative_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarative_assignmentContext differentiates from other interfaces.
	IsDeclarative_assignmentContext()
}

type Declarative_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarative_assignmentContext() *Declarative_assignmentContext {
	var p = new(Declarative_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_declarative_assignment
	return p
}

func (*Declarative_assignmentContext) IsDeclarative_assignmentContext() {}

func NewDeclarative_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declarative_assignmentContext {
	var p = new(Declarative_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_declarative_assignment

	return p
}

func (s *Declarative_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Declarative_assignmentContext) Reg_declaration() IReg_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReg_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReg_declarationContext)
}

func (s *Declarative_assignmentContext) Logic_declaration() ILogic_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogic_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogic_declarationContext)
}

func (s *Declarative_assignmentContext) Bits_declaration() IBits_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBits_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBits_declarationContext)
}

func (s *Declarative_assignmentContext) Integer_declaration() IInteger_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_declarationContext)
}

func (s *Declarative_assignmentContext) Int_declaration() IInt_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_declarationContext)
}

func (s *Declarative_assignmentContext) Genvar_declaration() IGenvar_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_declarationContext)
}

func (s *Declarative_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declarative_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declarative_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDeclarative_assignment(s)
	}
}

func (s *Declarative_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDeclarative_assignment(s)
	}
}

func (p *SysVerilogHDLParser) Declarative_assignment() (localctx IDeclarative_assignmentContext) {
	localctx = NewDeclarative_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, SysVerilogHDLParserRULE_declarative_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2408)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2402)
			p.Reg_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2403)
			p.Logic_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2404)
			p.Bits_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2405)
			p.Integer_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2406)
			p.Int_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2407)
			p.Genvar_declaration()
		}

	}

	return localctx
}

// IDelay_or_event_controlContext is an interface to support dynamic dispatch.
type IDelay_or_event_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_or_event_controlContext differentiates from other interfaces.
	IsDelay_or_event_controlContext()
}

type Delay_or_event_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_or_event_controlContext() *Delay_or_event_controlContext {
	var p = new(Delay_or_event_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_delay_or_event_control
	return p
}

func (*Delay_or_event_controlContext) IsDelay_or_event_controlContext() {}

func NewDelay_or_event_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_or_event_controlContext {
	var p = new(Delay_or_event_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_delay_or_event_control

	return p
}

func (s *Delay_or_event_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_or_event_controlContext) Delay_control() IDelay_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_controlContext)
}

func (s *Delay_or_event_controlContext) Event_control() IEvent_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_controlContext)
}

func (s *Delay_or_event_controlContext) Repeat_event_control() IRepeat_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRepeat_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRepeat_event_controlContext)
}

func (s *Delay_or_event_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_or_event_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_or_event_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDelay_or_event_control(s)
	}
}

func (s *Delay_or_event_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDelay_or_event_control(s)
	}
}

func (p *SysVerilogHDLParser) Delay_or_event_control() (localctx IDelay_or_event_controlContext) {
	localctx = NewDelay_or_event_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, SysVerilogHDLParserRULE_delay_or_event_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2413)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserHash:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2410)
			p.Delay_control()
		}

	case SysVerilogHDLParserAt:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2411)
			p.Event_control()
		}

	case SysVerilogHDLParserRepeat:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2412)
			p.Repeat_event_control()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDelay_controlContext is an interface to support dynamic dispatch.
type IDelay_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_controlContext differentiates from other interfaces.
	IsDelay_controlContext()
}

type Delay_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_controlContext() *Delay_controlContext {
	var p = new(Delay_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_delay_control
	return p
}

func (*Delay_controlContext) IsDelay_controlContext() {}

func NewDelay_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_controlContext {
	var p = new(Delay_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_delay_control

	return p
}

func (s *Delay_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_controlContext) Hash() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserHash, 0)
}

func (s *Delay_controlContext) Delay_value() IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *Delay_controlContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Delay_controlContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Delay_controlContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Delay_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDelay_control(s)
	}
}

func (s *Delay_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDelay_control(s)
	}
}

func (p *SysVerilogHDLParser) Delay_control() (localctx IDelay_controlContext) {
	localctx = NewDelay_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, SysVerilogHDLParserRULE_delay_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2427)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2415)
			p.Match(SysVerilogHDLParserHash)
		}
		{
			p.SetState(2416)
			p.Delay_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2417)
			p.Match(SysVerilogHDLParserHash)
		}
		{
			p.SetState(2418)
			p.Match(SysVerilogHDLParserOpen_parenthesis)
		}
		{
			p.SetState(2419)
			p.Delay_value()
		}
		{
			p.SetState(2420)
			p.Match(SysVerilogHDLParserClose_parenthesis)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2422)
			p.Match(SysVerilogHDLParserHash)
		}
		{
			p.SetState(2423)
			p.Match(SysVerilogHDLParserOpen_parenthesis)
		}
		{
			p.SetState(2424)
			p.Mintypmax_expression()
		}
		{
			p.SetState(2425)
			p.Match(SysVerilogHDLParserClose_parenthesis)
		}

	}

	return localctx
}

// IEvent_controlContext is an interface to support dynamic dispatch.
type IEvent_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_controlContext differentiates from other interfaces.
	IsEvent_controlContext()
}

type Event_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_controlContext() *Event_controlContext {
	var p = new(Event_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_event_control
	return p
}

func (*Event_controlContext) IsEvent_controlContext() {}

func NewEvent_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_controlContext {
	var p = new(Event_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_event_control

	return p
}

func (s *Event_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_controlContext) Event_control_identifier() IEvent_control_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_control_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_control_identifierContext)
}

func (s *Event_controlContext) Event_control_expression() IEvent_control_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_control_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_control_expressionContext)
}

func (s *Event_controlContext) Event_control_wildcard() IEvent_control_wildcardContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_control_wildcardContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_control_wildcardContext)
}

func (s *Event_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEvent_control(s)
	}
}

func (s *Event_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEvent_control(s)
	}
}

func (p *SysVerilogHDLParser) Event_control() (localctx IEvent_controlContext) {
	localctx = NewEvent_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, SysVerilogHDLParserRULE_event_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2432)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 185, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2429)
			p.Event_control_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2430)
			p.Event_control_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2431)
			p.Event_control_wildcard()
		}

	}

	return localctx
}

// IEvent_control_identifierContext is an interface to support dynamic dispatch.
type IEvent_control_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_control_identifierContext differentiates from other interfaces.
	IsEvent_control_identifierContext()
}

type Event_control_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_control_identifierContext() *Event_control_identifierContext {
	var p = new(Event_control_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_event_control_identifier
	return p
}

func (*Event_control_identifierContext) IsEvent_control_identifierContext() {}

func NewEvent_control_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_control_identifierContext {
	var p = new(Event_control_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_event_control_identifier

	return p
}

func (s *Event_control_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_control_identifierContext) At() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserAt, 0)
}

func (s *Event_control_identifierContext) Event_identifier() IEvent_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_identifierContext)
}

func (s *Event_control_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_control_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_control_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEvent_control_identifier(s)
	}
}

func (s *Event_control_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEvent_control_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Event_control_identifier() (localctx IEvent_control_identifierContext) {
	localctx = NewEvent_control_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, SysVerilogHDLParserRULE_event_control_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2434)
		p.Match(SysVerilogHDLParserAt)
	}
	{
		p.SetState(2435)
		p.Event_identifier()
	}

	return localctx
}

// IEvent_control_expressionContext is an interface to support dynamic dispatch.
type IEvent_control_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_control_expressionContext differentiates from other interfaces.
	IsEvent_control_expressionContext()
}

type Event_control_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_control_expressionContext() *Event_control_expressionContext {
	var p = new(Event_control_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_event_control_expression
	return p
}

func (*Event_control_expressionContext) IsEvent_control_expressionContext() {}

func NewEvent_control_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_control_expressionContext {
	var p = new(Event_control_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_event_control_expression

	return p
}

func (s *Event_control_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_control_expressionContext) At() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserAt, 0)
}

func (s *Event_control_expressionContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Event_control_expressionContext) Event_expression() IEvent_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_expressionContext)
}

func (s *Event_control_expressionContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Event_control_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_control_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_control_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEvent_control_expression(s)
	}
}

func (s *Event_control_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEvent_control_expression(s)
	}
}

func (p *SysVerilogHDLParser) Event_control_expression() (localctx IEvent_control_expressionContext) {
	localctx = NewEvent_control_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, SysVerilogHDLParserRULE_event_control_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2437)
		p.Match(SysVerilogHDLParserAt)
	}
	{
		p.SetState(2438)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2439)
		p.Event_expression()
	}
	{
		p.SetState(2440)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// IEvent_expressionContext is an interface to support dynamic dispatch.
type IEvent_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_expressionContext differentiates from other interfaces.
	IsEvent_expressionContext()
}

type Event_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_expressionContext() *Event_expressionContext {
	var p = new(Event_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_event_expression
	return p
}

func (*Event_expressionContext) IsEvent_expressionContext() {}

func NewEvent_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_expressionContext {
	var p = new(Event_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_event_expression

	return p
}

func (s *Event_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_expressionContext) Single_event_expression() ISingle_event_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_event_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_event_expressionContext)
}

func (s *Event_expressionContext) Event_expression_or() IEvent_expression_orContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_expression_orContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_expression_orContext)
}

func (s *Event_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEvent_expression(s)
	}
}

func (s *Event_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEvent_expression(s)
	}
}

func (p *SysVerilogHDLParser) Event_expression() (localctx IEvent_expressionContext) {
	localctx = NewEvent_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, SysVerilogHDLParserRULE_event_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2444)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2442)
			p.Single_event_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2443)
			p.Event_expression_or()
		}

	}

	return localctx
}

// ISingle_event_expressionContext is an interface to support dynamic dispatch.
type ISingle_event_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingle_event_expressionContext differentiates from other interfaces.
	IsSingle_event_expressionContext()
}

type Single_event_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_event_expressionContext() *Single_event_expressionContext {
	var p = new(Single_event_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_single_event_expression
	return p
}

func (*Single_event_expressionContext) IsSingle_event_expressionContext() {}

func NewSingle_event_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_event_expressionContext {
	var p = new(Single_event_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_single_event_expression

	return p
}

func (s *Single_event_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_event_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Single_event_expressionContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Single_event_expressionContext) Event_expression_edgespec() IEvent_expression_edgespecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_expression_edgespecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_expression_edgespecContext)
}

func (s *Single_event_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_event_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_event_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterSingle_event_expression(s)
	}
}

func (s *Single_event_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitSingle_event_expression(s)
	}
}

func (p *SysVerilogHDLParser) Single_event_expression() (localctx ISingle_event_expressionContext) {
	localctx = NewSingle_event_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, SysVerilogHDLParserRULE_single_event_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2451)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 187, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2446)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2447)
			p.Hierarchical_identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2448)
			p.Event_expression_edgespec()
		}
		{
			p.SetState(2449)
			p.Expression()
		}

	}

	return localctx
}

// IEvent_expression_edgespecContext is an interface to support dynamic dispatch.
type IEvent_expression_edgespecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_expression_edgespecContext differentiates from other interfaces.
	IsEvent_expression_edgespecContext()
}

type Event_expression_edgespecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_expression_edgespecContext() *Event_expression_edgespecContext {
	var p = new(Event_expression_edgespecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_event_expression_edgespec
	return p
}

func (*Event_expression_edgespecContext) IsEvent_expression_edgespecContext() {}

func NewEvent_expression_edgespecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_expression_edgespecContext {
	var p = new(Event_expression_edgespecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_event_expression_edgespec

	return p
}

func (s *Event_expression_edgespecContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_expression_edgespecContext) Posedge() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserPosedge, 0)
}

func (s *Event_expression_edgespecContext) Negedge() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserNegedge, 0)
}

func (s *Event_expression_edgespecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_expression_edgespecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_expression_edgespecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEvent_expression_edgespec(s)
	}
}

func (s *Event_expression_edgespecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEvent_expression_edgespec(s)
	}
}

func (p *SysVerilogHDLParser) Event_expression_edgespec() (localctx IEvent_expression_edgespecContext) {
	localctx = NewEvent_expression_edgespecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, SysVerilogHDLParserRULE_event_expression_edgespec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2453)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SysVerilogHDLParserNegedge || _la == SysVerilogHDLParserPosedge) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IEvent_expression_orContext is an interface to support dynamic dispatch.
type IEvent_expression_orContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_expression_orContext differentiates from other interfaces.
	IsEvent_expression_orContext()
}

type Event_expression_orContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_expression_orContext() *Event_expression_orContext {
	var p = new(Event_expression_orContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_event_expression_or
	return p
}

func (*Event_expression_orContext) IsEvent_expression_orContext() {}

func NewEvent_expression_orContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_expression_orContext {
	var p = new(Event_expression_orContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_event_expression_or

	return p
}

func (s *Event_expression_orContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_expression_orContext) List_of_event_expression_comma() IList_of_event_expression_commaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_event_expression_commaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_event_expression_commaContext)
}

func (s *Event_expression_orContext) List_of_event_expression_or() IList_of_event_expression_orContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_event_expression_orContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_event_expression_orContext)
}

func (s *Event_expression_orContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_expression_orContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_expression_orContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEvent_expression_or(s)
	}
}

func (s *Event_expression_orContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEvent_expression_or(s)
	}
}

func (p *SysVerilogHDLParser) Event_expression_or() (localctx IEvent_expression_orContext) {
	localctx = NewEvent_expression_orContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, SysVerilogHDLParserRULE_event_expression_or)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2457)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 188, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2455)
			p.List_of_event_expression_comma()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2456)
			p.List_of_event_expression_or()
		}

	}

	return localctx
}

// IList_of_event_expression_commaContext is an interface to support dynamic dispatch.
type IList_of_event_expression_commaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_event_expression_commaContext differentiates from other interfaces.
	IsList_of_event_expression_commaContext()
}

type List_of_event_expression_commaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_event_expression_commaContext() *List_of_event_expression_commaContext {
	var p = new(List_of_event_expression_commaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_event_expression_comma
	return p
}

func (*List_of_event_expression_commaContext) IsList_of_event_expression_commaContext() {}

func NewList_of_event_expression_commaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_event_expression_commaContext {
	var p = new(List_of_event_expression_commaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_event_expression_comma

	return p
}

func (s *List_of_event_expression_commaContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_event_expression_commaContext) Single_event_expression() ISingle_event_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_event_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_event_expressionContext)
}

func (s *List_of_event_expression_commaContext) Comma_event_expression_star() IComma_event_expression_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_event_expression_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_event_expression_starContext)
}

func (s *List_of_event_expression_commaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_event_expression_commaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_event_expression_commaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_event_expression_comma(s)
	}
}

func (s *List_of_event_expression_commaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_event_expression_comma(s)
	}
}

func (p *SysVerilogHDLParser) List_of_event_expression_comma() (localctx IList_of_event_expression_commaContext) {
	localctx = NewList_of_event_expression_commaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, SysVerilogHDLParserRULE_list_of_event_expression_comma)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2459)
		p.Single_event_expression()
	}
	{
		p.SetState(2460)
		p.Comma_event_expression_star()
	}

	return localctx
}

// IComma_event_expression_starContext is an interface to support dynamic dispatch.
type IComma_event_expression_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_event_expression_starContext differentiates from other interfaces.
	IsComma_event_expression_starContext()
}

type Comma_event_expression_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_event_expression_starContext() *Comma_event_expression_starContext {
	var p = new(Comma_event_expression_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_event_expression_star
	return p
}

func (*Comma_event_expression_starContext) IsComma_event_expression_starContext() {}

func NewComma_event_expression_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_event_expression_starContext {
	var p = new(Comma_event_expression_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_event_expression_star

	return p
}

func (s *Comma_event_expression_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_event_expression_starContext) AllComma_event_expression() []IComma_event_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_event_expressionContext)(nil)).Elem())
	var tst = make([]IComma_event_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_event_expressionContext)
		}
	}

	return tst
}

func (s *Comma_event_expression_starContext) Comma_event_expression(i int) IComma_event_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_event_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_event_expressionContext)
}

func (s *Comma_event_expression_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_event_expression_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_event_expression_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_event_expression_star(s)
	}
}

func (s *Comma_event_expression_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_event_expression_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_event_expression_star() (localctx IComma_event_expression_starContext) {
	localctx = NewComma_event_expression_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, SysVerilogHDLParserRULE_comma_event_expression_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2465)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(2462)
			p.Comma_event_expression()
		}

		p.SetState(2467)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_event_expressionContext is an interface to support dynamic dispatch.
type IComma_event_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_event_expressionContext differentiates from other interfaces.
	IsComma_event_expressionContext()
}

type Comma_event_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_event_expressionContext() *Comma_event_expressionContext {
	var p = new(Comma_event_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_event_expression
	return p
}

func (*Comma_event_expressionContext) IsComma_event_expressionContext() {}

func NewComma_event_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_event_expressionContext {
	var p = new(Comma_event_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_event_expression

	return p
}

func (s *Comma_event_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_event_expressionContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_event_expressionContext) Single_event_expression() ISingle_event_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_event_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_event_expressionContext)
}

func (s *Comma_event_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_event_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_event_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_event_expression(s)
	}
}

func (s *Comma_event_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_event_expression(s)
	}
}

func (p *SysVerilogHDLParser) Comma_event_expression() (localctx IComma_event_expressionContext) {
	localctx = NewComma_event_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, SysVerilogHDLParserRULE_comma_event_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2468)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2469)
		p.Single_event_expression()
	}

	return localctx
}

// IList_of_event_expression_orContext is an interface to support dynamic dispatch.
type IList_of_event_expression_orContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_event_expression_orContext differentiates from other interfaces.
	IsList_of_event_expression_orContext()
}

type List_of_event_expression_orContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_event_expression_orContext() *List_of_event_expression_orContext {
	var p = new(List_of_event_expression_orContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_event_expression_or
	return p
}

func (*List_of_event_expression_orContext) IsList_of_event_expression_orContext() {}

func NewList_of_event_expression_orContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_event_expression_orContext {
	var p = new(List_of_event_expression_orContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_event_expression_or

	return p
}

func (s *List_of_event_expression_orContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_event_expression_orContext) Single_event_expression() ISingle_event_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_event_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_event_expressionContext)
}

func (s *List_of_event_expression_orContext) Or_event_expression_star() IOr_event_expression_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_event_expression_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOr_event_expression_starContext)
}

func (s *List_of_event_expression_orContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_event_expression_orContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_event_expression_orContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_event_expression_or(s)
	}
}

func (s *List_of_event_expression_orContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_event_expression_or(s)
	}
}

func (p *SysVerilogHDLParser) List_of_event_expression_or() (localctx IList_of_event_expression_orContext) {
	localctx = NewList_of_event_expression_orContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, SysVerilogHDLParserRULE_list_of_event_expression_or)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2471)
		p.Single_event_expression()
	}
	{
		p.SetState(2472)
		p.Or_event_expression_star()
	}

	return localctx
}

// IOr_event_expression_starContext is an interface to support dynamic dispatch.
type IOr_event_expression_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOr_event_expression_starContext differentiates from other interfaces.
	IsOr_event_expression_starContext()
}

type Or_event_expression_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOr_event_expression_starContext() *Or_event_expression_starContext {
	var p = new(Or_event_expression_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_or_event_expression_star
	return p
}

func (*Or_event_expression_starContext) IsOr_event_expression_starContext() {}

func NewOr_event_expression_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Or_event_expression_starContext {
	var p = new(Or_event_expression_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_or_event_expression_star

	return p
}

func (s *Or_event_expression_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Or_event_expression_starContext) AllOr_event_expression() []IOr_event_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOr_event_expressionContext)(nil)).Elem())
	var tst = make([]IOr_event_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOr_event_expressionContext)
		}
	}

	return tst
}

func (s *Or_event_expression_starContext) Or_event_expression(i int) IOr_event_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_event_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOr_event_expressionContext)
}

func (s *Or_event_expression_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Or_event_expression_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Or_event_expression_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterOr_event_expression_star(s)
	}
}

func (s *Or_event_expression_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitOr_event_expression_star(s)
	}
}

func (p *SysVerilogHDLParser) Or_event_expression_star() (localctx IOr_event_expression_starContext) {
	localctx = NewOr_event_expression_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, SysVerilogHDLParserRULE_or_event_expression_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2477)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserOr {
		{
			p.SetState(2474)
			p.Or_event_expression()
		}

		p.SetState(2479)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOr_event_expressionContext is an interface to support dynamic dispatch.
type IOr_event_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOr_event_expressionContext differentiates from other interfaces.
	IsOr_event_expressionContext()
}

type Or_event_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOr_event_expressionContext() *Or_event_expressionContext {
	var p = new(Or_event_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_or_event_expression
	return p
}

func (*Or_event_expressionContext) IsOr_event_expressionContext() {}

func NewOr_event_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Or_event_expressionContext {
	var p = new(Or_event_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_or_event_expression

	return p
}

func (s *Or_event_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Or_event_expressionContext) Or() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOr, 0)
}

func (s *Or_event_expressionContext) Single_event_expression() ISingle_event_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_event_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_event_expressionContext)
}

func (s *Or_event_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Or_event_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Or_event_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterOr_event_expression(s)
	}
}

func (s *Or_event_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitOr_event_expression(s)
	}
}

func (p *SysVerilogHDLParser) Or_event_expression() (localctx IOr_event_expressionContext) {
	localctx = NewOr_event_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, SysVerilogHDLParserRULE_or_event_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2480)
		p.Match(SysVerilogHDLParserOr)
	}
	{
		p.SetState(2481)
		p.Single_event_expression()
	}

	return localctx
}

// IEvent_control_wildcardContext is an interface to support dynamic dispatch.
type IEvent_control_wildcardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_control_wildcardContext differentiates from other interfaces.
	IsEvent_control_wildcardContext()
}

type Event_control_wildcardContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_control_wildcardContext() *Event_control_wildcardContext {
	var p = new(Event_control_wildcardContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_event_control_wildcard
	return p
}

func (*Event_control_wildcardContext) IsEvent_control_wildcardContext() {}

func NewEvent_control_wildcardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_control_wildcardContext {
	var p = new(Event_control_wildcardContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_event_control_wildcard

	return p
}

func (s *Event_control_wildcardContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_control_wildcardContext) At() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserAt, 0)
}

func (s *Event_control_wildcardContext) Star() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserStar, 0)
}

func (s *Event_control_wildcardContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Event_control_wildcardContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Event_control_wildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_control_wildcardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_control_wildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEvent_control_wildcard(s)
	}
}

func (s *Event_control_wildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEvent_control_wildcard(s)
	}
}

func (p *SysVerilogHDLParser) Event_control_wildcard() (localctx IEvent_control_wildcardContext) {
	localctx = NewEvent_control_wildcardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, SysVerilogHDLParserRULE_event_control_wildcard)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2489)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 191, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2483)
			p.Match(SysVerilogHDLParserAt)
		}
		{
			p.SetState(2484)
			p.Match(SysVerilogHDLParserStar)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2485)
			p.Match(SysVerilogHDLParserAt)
		}
		{
			p.SetState(2486)
			p.Match(SysVerilogHDLParserOpen_parenthesis)
		}
		{
			p.SetState(2487)
			p.Match(SysVerilogHDLParserStar)
		}
		{
			p.SetState(2488)
			p.Match(SysVerilogHDLParserClose_parenthesis)
		}

	}

	return localctx
}

// IRepeat_event_controlContext is an interface to support dynamic dispatch.
type IRepeat_event_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRepeat_event_controlContext differentiates from other interfaces.
	IsRepeat_event_controlContext()
}

type Repeat_event_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeat_event_controlContext() *Repeat_event_controlContext {
	var p = new(Repeat_event_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_repeat_event_control
	return p
}

func (*Repeat_event_controlContext) IsRepeat_event_controlContext() {}

func NewRepeat_event_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Repeat_event_controlContext {
	var p = new(Repeat_event_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_repeat_event_control

	return p
}

func (s *Repeat_event_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Repeat_event_controlContext) Repeat() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRepeat, 0)
}

func (s *Repeat_event_controlContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Repeat_event_controlContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Repeat_event_controlContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Repeat_event_controlContext) Event_control() IEvent_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_controlContext)
}

func (s *Repeat_event_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Repeat_event_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Repeat_event_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterRepeat_event_control(s)
	}
}

func (s *Repeat_event_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitRepeat_event_control(s)
	}
}

func (p *SysVerilogHDLParser) Repeat_event_control() (localctx IRepeat_event_controlContext) {
	localctx = NewRepeat_event_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, SysVerilogHDLParserRULE_repeat_event_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2491)
		p.Match(SysVerilogHDLParserRepeat)
	}
	{
		p.SetState(2492)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2493)
		p.Expression()
	}
	{
		p.SetState(2494)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}
	{
		p.SetState(2495)
		p.Event_control()
	}

	return localctx
}

// IEvent_triggerContext is an interface to support dynamic dispatch.
type IEvent_triggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_triggerContext differentiates from other interfaces.
	IsEvent_triggerContext()
}

type Event_triggerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_triggerContext() *Event_triggerContext {
	var p = new(Event_triggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_event_trigger
	return p
}

func (*Event_triggerContext) IsEvent_triggerContext() {}

func NewEvent_triggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_triggerContext {
	var p = new(Event_triggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_event_trigger

	return p
}

func (s *Event_triggerContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_triggerContext) Dash_right_angle() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDash_right_angle, 0)
}

func (s *Event_triggerContext) Hierarchical_event_identifier() IHierarchical_event_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_event_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_event_identifierContext)
}

func (s *Event_triggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_triggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_triggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEvent_trigger(s)
	}
}

func (s *Event_triggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEvent_trigger(s)
	}
}

func (p *SysVerilogHDLParser) Event_trigger() (localctx IEvent_triggerContext) {
	localctx = NewEvent_triggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, SysVerilogHDLParserRULE_event_trigger)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2497)
		p.Match(SysVerilogHDLParserDash_right_angle)
	}
	{
		p.SetState(2498)
		p.Hierarchical_event_identifier()
	}

	return localctx
}

// IHierarchical_event_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_event_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_event_identifierContext differentiates from other interfaces.
	IsHierarchical_event_identifierContext()
}

type Hierarchical_event_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_event_identifierContext() *Hierarchical_event_identifierContext {
	var p = new(Hierarchical_event_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_event_identifier
	return p
}

func (*Hierarchical_event_identifierContext) IsHierarchical_event_identifierContext() {}

func NewHierarchical_event_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_event_identifierContext {
	var p = new(Hierarchical_event_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_event_identifier

	return p
}

func (s *Hierarchical_event_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_event_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_event_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_event_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_event_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterHierarchical_event_identifier(s)
	}
}

func (s *Hierarchical_event_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitHierarchical_event_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Hierarchical_event_identifier() (localctx IHierarchical_event_identifierContext) {
	localctx = NewHierarchical_event_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, SysVerilogHDLParserRULE_hierarchical_event_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2500)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IEvent_identifierContext is an interface to support dynamic dispatch.
type IEvent_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_identifierContext differentiates from other interfaces.
	IsEvent_identifierContext()
}

type Event_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_identifierContext() *Event_identifierContext {
	var p = new(Event_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_event_identifier
	return p
}

func (*Event_identifierContext) IsEvent_identifierContext() {}

func NewEvent_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_identifierContext {
	var p = new(Event_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_event_identifier

	return p
}

func (s *Event_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Event_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterEvent_identifier(s)
	}
}

func (s *Event_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitEvent_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Event_identifier() (localctx IEvent_identifierContext) {
	localctx = NewEvent_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, SysVerilogHDLParserRULE_event_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2502)
		p.Identifier()
	}

	return localctx
}

// IWait_statementContext is an interface to support dynamic dispatch.
type IWait_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWait_statementContext differentiates from other interfaces.
	IsWait_statementContext()
}

type Wait_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWait_statementContext() *Wait_statementContext {
	var p = new(Wait_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_wait_statement
	return p
}

func (*Wait_statementContext) IsWait_statementContext() {}

func NewWait_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Wait_statementContext {
	var p = new(Wait_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_wait_statement

	return p
}

func (s *Wait_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Wait_statementContext) Wait() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserWait, 0)
}

func (s *Wait_statementContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Wait_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Wait_statementContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Wait_statementContext) Statement_semicolon() IStatement_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_semicolonContext)
}

func (s *Wait_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Wait_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Wait_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterWait_statement(s)
	}
}

func (s *Wait_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitWait_statement(s)
	}
}

func (p *SysVerilogHDLParser) Wait_statement() (localctx IWait_statementContext) {
	localctx = NewWait_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, SysVerilogHDLParserRULE_wait_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2504)
		p.Match(SysVerilogHDLParserWait)
	}
	{
		p.SetState(2505)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2506)
		p.Expression()
	}
	{
		p.SetState(2507)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}
	{
		p.SetState(2508)
		p.Statement_semicolon()
	}

	return localctx
}

// IAttr_generated_instantiationContext is an interface to support dynamic dispatch.
type IAttr_generated_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_generated_instantiationContext differentiates from other interfaces.
	IsAttr_generated_instantiationContext()
}

type Attr_generated_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_generated_instantiationContext() *Attr_generated_instantiationContext {
	var p = new(Attr_generated_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attr_generated_instantiation
	return p
}

func (*Attr_generated_instantiationContext) IsAttr_generated_instantiationContext() {}

func NewAttr_generated_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_generated_instantiationContext {
	var p = new(Attr_generated_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attr_generated_instantiation

	return p
}

func (s *Attr_generated_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_generated_instantiationContext) Attribute_instance_star() IAttribute_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instance_starContext)
}

func (s *Attr_generated_instantiationContext) Generated_instantiation() IGenerated_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerated_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerated_instantiationContext)
}

func (s *Attr_generated_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_generated_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_generated_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttr_generated_instantiation(s)
	}
}

func (s *Attr_generated_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttr_generated_instantiation(s)
	}
}

func (p *SysVerilogHDLParser) Attr_generated_instantiation() (localctx IAttr_generated_instantiationContext) {
	localctx = NewAttr_generated_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, SysVerilogHDLParserRULE_attr_generated_instantiation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2510)
		p.Attribute_instance_star()
	}
	{
		p.SetState(2511)
		p.Generated_instantiation()
	}

	return localctx
}

// IGenerated_instantiationContext is an interface to support dynamic dispatch.
type IGenerated_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerated_instantiationContext differentiates from other interfaces.
	IsGenerated_instantiationContext()
}

type Generated_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerated_instantiationContext() *Generated_instantiationContext {
	var p = new(Generated_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generated_instantiation
	return p
}

func (*Generated_instantiationContext) IsGenerated_instantiationContext() {}

func NewGenerated_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generated_instantiationContext {
	var p = new(Generated_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generated_instantiation

	return p
}

func (s *Generated_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Generated_instantiationContext) Generate() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserGenerate, 0)
}

func (s *Generated_instantiationContext) Generate_item_star() IGenerate_item_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_item_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_item_starContext)
}

func (s *Generated_instantiationContext) Endgenerate() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEndgenerate, 0)
}

func (s *Generated_instantiationContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Generated_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generated_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generated_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerated_instantiation(s)
	}
}

func (s *Generated_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerated_instantiation(s)
	}
}

func (p *SysVerilogHDLParser) Generated_instantiation() (localctx IGenerated_instantiationContext) {
	localctx = NewGenerated_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, SysVerilogHDLParserRULE_generated_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2513)
		p.Match(SysVerilogHDLParserGenerate)
	}
	{
		p.SetState(2514)
		p.Generate_item_star()
	}
	{
		p.SetState(2515)
		p.Match(SysVerilogHDLParserEndgenerate)
	}
	p.SetState(2517)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserT__0 || _la == SysVerilogHDLParserSemicolon {
		{
			p.SetState(2516)
			p.Semicolon()
		}

	}

	return localctx
}

// IGenerate_item_starContext is an interface to support dynamic dispatch.
type IGenerate_item_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_item_starContext differentiates from other interfaces.
	IsGenerate_item_starContext()
}

type Generate_item_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_item_starContext() *Generate_item_starContext {
	var p = new(Generate_item_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_item_star
	return p
}

func (*Generate_item_starContext) IsGenerate_item_starContext() {}

func NewGenerate_item_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_item_starContext {
	var p = new(Generate_item_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_item_star

	return p
}

func (s *Generate_item_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_item_starContext) AllGenerate_item() []IGenerate_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem())
	var tst = make([]IGenerate_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenerate_itemContext)
		}
	}

	return tst
}

func (s *Generate_item_starContext) Generate_item(i int) IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generate_item_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_item_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_item_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_item_star(s)
	}
}

func (s *Generate_item_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_item_star(s)
	}
}

func (p *SysVerilogHDLParser) Generate_item_star() (localctx IGenerate_item_starContext) {
	localctx = NewGenerate_item_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, SysVerilogHDLParserRULE_generate_item_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2522)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserT__0 || (((_la-49)&-(0x1f+1)) == 0 && ((1<<uint((_la-49)))&((1<<(SysVerilogHDLParserAlways-49))|(1<<(SysVerilogHDLParserAlways_comb-49))|(1<<(SysVerilogHDLParserAlways_ff-49))|(1<<(SysVerilogHDLParserAnd-49))|(1<<(SysVerilogHDLParserAssign-49))|(1<<(SysVerilogHDLParserAutomatic-49))|(1<<(SysVerilogHDLParserBegin-49))|(1<<(SysVerilogHDLParserBit-49))|(1<<(SysVerilogHDLParserBuf-49))|(1<<(SysVerilogHDLParserBufif0-49))|(1<<(SysVerilogHDLParserBufif1-49))|(1<<(SysVerilogHDLParserByte-49))|(1<<(SysVerilogHDLParserCase_keyword-49))|(1<<(SysVerilogHDLParserCasez-49))|(1<<(SysVerilogHDLParserCasex-49))|(1<<(SysVerilogHDLParserCmos-49))|(1<<(SysVerilogHDLParserConst-49))|(1<<(SysVerilogHDLParserDefparam-49))|(1<<(SysVerilogHDLParserDo-49)))) != 0) || (((_la-88)&-(0x1f+1)) == 0 && ((1<<uint((_la-88)))&((1<<(SysVerilogHDLParserEnum-88))|(1<<(SysVerilogHDLParserEvent_keyword-88))|(1<<(SysVerilogHDLParserFinal-88))|(1<<(SysVerilogHDLParserFor-88))|(1<<(SysVerilogHDLParserForever-88))|(1<<(SysVerilogHDLParserFunction-88))|(1<<(SysVerilogHDLParserGenvar-88))|(1<<(SysVerilogHDLParserIf-88))|(1<<(SysVerilogHDLParserInitial-88))|(1<<(SysVerilogHDLParserInt-88))|(1<<(SysVerilogHDLParserInteger-88))|(1<<(SysVerilogHDLParserLocalparam-88))|(1<<(SysVerilogHDLParserLogic-88)))) != 0) || (((_la-122)&-(0x1f+1)) == 0 && ((1<<uint((_la-122)))&((1<<(SysVerilogHDLParserNand-122))|(1<<(SysVerilogHDLParserNmos-122))|(1<<(SysVerilogHDLParserNONE-122))|(1<<(SysVerilogHDLParserNor-122))|(1<<(SysVerilogHDLParserNot-122))|(1<<(SysVerilogHDLParserNotif0-122))|(1<<(SysVerilogHDLParserNotif1-122))|(1<<(SysVerilogHDLParserOr-122))|(1<<(SysVerilogHDLParserParameter-122))|(1<<(SysVerilogHDLParserPmos-122))|(1<<(SysVerilogHDLParserPullup-122))|(1<<(SysVerilogHDLParserPulldown-122))|(1<<(SysVerilogHDLParserRcmos-122))|(1<<(SysVerilogHDLParserReal-122))|(1<<(SysVerilogHDLParserRealtime-122))|(1<<(SysVerilogHDLParserReg-122))|(1<<(SysVerilogHDLParserRepeat-122)))) != 0) || (((_la-154)&-(0x1f+1)) == 0 && ((1<<uint((_la-154)))&((1<<(SysVerilogHDLParserRnmos-154))|(1<<(SysVerilogHDLParserRpmos-154))|(1<<(SysVerilogHDLParserRtran-154))|(1<<(SysVerilogHDLParserRtranif0-154))|(1<<(SysVerilogHDLParserRtranif1-154))|(1<<(SysVerilogHDLParserStatic-154))|(1<<(SysVerilogHDLParserSVString-154))|(1<<(SysVerilogHDLParserStruct-154))|(1<<(SysVerilogHDLParserSupply0-154))|(1<<(SysVerilogHDLParserSupply1-154))|(1<<(SysVerilogHDLParserTask-154))|(1<<(SysVerilogHDLParserTime-154))|(1<<(SysVerilogHDLParserTran-154))|(1<<(SysVerilogHDLParserTranif0-154))|(1<<(SysVerilogHDLParserTranif1-154))|(1<<(SysVerilogHDLParserTri-154))|(1<<(SysVerilogHDLParserTri_and-154))|(1<<(SysVerilogHDLParserTri_or-154))|(1<<(SysVerilogHDLParserTri_reg-154))|(1<<(SysVerilogHDLParserTri0-154))|(1<<(SysVerilogHDLParserTri1-154)))) != 0) || (((_la-187)&-(0x1f+1)) == 0 && ((1<<uint((_la-187)))&((1<<(SysVerilogHDLParserUnionStruct-187))|(1<<(SysVerilogHDLParserUwire-187))|(1<<(SysVerilogHDLParserWand-187))|(1<<(SysVerilogHDLParserWhile-187))|(1<<(SysVerilogHDLParserWire-187))|(1<<(SysVerilogHDLParserWor-187))|(1<<(SysVerilogHDLParserXnor-187))|(1<<(SysVerilogHDLParserXor-187))|(1<<(SysVerilogHDLParserEscaped_identifier-187))|(1<<(SysVerilogHDLParserSimple_identifier-187)))) != 0) || _la == SysVerilogHDLParserOpen_parenthesis || _la == SysVerilogHDLParserSemicolon {
		{
			p.SetState(2519)
			p.Generate_item()
		}

		p.SetState(2524)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGenerate_itemContext is an interface to support dynamic dispatch.
type IGenerate_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_itemContext differentiates from other interfaces.
	IsGenerate_itemContext()
}

type Generate_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_itemContext() *Generate_itemContext {
	var p = new(Generate_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_item
	return p
}

func (*Generate_itemContext) IsGenerate_itemContext() {}

func NewGenerate_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_itemContext {
	var p = new(Generate_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_item

	return p
}

func (s *Generate_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_itemContext) Generate_conditional_statement() IGenerate_conditional_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_conditional_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_conditional_statementContext)
}

func (s *Generate_itemContext) Generate_case_statement() IGenerate_case_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_case_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_case_statementContext)
}

func (s *Generate_itemContext) Generate_loop_statement() IGenerate_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_loop_statementContext)
}

func (s *Generate_itemContext) Generate_block() IGenerate_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_blockContext)
}

func (s *Generate_itemContext) Parameter_item_semicolon() IParameter_item_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_item_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_item_semicolonContext)
}

func (s *Generate_itemContext) Attr_variable_item_semicolon() IAttr_variable_item_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_variable_item_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_variable_item_semicolonContext)
}

func (s *Generate_itemContext) Subroutine_item_semicolon() ISubroutine_item_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubroutine_item_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubroutine_item_semicolonContext)
}

func (s *Generate_itemContext) Attr_construct_item() IAttr_construct_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_construct_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_construct_itemContext)
}

func (s *Generate_itemContext) Attr_component_item() IAttr_component_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_component_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_component_itemContext)
}

func (s *Generate_itemContext) Null_item() INull_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INull_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INull_itemContext)
}

func (s *Generate_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_item(s)
	}
}

func (s *Generate_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_item(s)
	}
}

func (p *SysVerilogHDLParser) Generate_item() (localctx IGenerate_itemContext) {
	localctx = NewGenerate_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, SysVerilogHDLParserRULE_generate_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2535)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 194, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2525)
			p.Generate_conditional_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2526)
			p.Generate_case_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2527)
			p.Generate_loop_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2528)
			p.Generate_block()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2529)
			p.Parameter_item_semicolon()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2530)
			p.Attr_variable_item_semicolon()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2531)
			p.Subroutine_item_semicolon()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2532)
			p.Attr_construct_item()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2533)
			p.Attr_component_item()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2534)
			p.Null_item()
		}

	}

	return localctx
}

// IGenerate_blockContext is an interface to support dynamic dispatch.
type IGenerate_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_blockContext differentiates from other interfaces.
	IsGenerate_blockContext()
}

type Generate_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_blockContext() *Generate_blockContext {
	var p = new(Generate_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_block
	return p
}

func (*Generate_blockContext) IsGenerate_blockContext() {}

func NewGenerate_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_blockContext {
	var p = new(Generate_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_block

	return p
}

func (s *Generate_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_blockContext) Begin() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserBegin, 0)
}

func (s *Generate_blockContext) Generate_item_star() IGenerate_item_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_item_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_item_starContext)
}

func (s *Generate_blockContext) End() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEnd, 0)
}

func (s *Generate_blockContext) Generate_colon_block_identifier0() IGenerate_colon_block_identifier0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_colon_block_identifier0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_colon_block_identifier0Context)
}

func (s *Generate_blockContext) Generate_colon_block_identifier1() IGenerate_colon_block_identifier1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_colon_block_identifier1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_colon_block_identifier1Context)
}

func (s *Generate_blockContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Generate_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_block(s)
	}
}

func (s *Generate_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_block(s)
	}
}

func (p *SysVerilogHDLParser) Generate_block() (localctx IGenerate_blockContext) {
	localctx = NewGenerate_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, SysVerilogHDLParserRULE_generate_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2537)
		p.Match(SysVerilogHDLParserBegin)
	}
	p.SetState(2539)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserColon {
		{
			p.SetState(2538)
			p.Generate_colon_block_identifier0()
		}

	}
	{
		p.SetState(2541)
		p.Generate_item_star()
	}
	{
		p.SetState(2542)
		p.Match(SysVerilogHDLParserEnd)
	}
	p.SetState(2544)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserColon {
		{
			p.SetState(2543)
			p.Generate_colon_block_identifier1()
		}

	}
	p.SetState(2547)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 197, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2546)
			p.Semicolon()
		}

	}

	return localctx
}

// IGenerate_colon_block_identifier0Context is an interface to support dynamic dispatch.
type IGenerate_colon_block_identifier0Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_colon_block_identifier0Context differentiates from other interfaces.
	IsGenerate_colon_block_identifier0Context()
}

type Generate_colon_block_identifier0Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_colon_block_identifier0Context() *Generate_colon_block_identifier0Context {
	var p = new(Generate_colon_block_identifier0Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_colon_block_identifier0
	return p
}

func (*Generate_colon_block_identifier0Context) IsGenerate_colon_block_identifier0Context() {}

func NewGenerate_colon_block_identifier0Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_colon_block_identifier0Context {
	var p = new(Generate_colon_block_identifier0Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_colon_block_identifier0

	return p
}

func (s *Generate_colon_block_identifier0Context) GetParser() antlr.Parser { return s.parser }

func (s *Generate_colon_block_identifier0Context) Generate_colon_block_identifier() IGenerate_colon_block_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_colon_block_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_colon_block_identifierContext)
}

func (s *Generate_colon_block_identifier0Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_colon_block_identifier0Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_colon_block_identifier0Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_colon_block_identifier0(s)
	}
}

func (s *Generate_colon_block_identifier0Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_colon_block_identifier0(s)
	}
}

func (p *SysVerilogHDLParser) Generate_colon_block_identifier0() (localctx IGenerate_colon_block_identifier0Context) {
	localctx = NewGenerate_colon_block_identifier0Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, SysVerilogHDLParserRULE_generate_colon_block_identifier0)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2549)
		p.Generate_colon_block_identifier()
	}

	return localctx
}

// IGenerate_colon_block_identifier1Context is an interface to support dynamic dispatch.
type IGenerate_colon_block_identifier1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_colon_block_identifier1Context differentiates from other interfaces.
	IsGenerate_colon_block_identifier1Context()
}

type Generate_colon_block_identifier1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_colon_block_identifier1Context() *Generate_colon_block_identifier1Context {
	var p = new(Generate_colon_block_identifier1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_colon_block_identifier1
	return p
}

func (*Generate_colon_block_identifier1Context) IsGenerate_colon_block_identifier1Context() {}

func NewGenerate_colon_block_identifier1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_colon_block_identifier1Context {
	var p = new(Generate_colon_block_identifier1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_colon_block_identifier1

	return p
}

func (s *Generate_colon_block_identifier1Context) GetParser() antlr.Parser { return s.parser }

func (s *Generate_colon_block_identifier1Context) Generate_colon_block_identifier() IGenerate_colon_block_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_colon_block_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_colon_block_identifierContext)
}

func (s *Generate_colon_block_identifier1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_colon_block_identifier1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_colon_block_identifier1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_colon_block_identifier1(s)
	}
}

func (s *Generate_colon_block_identifier1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_colon_block_identifier1(s)
	}
}

func (p *SysVerilogHDLParser) Generate_colon_block_identifier1() (localctx IGenerate_colon_block_identifier1Context) {
	localctx = NewGenerate_colon_block_identifier1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, SysVerilogHDLParserRULE_generate_colon_block_identifier1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2551)
		p.Generate_colon_block_identifier()
	}

	return localctx
}

// IGenerate_colon_block_identifierContext is an interface to support dynamic dispatch.
type IGenerate_colon_block_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_colon_block_identifierContext differentiates from other interfaces.
	IsGenerate_colon_block_identifierContext()
}

type Generate_colon_block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_colon_block_identifierContext() *Generate_colon_block_identifierContext {
	var p = new(Generate_colon_block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_colon_block_identifier
	return p
}

func (*Generate_colon_block_identifierContext) IsGenerate_colon_block_identifierContext() {}

func NewGenerate_colon_block_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_colon_block_identifierContext {
	var p = new(Generate_colon_block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_colon_block_identifier

	return p
}

func (s *Generate_colon_block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_colon_block_identifierContext) Colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserColon, 0)
}

func (s *Generate_colon_block_identifierContext) Generate_block_identifier() IGenerate_block_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_block_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_block_identifierContext)
}

func (s *Generate_colon_block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_colon_block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_colon_block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_colon_block_identifier(s)
	}
}

func (s *Generate_colon_block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_colon_block_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Generate_colon_block_identifier() (localctx IGenerate_colon_block_identifierContext) {
	localctx = NewGenerate_colon_block_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, SysVerilogHDLParserRULE_generate_colon_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2553)
		p.Match(SysVerilogHDLParserColon)
	}
	{
		p.SetState(2554)
		p.Generate_block_identifier()
	}

	return localctx
}

// IGenerate_block_identifierContext is an interface to support dynamic dispatch.
type IGenerate_block_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_block_identifierContext differentiates from other interfaces.
	IsGenerate_block_identifierContext()
}

type Generate_block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_block_identifierContext() *Generate_block_identifierContext {
	var p = new(Generate_block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_block_identifier
	return p
}

func (*Generate_block_identifierContext) IsGenerate_block_identifierContext() {}

func NewGenerate_block_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_block_identifierContext {
	var p = new(Generate_block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_block_identifier

	return p
}

func (s *Generate_block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_block_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Generate_block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_block_identifier(s)
	}
}

func (s *Generate_block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_block_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Generate_block_identifier() (localctx IGenerate_block_identifierContext) {
	localctx = NewGenerate_block_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, SysVerilogHDLParserRULE_generate_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2556)
		p.Identifier()
	}

	return localctx
}

// IGenerate_conditional_statementContext is an interface to support dynamic dispatch.
type IGenerate_conditional_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_conditional_statementContext differentiates from other interfaces.
	IsGenerate_conditional_statementContext()
}

type Generate_conditional_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_conditional_statementContext() *Generate_conditional_statementContext {
	var p = new(Generate_conditional_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_conditional_statement
	return p
}

func (*Generate_conditional_statementContext) IsGenerate_conditional_statementContext() {}

func NewGenerate_conditional_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_conditional_statementContext {
	var p = new(Generate_conditional_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_conditional_statement

	return p
}

func (s *Generate_conditional_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_conditional_statementContext) Generate_if_statement() IGenerate_if_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_if_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_if_statementContext)
}

func (s *Generate_conditional_statementContext) Generate_else_statement() IGenerate_else_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_else_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_else_statementContext)
}

func (s *Generate_conditional_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_conditional_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_conditional_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_conditional_statement(s)
	}
}

func (s *Generate_conditional_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_conditional_statement(s)
	}
}

func (p *SysVerilogHDLParser) Generate_conditional_statement() (localctx IGenerate_conditional_statementContext) {
	localctx = NewGenerate_conditional_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, SysVerilogHDLParserRULE_generate_conditional_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2558)
		p.Generate_if_statement()
	}
	p.SetState(2560)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 198, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2559)
			p.Generate_else_statement()
		}

	}

	return localctx
}

// IGenerate_if_statementContext is an interface to support dynamic dispatch.
type IGenerate_if_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_if_statementContext differentiates from other interfaces.
	IsGenerate_if_statementContext()
}

type Generate_if_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_if_statementContext() *Generate_if_statementContext {
	var p = new(Generate_if_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_if_statement
	return p
}

func (*Generate_if_statementContext) IsGenerate_if_statementContext() {}

func NewGenerate_if_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_if_statementContext {
	var p = new(Generate_if_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_if_statement

	return p
}

func (s *Generate_if_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_if_statementContext) If() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserIf, 0)
}

func (s *Generate_if_statementContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Generate_if_statementContext) Conditional_expression() IConditional_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_expressionContext)
}

func (s *Generate_if_statementContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Generate_if_statementContext) Generate_item() IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generate_if_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_if_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_if_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_if_statement(s)
	}
}

func (s *Generate_if_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_if_statement(s)
	}
}

func (p *SysVerilogHDLParser) Generate_if_statement() (localctx IGenerate_if_statementContext) {
	localctx = NewGenerate_if_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, SysVerilogHDLParserRULE_generate_if_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2562)
		p.Match(SysVerilogHDLParserIf)
	}
	{
		p.SetState(2563)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2564)
		p.Conditional_expression()
	}
	{
		p.SetState(2565)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}
	{
		p.SetState(2566)
		p.Generate_item()
	}

	return localctx
}

// IGenerate_else_statementContext is an interface to support dynamic dispatch.
type IGenerate_else_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_else_statementContext differentiates from other interfaces.
	IsGenerate_else_statementContext()
}

type Generate_else_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_else_statementContext() *Generate_else_statementContext {
	var p = new(Generate_else_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_else_statement
	return p
}

func (*Generate_else_statementContext) IsGenerate_else_statementContext() {}

func NewGenerate_else_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_else_statementContext {
	var p = new(Generate_else_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_else_statement

	return p
}

func (s *Generate_else_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_else_statementContext) Else() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserElse, 0)
}

func (s *Generate_else_statementContext) Generate_item() IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generate_else_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_else_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_else_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_else_statement(s)
	}
}

func (s *Generate_else_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_else_statement(s)
	}
}

func (p *SysVerilogHDLParser) Generate_else_statement() (localctx IGenerate_else_statementContext) {
	localctx = NewGenerate_else_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, SysVerilogHDLParserRULE_generate_else_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2568)
		p.Match(SysVerilogHDLParserElse)
	}
	{
		p.SetState(2569)
		p.Generate_item()
	}

	return localctx
}

// IGenerate_loop_statementContext is an interface to support dynamic dispatch.
type IGenerate_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_loop_statementContext differentiates from other interfaces.
	IsGenerate_loop_statementContext()
}

type Generate_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_loop_statementContext() *Generate_loop_statementContext {
	var p = new(Generate_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_loop_statement
	return p
}

func (*Generate_loop_statementContext) IsGenerate_loop_statementContext() {}

func NewGenerate_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_loop_statementContext {
	var p = new(Generate_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_loop_statement

	return p
}

func (s *Generate_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_loop_statementContext) Generate_forever_loop_statement() IGenerate_forever_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_forever_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_forever_loop_statementContext)
}

func (s *Generate_loop_statementContext) Generate_repeat_loop_statement() IGenerate_repeat_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_repeat_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_repeat_loop_statementContext)
}

func (s *Generate_loop_statementContext) Generate_while_loop_statement() IGenerate_while_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_while_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_while_loop_statementContext)
}

func (s *Generate_loop_statementContext) Generate_do_loop_statement() IGenerate_do_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_do_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_do_loop_statementContext)
}

func (s *Generate_loop_statementContext) Generate_for_loop_statement() IGenerate_for_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_for_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_for_loop_statementContext)
}

func (s *Generate_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_loop_statement(s)
	}
}

func (s *Generate_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_loop_statement(s)
	}
}

func (p *SysVerilogHDLParser) Generate_loop_statement() (localctx IGenerate_loop_statementContext) {
	localctx = NewGenerate_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, SysVerilogHDLParserRULE_generate_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2576)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserForever:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2571)
			p.Generate_forever_loop_statement()
		}

	case SysVerilogHDLParserRepeat:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2572)
			p.Generate_repeat_loop_statement()
		}

	case SysVerilogHDLParserWhile:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2573)
			p.Generate_while_loop_statement()
		}

	case SysVerilogHDLParserDo:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2574)
			p.Generate_do_loop_statement()
		}

	case SysVerilogHDLParserFor:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2575)
			p.Generate_for_loop_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGenerate_forever_loop_statementContext is an interface to support dynamic dispatch.
type IGenerate_forever_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_forever_loop_statementContext differentiates from other interfaces.
	IsGenerate_forever_loop_statementContext()
}

type Generate_forever_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_forever_loop_statementContext() *Generate_forever_loop_statementContext {
	var p = new(Generate_forever_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_forever_loop_statement
	return p
}

func (*Generate_forever_loop_statementContext) IsGenerate_forever_loop_statementContext() {}

func NewGenerate_forever_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_forever_loop_statementContext {
	var p = new(Generate_forever_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_forever_loop_statement

	return p
}

func (s *Generate_forever_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_forever_loop_statementContext) Forever() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserForever, 0)
}

func (s *Generate_forever_loop_statementContext) Generate_item() IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generate_forever_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_forever_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_forever_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_forever_loop_statement(s)
	}
}

func (s *Generate_forever_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_forever_loop_statement(s)
	}
}

func (p *SysVerilogHDLParser) Generate_forever_loop_statement() (localctx IGenerate_forever_loop_statementContext) {
	localctx = NewGenerate_forever_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, SysVerilogHDLParserRULE_generate_forever_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2578)
		p.Match(SysVerilogHDLParserForever)
	}
	{
		p.SetState(2579)
		p.Generate_item()
	}

	return localctx
}

// IGenerate_repeat_loop_statementContext is an interface to support dynamic dispatch.
type IGenerate_repeat_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_repeat_loop_statementContext differentiates from other interfaces.
	IsGenerate_repeat_loop_statementContext()
}

type Generate_repeat_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_repeat_loop_statementContext() *Generate_repeat_loop_statementContext {
	var p = new(Generate_repeat_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_repeat_loop_statement
	return p
}

func (*Generate_repeat_loop_statementContext) IsGenerate_repeat_loop_statementContext() {}

func NewGenerate_repeat_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_repeat_loop_statementContext {
	var p = new(Generate_repeat_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_repeat_loop_statement

	return p
}

func (s *Generate_repeat_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_repeat_loop_statementContext) Repeat() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRepeat, 0)
}

func (s *Generate_repeat_loop_statementContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Generate_repeat_loop_statementContext) Loop_terminate_expression() ILoop_terminate_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_terminate_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_terminate_expressionContext)
}

func (s *Generate_repeat_loop_statementContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Generate_repeat_loop_statementContext) Generate_item() IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generate_repeat_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_repeat_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_repeat_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_repeat_loop_statement(s)
	}
}

func (s *Generate_repeat_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_repeat_loop_statement(s)
	}
}

func (p *SysVerilogHDLParser) Generate_repeat_loop_statement() (localctx IGenerate_repeat_loop_statementContext) {
	localctx = NewGenerate_repeat_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, SysVerilogHDLParserRULE_generate_repeat_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2581)
		p.Match(SysVerilogHDLParserRepeat)
	}
	{
		p.SetState(2582)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2583)
		p.Loop_terminate_expression()
	}
	{
		p.SetState(2584)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}
	{
		p.SetState(2585)
		p.Generate_item()
	}

	return localctx
}

// IGenerate_while_loop_statementContext is an interface to support dynamic dispatch.
type IGenerate_while_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_while_loop_statementContext differentiates from other interfaces.
	IsGenerate_while_loop_statementContext()
}

type Generate_while_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_while_loop_statementContext() *Generate_while_loop_statementContext {
	var p = new(Generate_while_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_while_loop_statement
	return p
}

func (*Generate_while_loop_statementContext) IsGenerate_while_loop_statementContext() {}

func NewGenerate_while_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_while_loop_statementContext {
	var p = new(Generate_while_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_while_loop_statement

	return p
}

func (s *Generate_while_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_while_loop_statementContext) While() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserWhile, 0)
}

func (s *Generate_while_loop_statementContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Generate_while_loop_statementContext) Loop_terminate_expression() ILoop_terminate_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_terminate_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_terminate_expressionContext)
}

func (s *Generate_while_loop_statementContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Generate_while_loop_statementContext) Generate_item() IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generate_while_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_while_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_while_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_while_loop_statement(s)
	}
}

func (s *Generate_while_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_while_loop_statement(s)
	}
}

func (p *SysVerilogHDLParser) Generate_while_loop_statement() (localctx IGenerate_while_loop_statementContext) {
	localctx = NewGenerate_while_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, SysVerilogHDLParserRULE_generate_while_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2587)
		p.Match(SysVerilogHDLParserWhile)
	}
	{
		p.SetState(2588)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2589)
		p.Loop_terminate_expression()
	}
	{
		p.SetState(2590)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}
	{
		p.SetState(2591)
		p.Generate_item()
	}

	return localctx
}

// IGenerate_do_loop_statementContext is an interface to support dynamic dispatch.
type IGenerate_do_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_do_loop_statementContext differentiates from other interfaces.
	IsGenerate_do_loop_statementContext()
}

type Generate_do_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_do_loop_statementContext() *Generate_do_loop_statementContext {
	var p = new(Generate_do_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_do_loop_statement
	return p
}

func (*Generate_do_loop_statementContext) IsGenerate_do_loop_statementContext() {}

func NewGenerate_do_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_do_loop_statementContext {
	var p = new(Generate_do_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_do_loop_statement

	return p
}

func (s *Generate_do_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_do_loop_statementContext) Do() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDo, 0)
}

func (s *Generate_do_loop_statementContext) Generate_item() IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generate_do_loop_statementContext) While() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserWhile, 0)
}

func (s *Generate_do_loop_statementContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Generate_do_loop_statementContext) Loop_terminate_expression() ILoop_terminate_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_terminate_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_terminate_expressionContext)
}

func (s *Generate_do_loop_statementContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Generate_do_loop_statementContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Generate_do_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_do_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_do_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_do_loop_statement(s)
	}
}

func (s *Generate_do_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_do_loop_statement(s)
	}
}

func (p *SysVerilogHDLParser) Generate_do_loop_statement() (localctx IGenerate_do_loop_statementContext) {
	localctx = NewGenerate_do_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, SysVerilogHDLParserRULE_generate_do_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2593)
		p.Match(SysVerilogHDLParserDo)
	}
	{
		p.SetState(2594)
		p.Generate_item()
	}
	{
		p.SetState(2595)
		p.Match(SysVerilogHDLParserWhile)
	}
	{
		p.SetState(2596)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2597)
		p.Loop_terminate_expression()
	}
	{
		p.SetState(2598)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}
	{
		p.SetState(2599)
		p.Semicolon()
	}

	return localctx
}

// IGenerate_for_loop_statementContext is an interface to support dynamic dispatch.
type IGenerate_for_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_for_loop_statementContext differentiates from other interfaces.
	IsGenerate_for_loop_statementContext()
}

type Generate_for_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_for_loop_statementContext() *Generate_for_loop_statementContext {
	var p = new(Generate_for_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_for_loop_statement
	return p
}

func (*Generate_for_loop_statementContext) IsGenerate_for_loop_statementContext() {}

func NewGenerate_for_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_for_loop_statementContext {
	var p = new(Generate_for_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_for_loop_statement

	return p
}

func (s *Generate_for_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_for_loop_statementContext) For() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserFor, 0)
}

func (s *Generate_for_loop_statementContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Generate_for_loop_statementContext) Loop_init_assignment() ILoop_init_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_init_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_init_assignmentContext)
}

func (s *Generate_for_loop_statementContext) AllSemicolon() []ISemicolonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISemicolonContext)(nil)).Elem())
	var tst = make([]ISemicolonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISemicolonContext)
		}
	}

	return tst
}

func (s *Generate_for_loop_statementContext) Semicolon(i int) ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Generate_for_loop_statementContext) Loop_terminate_expression() ILoop_terminate_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_terminate_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_terminate_expressionContext)
}

func (s *Generate_for_loop_statementContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Generate_for_loop_statementContext) Generate_item() IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generate_for_loop_statementContext) Loop_step_assignment() ILoop_step_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_step_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_step_assignmentContext)
}

func (s *Generate_for_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_for_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_for_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_for_loop_statement(s)
	}
}

func (s *Generate_for_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_for_loop_statement(s)
	}
}

func (p *SysVerilogHDLParser) Generate_for_loop_statement() (localctx IGenerate_for_loop_statementContext) {
	localctx = NewGenerate_for_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, SysVerilogHDLParserRULE_generate_for_loop_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2601)
		p.Match(SysVerilogHDLParserFor)
	}
	{
		p.SetState(2602)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2603)
		p.Loop_init_assignment()
	}
	{
		p.SetState(2604)
		p.Semicolon()
	}
	{
		p.SetState(2605)
		p.Loop_terminate_expression()
	}
	{
		p.SetState(2606)
		p.Semicolon()
	}
	p.SetState(2608)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserT__26 || _la == SysVerilogHDLParserT__27 || (((_la-202)&-(0x1f+1)) == 0 && ((1<<uint((_la-202)))&((1<<(SysVerilogHDLParserEscaped_identifier-202))|(1<<(SysVerilogHDLParserSimple_identifier-202))|(1<<(SysVerilogHDLParserLeft_curly_bracket-202)))) != 0) {
		{
			p.SetState(2607)
			p.Loop_step_assignment()
		}

	}
	{
		p.SetState(2610)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}
	{
		p.SetState(2611)
		p.Generate_item()
	}

	return localctx
}

// IGenerate_case_statementContext is an interface to support dynamic dispatch.
type IGenerate_case_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_case_statementContext differentiates from other interfaces.
	IsGenerate_case_statementContext()
}

type Generate_case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_case_statementContext() *Generate_case_statementContext {
	var p = new(Generate_case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_case_statement
	return p
}

func (*Generate_case_statementContext) IsGenerate_case_statementContext() {}

func NewGenerate_case_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_case_statementContext {
	var p = new(Generate_case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_case_statement

	return p
}

func (s *Generate_case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_case_statementContext) Any_case_keyword() IAny_case_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAny_case_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAny_case_keywordContext)
}

func (s *Generate_case_statementContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Generate_case_statementContext) Case_switch() ICase_switchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_switchContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_switchContext)
}

func (s *Generate_case_statementContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Generate_case_statementContext) Generate_case_item_star() IGenerate_case_item_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_case_item_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_case_item_starContext)
}

func (s *Generate_case_statementContext) Endcase() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEndcase, 0)
}

func (s *Generate_case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_case_statement(s)
	}
}

func (s *Generate_case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_case_statement(s)
	}
}

func (p *SysVerilogHDLParser) Generate_case_statement() (localctx IGenerate_case_statementContext) {
	localctx = NewGenerate_case_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, SysVerilogHDLParserRULE_generate_case_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2613)
		p.Any_case_keyword()
	}
	{
		p.SetState(2614)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2615)
		p.Case_switch()
	}
	{
		p.SetState(2616)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}
	{
		p.SetState(2617)
		p.Generate_case_item_star()
	}
	{
		p.SetState(2618)
		p.Match(SysVerilogHDLParserEndcase)
	}

	return localctx
}

// IGenerate_case_item_starContext is an interface to support dynamic dispatch.
type IGenerate_case_item_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_case_item_starContext differentiates from other interfaces.
	IsGenerate_case_item_starContext()
}

type Generate_case_item_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_case_item_starContext() *Generate_case_item_starContext {
	var p = new(Generate_case_item_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_case_item_star
	return p
}

func (*Generate_case_item_starContext) IsGenerate_case_item_starContext() {}

func NewGenerate_case_item_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_case_item_starContext {
	var p = new(Generate_case_item_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_case_item_star

	return p
}

func (s *Generate_case_item_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_case_item_starContext) AllGenerate_case_item() []IGenerate_case_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenerate_case_itemContext)(nil)).Elem())
	var tst = make([]IGenerate_case_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenerate_case_itemContext)
		}
	}

	return tst
}

func (s *Generate_case_item_starContext) Generate_case_item(i int) IGenerate_case_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_case_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenerate_case_itemContext)
}

func (s *Generate_case_item_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_case_item_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_case_item_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_case_item_star(s)
	}
}

func (s *Generate_case_item_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_case_item_star(s)
	}
}

func (p *SysVerilogHDLParser) Generate_case_item_star() (localctx IGenerate_case_item_starContext) {
	localctx = NewGenerate_case_item_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, SysVerilogHDLParserRULE_generate_case_item_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2623)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SysVerilogHDLParserT__1)|(1<<SysVerilogHDLParserT__2)|(1<<SysVerilogHDLParserT__3)|(1<<SysVerilogHDLParserT__4)|(1<<SysVerilogHDLParserT__5)|(1<<SysVerilogHDLParserT__6)|(1<<SysVerilogHDLParserT__7)|(1<<SysVerilogHDLParserT__8)|(1<<SysVerilogHDLParserT__9)|(1<<SysVerilogHDLParserT__10)|(1<<SysVerilogHDLParserT__26)|(1<<SysVerilogHDLParserT__27))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(SysVerilogHDLParserBinary_number-42))|(1<<(SysVerilogHDLParserDecimal_number-42))|(1<<(SysVerilogHDLParserFixed_point_number-42))|(1<<(SysVerilogHDLParserHex_number-42))|(1<<(SysVerilogHDLParserOctal_number-42))|(1<<(SysVerilogHDLParserReal_exp_form-42))|(1<<(SysVerilogHDLParserDefault-42)))) != 0) || _la == SysVerilogHDLParserInt || _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned || (((_la-201)&-(0x1f+1)) == 0 && ((1<<uint((_la-201)))&((1<<(SysVerilogHDLParserDollar_Identifier-201))|(1<<(SysVerilogHDLParserEscaped_identifier-201))|(1<<(SysVerilogHDLParserSimple_identifier-201))|(1<<(SysVerilogHDLParserString_literal-201))|(1<<(SysVerilogHDLParserLeft_curly_bracket-201))|(1<<(SysVerilogHDLParserOpen_parenthesis-201))|(1<<(SysVerilogHDLParserQuote-201))|(1<<(SysVerilogHDLParserTilde-201)))) != 0) {
		{
			p.SetState(2620)
			p.Generate_case_item()
		}

		p.SetState(2625)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGenerate_case_itemContext is an interface to support dynamic dispatch.
type IGenerate_case_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_case_itemContext differentiates from other interfaces.
	IsGenerate_case_itemContext()
}

type Generate_case_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_case_itemContext() *Generate_case_itemContext {
	var p = new(Generate_case_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_generate_case_item
	return p
}

func (*Generate_case_itemContext) IsGenerate_case_itemContext() {}

func NewGenerate_case_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_case_itemContext {
	var p = new(Generate_case_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_generate_case_item

	return p
}

func (s *Generate_case_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_case_itemContext) Colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserColon, 0)
}

func (s *Generate_case_itemContext) Generate_item() IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generate_case_itemContext) Case_item_key() ICase_item_keyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_item_keyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_item_keyContext)
}

func (s *Generate_case_itemContext) Default() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDefault, 0)
}

func (s *Generate_case_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_case_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_case_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterGenerate_case_item(s)
	}
}

func (s *Generate_case_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitGenerate_case_item(s)
	}
}

func (p *SysVerilogHDLParser) Generate_case_item() (localctx IGenerate_case_itemContext) {
	localctx = NewGenerate_case_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, SysVerilogHDLParserRULE_generate_case_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2635)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserT__1, SysVerilogHDLParserT__2, SysVerilogHDLParserT__3, SysVerilogHDLParserT__4, SysVerilogHDLParserT__5, SysVerilogHDLParserT__6, SysVerilogHDLParserT__7, SysVerilogHDLParserT__8, SysVerilogHDLParserT__9, SysVerilogHDLParserT__10, SysVerilogHDLParserT__26, SysVerilogHDLParserT__27, SysVerilogHDLParserBinary_number, SysVerilogHDLParserDecimal_number, SysVerilogHDLParserFixed_point_number, SysVerilogHDLParserHex_number, SysVerilogHDLParserOctal_number, SysVerilogHDLParserReal_exp_form, SysVerilogHDLParserInt, SysVerilogHDLParserSigned, SysVerilogHDLParserUnsigned, SysVerilogHDLParserDollar_Identifier, SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier, SysVerilogHDLParserString_literal, SysVerilogHDLParserLeft_curly_bracket, SysVerilogHDLParserOpen_parenthesis, SysVerilogHDLParserQuote, SysVerilogHDLParserTilde:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2626)
			p.Case_item_key()
		}

		{
			p.SetState(2627)
			p.Match(SysVerilogHDLParserColon)
		}
		{
			p.SetState(2628)
			p.Generate_item()
		}

	case SysVerilogHDLParserDefault:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2630)
			p.Match(SysVerilogHDLParserDefault)
		}
		p.SetState(2632)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SysVerilogHDLParserColon {
			{
				p.SetState(2631)
				p.Match(SysVerilogHDLParserColon)
			}

		}
		{
			p.SetState(2634)
			p.Generate_item()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConditional_statementContext is an interface to support dynamic dispatch.
type IConditional_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_statementContext differentiates from other interfaces.
	IsConditional_statementContext()
}

type Conditional_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_statementContext() *Conditional_statementContext {
	var p = new(Conditional_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_conditional_statement
	return p
}

func (*Conditional_statementContext) IsConditional_statementContext() {}

func NewConditional_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_statementContext {
	var p = new(Conditional_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_conditional_statement

	return p
}

func (s *Conditional_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_statementContext) If_statement() IIf_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_statementContext)
}

func (s *Conditional_statementContext) Else_statement() IElse_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElse_statementContext)
}

func (s *Conditional_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterConditional_statement(s)
	}
}

func (s *Conditional_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitConditional_statement(s)
	}
}

func (p *SysVerilogHDLParser) Conditional_statement() (localctx IConditional_statementContext) {
	localctx = NewConditional_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, SysVerilogHDLParserRULE_conditional_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2637)
		p.If_statement()
	}
	p.SetState(2639)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 204, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2638)
			p.Else_statement()
		}

	}

	return localctx
}

// IIf_statementContext is an interface to support dynamic dispatch.
type IIf_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_statementContext differentiates from other interfaces.
	IsIf_statementContext()
}

type If_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_statementContext() *If_statementContext {
	var p = new(If_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_if_statement
	return p
}

func (*If_statementContext) IsIf_statementContext() {}

func NewIf_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_statementContext {
	var p = new(If_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_if_statement

	return p
}

func (s *If_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *If_statementContext) If() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserIf, 0)
}

func (s *If_statementContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *If_statementContext) Conditional_expression() IConditional_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_expressionContext)
}

func (s *If_statementContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *If_statementContext) Statement_semicolon() IStatement_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_semicolonContext)
}

func (s *If_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterIf_statement(s)
	}
}

func (s *If_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitIf_statement(s)
	}
}

func (p *SysVerilogHDLParser) If_statement() (localctx IIf_statementContext) {
	localctx = NewIf_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, SysVerilogHDLParserRULE_if_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2641)
		p.Match(SysVerilogHDLParserIf)
	}
	{
		p.SetState(2642)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2643)
		p.Conditional_expression()
	}
	{
		p.SetState(2644)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}
	{
		p.SetState(2645)
		p.Statement_semicolon()
	}

	return localctx
}

// IElse_statementContext is an interface to support dynamic dispatch.
type IElse_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElse_statementContext differentiates from other interfaces.
	IsElse_statementContext()
}

type Else_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElse_statementContext() *Else_statementContext {
	var p = new(Else_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_else_statement
	return p
}

func (*Else_statementContext) IsElse_statementContext() {}

func NewElse_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_statementContext {
	var p = new(Else_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_else_statement

	return p
}

func (s *Else_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_statementContext) Else() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserElse, 0)
}

func (s *Else_statementContext) Statement_semicolon() IStatement_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_semicolonContext)
}

func (s *Else_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterElse_statement(s)
	}
}

func (s *Else_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitElse_statement(s)
	}
}

func (p *SysVerilogHDLParser) Else_statement() (localctx IElse_statementContext) {
	localctx = NewElse_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, SysVerilogHDLParserRULE_else_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2647)
		p.Match(SysVerilogHDLParserElse)
	}
	{
		p.SetState(2648)
		p.Statement_semicolon()
	}

	return localctx
}

// IConditional_expressionContext is an interface to support dynamic dispatch.
type IConditional_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_expressionContext differentiates from other interfaces.
	IsConditional_expressionContext()
}

type Conditional_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_expressionContext() *Conditional_expressionContext {
	var p = new(Conditional_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_conditional_expression
	return p
}

func (*Conditional_expressionContext) IsConditional_expressionContext() {}

func NewConditional_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_expressionContext {
	var p = new(Conditional_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_conditional_expression

	return p
}

func (s *Conditional_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Conditional_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterConditional_expression(s)
	}
}

func (s *Conditional_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitConditional_expression(s)
	}
}

func (p *SysVerilogHDLParser) Conditional_expression() (localctx IConditional_expressionContext) {
	localctx = NewConditional_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, SysVerilogHDLParserRULE_conditional_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2650)
		p.Expression()
	}

	return localctx
}

// ILoop_statementContext is an interface to support dynamic dispatch.
type ILoop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_statementContext differentiates from other interfaces.
	IsLoop_statementContext()
}

type Loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_statementContext() *Loop_statementContext {
	var p = new(Loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_loop_statement
	return p
}

func (*Loop_statementContext) IsLoop_statementContext() {}

func NewLoop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_statementContext {
	var p = new(Loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_loop_statement

	return p
}

func (s *Loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_statementContext) Forever_loop_statement() IForever_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForever_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForever_loop_statementContext)
}

func (s *Loop_statementContext) Repeat_loop_statement() IRepeat_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRepeat_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRepeat_loop_statementContext)
}

func (s *Loop_statementContext) While_loop_statement() IWhile_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhile_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhile_loop_statementContext)
}

func (s *Loop_statementContext) Do_loop_statement() IDo_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDo_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDo_loop_statementContext)
}

func (s *Loop_statementContext) For_loop_statement() IFor_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_loop_statementContext)
}

func (s *Loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterLoop_statement(s)
	}
}

func (s *Loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitLoop_statement(s)
	}
}

func (p *SysVerilogHDLParser) Loop_statement() (localctx ILoop_statementContext) {
	localctx = NewLoop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, SysVerilogHDLParserRULE_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2657)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserForever:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2652)
			p.Forever_loop_statement()
		}

	case SysVerilogHDLParserRepeat:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2653)
			p.Repeat_loop_statement()
		}

	case SysVerilogHDLParserWhile:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2654)
			p.While_loop_statement()
		}

	case SysVerilogHDLParserDo:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2655)
			p.Do_loop_statement()
		}

	case SysVerilogHDLParserFor:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2656)
			p.For_loop_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IForever_loop_statementContext is an interface to support dynamic dispatch.
type IForever_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForever_loop_statementContext differentiates from other interfaces.
	IsForever_loop_statementContext()
}

type Forever_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForever_loop_statementContext() *Forever_loop_statementContext {
	var p = new(Forever_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_forever_loop_statement
	return p
}

func (*Forever_loop_statementContext) IsForever_loop_statementContext() {}

func NewForever_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Forever_loop_statementContext {
	var p = new(Forever_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_forever_loop_statement

	return p
}

func (s *Forever_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Forever_loop_statementContext) Forever() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserForever, 0)
}

func (s *Forever_loop_statementContext) Statement_semicolon() IStatement_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_semicolonContext)
}

func (s *Forever_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Forever_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Forever_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterForever_loop_statement(s)
	}
}

func (s *Forever_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitForever_loop_statement(s)
	}
}

func (p *SysVerilogHDLParser) Forever_loop_statement() (localctx IForever_loop_statementContext) {
	localctx = NewForever_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, SysVerilogHDLParserRULE_forever_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2659)
		p.Match(SysVerilogHDLParserForever)
	}
	{
		p.SetState(2660)
		p.Statement_semicolon()
	}

	return localctx
}

// IRepeat_loop_statementContext is an interface to support dynamic dispatch.
type IRepeat_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRepeat_loop_statementContext differentiates from other interfaces.
	IsRepeat_loop_statementContext()
}

type Repeat_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeat_loop_statementContext() *Repeat_loop_statementContext {
	var p = new(Repeat_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_repeat_loop_statement
	return p
}

func (*Repeat_loop_statementContext) IsRepeat_loop_statementContext() {}

func NewRepeat_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Repeat_loop_statementContext {
	var p = new(Repeat_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_repeat_loop_statement

	return p
}

func (s *Repeat_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Repeat_loop_statementContext) Repeat() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRepeat, 0)
}

func (s *Repeat_loop_statementContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Repeat_loop_statementContext) Loop_terminate_expression() ILoop_terminate_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_terminate_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_terminate_expressionContext)
}

func (s *Repeat_loop_statementContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Repeat_loop_statementContext) Statement_semicolon() IStatement_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_semicolonContext)
}

func (s *Repeat_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Repeat_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Repeat_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterRepeat_loop_statement(s)
	}
}

func (s *Repeat_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitRepeat_loop_statement(s)
	}
}

func (p *SysVerilogHDLParser) Repeat_loop_statement() (localctx IRepeat_loop_statementContext) {
	localctx = NewRepeat_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, SysVerilogHDLParserRULE_repeat_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2662)
		p.Match(SysVerilogHDLParserRepeat)
	}
	{
		p.SetState(2663)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2664)
		p.Loop_terminate_expression()
	}
	{
		p.SetState(2665)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}
	{
		p.SetState(2666)
		p.Statement_semicolon()
	}

	return localctx
}

// IWhile_loop_statementContext is an interface to support dynamic dispatch.
type IWhile_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhile_loop_statementContext differentiates from other interfaces.
	IsWhile_loop_statementContext()
}

type While_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhile_loop_statementContext() *While_loop_statementContext {
	var p = new(While_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_while_loop_statement
	return p
}

func (*While_loop_statementContext) IsWhile_loop_statementContext() {}

func NewWhile_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_loop_statementContext {
	var p = new(While_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_while_loop_statement

	return p
}

func (s *While_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *While_loop_statementContext) While() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserWhile, 0)
}

func (s *While_loop_statementContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *While_loop_statementContext) Loop_terminate_expression() ILoop_terminate_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_terminate_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_terminate_expressionContext)
}

func (s *While_loop_statementContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *While_loop_statementContext) Statement_semicolon() IStatement_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_semicolonContext)
}

func (s *While_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *While_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterWhile_loop_statement(s)
	}
}

func (s *While_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitWhile_loop_statement(s)
	}
}

func (p *SysVerilogHDLParser) While_loop_statement() (localctx IWhile_loop_statementContext) {
	localctx = NewWhile_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, SysVerilogHDLParserRULE_while_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2668)
		p.Match(SysVerilogHDLParserWhile)
	}
	{
		p.SetState(2669)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2670)
		p.Loop_terminate_expression()
	}
	{
		p.SetState(2671)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}
	{
		p.SetState(2672)
		p.Statement_semicolon()
	}

	return localctx
}

// IDo_loop_statementContext is an interface to support dynamic dispatch.
type IDo_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDo_loop_statementContext differentiates from other interfaces.
	IsDo_loop_statementContext()
}

type Do_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDo_loop_statementContext() *Do_loop_statementContext {
	var p = new(Do_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_do_loop_statement
	return p
}

func (*Do_loop_statementContext) IsDo_loop_statementContext() {}

func NewDo_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Do_loop_statementContext {
	var p = new(Do_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_do_loop_statement

	return p
}

func (s *Do_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Do_loop_statementContext) Do() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDo, 0)
}

func (s *Do_loop_statementContext) Statement_semicolon() IStatement_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_semicolonContext)
}

func (s *Do_loop_statementContext) While() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserWhile, 0)
}

func (s *Do_loop_statementContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Do_loop_statementContext) Loop_terminate_expression() ILoop_terminate_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_terminate_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_terminate_expressionContext)
}

func (s *Do_loop_statementContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Do_loop_statementContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Do_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Do_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Do_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDo_loop_statement(s)
	}
}

func (s *Do_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDo_loop_statement(s)
	}
}

func (p *SysVerilogHDLParser) Do_loop_statement() (localctx IDo_loop_statementContext) {
	localctx = NewDo_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, SysVerilogHDLParserRULE_do_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2674)
		p.Match(SysVerilogHDLParserDo)
	}
	{
		p.SetState(2675)
		p.Statement_semicolon()
	}
	{
		p.SetState(2676)
		p.Match(SysVerilogHDLParserWhile)
	}
	{
		p.SetState(2677)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2678)
		p.Loop_terminate_expression()
	}
	{
		p.SetState(2679)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}
	{
		p.SetState(2680)
		p.Semicolon()
	}

	return localctx
}

// IFor_loop_statementContext is an interface to support dynamic dispatch.
type IFor_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_loop_statementContext differentiates from other interfaces.
	IsFor_loop_statementContext()
}

type For_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_loop_statementContext() *For_loop_statementContext {
	var p = new(For_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_for_loop_statement
	return p
}

func (*For_loop_statementContext) IsFor_loop_statementContext() {}

func NewFor_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_loop_statementContext {
	var p = new(For_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_for_loop_statement

	return p
}

func (s *For_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *For_loop_statementContext) For() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserFor, 0)
}

func (s *For_loop_statementContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *For_loop_statementContext) Loop_init_assignment() ILoop_init_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_init_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_init_assignmentContext)
}

func (s *For_loop_statementContext) AllSemicolon() []ISemicolonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISemicolonContext)(nil)).Elem())
	var tst = make([]ISemicolonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISemicolonContext)
		}
	}

	return tst
}

func (s *For_loop_statementContext) Semicolon(i int) ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *For_loop_statementContext) Loop_terminate_expression() ILoop_terminate_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_terminate_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_terminate_expressionContext)
}

func (s *For_loop_statementContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *For_loop_statementContext) Statement_semicolon() IStatement_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_semicolonContext)
}

func (s *For_loop_statementContext) Loop_step_assignment() ILoop_step_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_step_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_step_assignmentContext)
}

func (s *For_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterFor_loop_statement(s)
	}
}

func (s *For_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitFor_loop_statement(s)
	}
}

func (p *SysVerilogHDLParser) For_loop_statement() (localctx IFor_loop_statementContext) {
	localctx = NewFor_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, SysVerilogHDLParserRULE_for_loop_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2682)
		p.Match(SysVerilogHDLParserFor)
	}
	{
		p.SetState(2683)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2684)
		p.Loop_init_assignment()
	}
	{
		p.SetState(2685)
		p.Semicolon()
	}
	{
		p.SetState(2686)
		p.Loop_terminate_expression()
	}
	{
		p.SetState(2687)
		p.Semicolon()
	}
	p.SetState(2689)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserT__26 || _la == SysVerilogHDLParserT__27 || (((_la-202)&-(0x1f+1)) == 0 && ((1<<uint((_la-202)))&((1<<(SysVerilogHDLParserEscaped_identifier-202))|(1<<(SysVerilogHDLParserSimple_identifier-202))|(1<<(SysVerilogHDLParserLeft_curly_bracket-202)))) != 0) {
		{
			p.SetState(2688)
			p.Loop_step_assignment()
		}

	}
	{
		p.SetState(2691)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}
	{
		p.SetState(2692)
		p.Statement_semicolon()
	}

	return localctx
}

// ILoop_init_assignmentContext is an interface to support dynamic dispatch.
type ILoop_init_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_init_assignmentContext differentiates from other interfaces.
	IsLoop_init_assignmentContext()
}

type Loop_init_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_init_assignmentContext() *Loop_init_assignmentContext {
	var p = new(Loop_init_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_loop_init_assignment
	return p
}

func (*Loop_init_assignmentContext) IsLoop_init_assignmentContext() {}

func NewLoop_init_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_init_assignmentContext {
	var p = new(Loop_init_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_loop_init_assignment

	return p
}

func (s *Loop_init_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_init_assignmentContext) Declarative_assignment() IDeclarative_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarative_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarative_assignmentContext)
}

func (s *Loop_init_assignmentContext) Blocking_assignment() IBlocking_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlocking_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlocking_assignmentContext)
}

func (s *Loop_init_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_init_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_init_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterLoop_init_assignment(s)
	}
}

func (s *Loop_init_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitLoop_init_assignment(s)
	}
}

func (p *SysVerilogHDLParser) Loop_init_assignment() (localctx ILoop_init_assignmentContext) {
	localctx = NewLoop_init_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, SysVerilogHDLParserRULE_loop_init_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2696)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserAutomatic, SysVerilogHDLParserBit, SysVerilogHDLParserByte, SysVerilogHDLParserConst, SysVerilogHDLParserGenvar, SysVerilogHDLParserInt, SysVerilogHDLParserInteger, SysVerilogHDLParserLogic, SysVerilogHDLParserReg, SysVerilogHDLParserStatic:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2694)
			p.Declarative_assignment()
		}

	case SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier, SysVerilogHDLParserLeft_curly_bracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2695)
			p.Blocking_assignment()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILoop_terminate_expressionContext is an interface to support dynamic dispatch.
type ILoop_terminate_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_terminate_expressionContext differentiates from other interfaces.
	IsLoop_terminate_expressionContext()
}

type Loop_terminate_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_terminate_expressionContext() *Loop_terminate_expressionContext {
	var p = new(Loop_terminate_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_loop_terminate_expression
	return p
}

func (*Loop_terminate_expressionContext) IsLoop_terminate_expressionContext() {}

func NewLoop_terminate_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_terminate_expressionContext {
	var p = new(Loop_terminate_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_loop_terminate_expression

	return p
}

func (s *Loop_terminate_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_terminate_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Loop_terminate_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_terminate_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_terminate_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterLoop_terminate_expression(s)
	}
}

func (s *Loop_terminate_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitLoop_terminate_expression(s)
	}
}

func (p *SysVerilogHDLParser) Loop_terminate_expression() (localctx ILoop_terminate_expressionContext) {
	localctx = NewLoop_terminate_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, SysVerilogHDLParserRULE_loop_terminate_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2698)
		p.Expression()
	}

	return localctx
}

// ILoop_step_assignmentContext is an interface to support dynamic dispatch.
type ILoop_step_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_step_assignmentContext differentiates from other interfaces.
	IsLoop_step_assignmentContext()
}

type Loop_step_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_step_assignmentContext() *Loop_step_assignmentContext {
	var p = new(Loop_step_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_loop_step_assignment
	return p
}

func (*Loop_step_assignmentContext) IsLoop_step_assignmentContext() {}

func NewLoop_step_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_step_assignmentContext {
	var p = new(Loop_step_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_loop_step_assignment

	return p
}

func (s *Loop_step_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_step_assignmentContext) Blocking_assignment() IBlocking_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlocking_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlocking_assignmentContext)
}

func (s *Loop_step_assignmentContext) Postfix_assignment() IPostfix_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfix_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfix_assignmentContext)
}

func (s *Loop_step_assignmentContext) Prefix_assignment() IPrefix_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefix_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrefix_assignmentContext)
}

func (s *Loop_step_assignmentContext) Operator_assignment() IOperator_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperator_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperator_assignmentContext)
}

func (s *Loop_step_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_step_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_step_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterLoop_step_assignment(s)
	}
}

func (s *Loop_step_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitLoop_step_assignment(s)
	}
}

func (p *SysVerilogHDLParser) Loop_step_assignment() (localctx ILoop_step_assignmentContext) {
	localctx = NewLoop_step_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, SysVerilogHDLParserRULE_loop_step_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2704)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2700)
			p.Blocking_assignment()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2701)
			p.Postfix_assignment()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2702)
			p.Prefix_assignment()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2703)
			p.Operator_assignment()
		}

	}

	return localctx
}

// ICase_statementContext is an interface to support dynamic dispatch.
type ICase_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_statementContext differentiates from other interfaces.
	IsCase_statementContext()
}

type Case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_statementContext() *Case_statementContext {
	var p = new(Case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_case_statement
	return p
}

func (*Case_statementContext) IsCase_statementContext() {}

func NewCase_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_statementContext {
	var p = new(Case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_case_statement

	return p
}

func (s *Case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_statementContext) Any_case_keyword() IAny_case_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAny_case_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAny_case_keywordContext)
}

func (s *Case_statementContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Case_statementContext) Case_switch() ICase_switchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_switchContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_switchContext)
}

func (s *Case_statementContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Case_statementContext) Case_item_star() ICase_item_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_item_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_item_starContext)
}

func (s *Case_statementContext) Endcase() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEndcase, 0)
}

func (s *Case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterCase_statement(s)
	}
}

func (s *Case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitCase_statement(s)
	}
}

func (p *SysVerilogHDLParser) Case_statement() (localctx ICase_statementContext) {
	localctx = NewCase_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, SysVerilogHDLParserRULE_case_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2706)
		p.Any_case_keyword()
	}
	{
		p.SetState(2707)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2708)
		p.Case_switch()
	}
	{
		p.SetState(2709)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}
	{
		p.SetState(2710)
		p.Case_item_star()
	}
	{
		p.SetState(2711)
		p.Match(SysVerilogHDLParserEndcase)
	}

	return localctx
}

// ICase_item_starContext is an interface to support dynamic dispatch.
type ICase_item_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_item_starContext differentiates from other interfaces.
	IsCase_item_starContext()
}

type Case_item_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_item_starContext() *Case_item_starContext {
	var p = new(Case_item_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_case_item_star
	return p
}

func (*Case_item_starContext) IsCase_item_starContext() {}

func NewCase_item_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_item_starContext {
	var p = new(Case_item_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_case_item_star

	return p
}

func (s *Case_item_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_item_starContext) AllCase_item() []ICase_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICase_itemContext)(nil)).Elem())
	var tst = make([]ICase_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICase_itemContext)
		}
	}

	return tst
}

func (s *Case_item_starContext) Case_item(i int) ICase_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICase_itemContext)
}

func (s *Case_item_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_item_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_item_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterCase_item_star(s)
	}
}

func (s *Case_item_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitCase_item_star(s)
	}
}

func (p *SysVerilogHDLParser) Case_item_star() (localctx ICase_item_starContext) {
	localctx = NewCase_item_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, SysVerilogHDLParserRULE_case_item_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2716)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SysVerilogHDLParserT__1)|(1<<SysVerilogHDLParserT__2)|(1<<SysVerilogHDLParserT__3)|(1<<SysVerilogHDLParserT__4)|(1<<SysVerilogHDLParserT__5)|(1<<SysVerilogHDLParserT__6)|(1<<SysVerilogHDLParserT__7)|(1<<SysVerilogHDLParserT__8)|(1<<SysVerilogHDLParserT__9)|(1<<SysVerilogHDLParserT__10)|(1<<SysVerilogHDLParserT__26)|(1<<SysVerilogHDLParserT__27))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(SysVerilogHDLParserBinary_number-42))|(1<<(SysVerilogHDLParserDecimal_number-42))|(1<<(SysVerilogHDLParserFixed_point_number-42))|(1<<(SysVerilogHDLParserHex_number-42))|(1<<(SysVerilogHDLParserOctal_number-42))|(1<<(SysVerilogHDLParserReal_exp_form-42))|(1<<(SysVerilogHDLParserDefault-42)))) != 0) || _la == SysVerilogHDLParserInt || _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned || (((_la-201)&-(0x1f+1)) == 0 && ((1<<uint((_la-201)))&((1<<(SysVerilogHDLParserDollar_Identifier-201))|(1<<(SysVerilogHDLParserEscaped_identifier-201))|(1<<(SysVerilogHDLParserSimple_identifier-201))|(1<<(SysVerilogHDLParserString_literal-201))|(1<<(SysVerilogHDLParserLeft_curly_bracket-201))|(1<<(SysVerilogHDLParserOpen_parenthesis-201))|(1<<(SysVerilogHDLParserQuote-201))|(1<<(SysVerilogHDLParserTilde-201)))) != 0) {
		{
			p.SetState(2713)
			p.Case_item()
		}

		p.SetState(2718)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICase_itemContext is an interface to support dynamic dispatch.
type ICase_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_itemContext differentiates from other interfaces.
	IsCase_itemContext()
}

type Case_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_itemContext() *Case_itemContext {
	var p = new(Case_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_case_item
	return p
}

func (*Case_itemContext) IsCase_itemContext() {}

func NewCase_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_itemContext {
	var p = new(Case_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_case_item

	return p
}

func (s *Case_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_itemContext) Colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserColon, 0)
}

func (s *Case_itemContext) Statement_semicolon() IStatement_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_semicolonContext)
}

func (s *Case_itemContext) Case_item_key() ICase_item_keyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_item_keyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_item_keyContext)
}

func (s *Case_itemContext) Default() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDefault, 0)
}

func (s *Case_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterCase_item(s)
	}
}

func (s *Case_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitCase_item(s)
	}
}

func (p *SysVerilogHDLParser) Case_item() (localctx ICase_itemContext) {
	localctx = NewCase_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, SysVerilogHDLParserRULE_case_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2728)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserT__1, SysVerilogHDLParserT__2, SysVerilogHDLParserT__3, SysVerilogHDLParserT__4, SysVerilogHDLParserT__5, SysVerilogHDLParserT__6, SysVerilogHDLParserT__7, SysVerilogHDLParserT__8, SysVerilogHDLParserT__9, SysVerilogHDLParserT__10, SysVerilogHDLParserT__26, SysVerilogHDLParserT__27, SysVerilogHDLParserBinary_number, SysVerilogHDLParserDecimal_number, SysVerilogHDLParserFixed_point_number, SysVerilogHDLParserHex_number, SysVerilogHDLParserOctal_number, SysVerilogHDLParserReal_exp_form, SysVerilogHDLParserInt, SysVerilogHDLParserSigned, SysVerilogHDLParserUnsigned, SysVerilogHDLParserDollar_Identifier, SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier, SysVerilogHDLParserString_literal, SysVerilogHDLParserLeft_curly_bracket, SysVerilogHDLParserOpen_parenthesis, SysVerilogHDLParserQuote, SysVerilogHDLParserTilde:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2719)
			p.Case_item_key()
		}

		{
			p.SetState(2720)
			p.Match(SysVerilogHDLParserColon)
		}
		{
			p.SetState(2721)
			p.Statement_semicolon()
		}

	case SysVerilogHDLParserDefault:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2723)
			p.Match(SysVerilogHDLParserDefault)
		}
		p.SetState(2725)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SysVerilogHDLParserColon {
			{
				p.SetState(2724)
				p.Match(SysVerilogHDLParserColon)
			}

		}
		{
			p.SetState(2727)
			p.Statement_semicolon()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICase_switchContext is an interface to support dynamic dispatch.
type ICase_switchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_switchContext differentiates from other interfaces.
	IsCase_switchContext()
}

type Case_switchContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_switchContext() *Case_switchContext {
	var p = new(Case_switchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_case_switch
	return p
}

func (*Case_switchContext) IsCase_switchContext() {}

func NewCase_switchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_switchContext {
	var p = new(Case_switchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_case_switch

	return p
}

func (s *Case_switchContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_switchContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_switchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_switchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_switchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterCase_switch(s)
	}
}

func (s *Case_switchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitCase_switch(s)
	}
}

func (p *SysVerilogHDLParser) Case_switch() (localctx ICase_switchContext) {
	localctx = NewCase_switchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, SysVerilogHDLParserRULE_case_switch)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2730)
		p.Expression()
	}

	return localctx
}

// ICase_item_keyContext is an interface to support dynamic dispatch.
type ICase_item_keyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_item_keyContext differentiates from other interfaces.
	IsCase_item_keyContext()
}

type Case_item_keyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_item_keyContext() *Case_item_keyContext {
	var p = new(Case_item_keyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_case_item_key
	return p
}

func (*Case_item_keyContext) IsCase_item_keyContext() {}

func NewCase_item_keyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_item_keyContext {
	var p = new(Case_item_keyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_case_item_key

	return p
}

func (s *Case_item_keyContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_item_keyContext) Case_item_key_expression() ICase_item_key_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_item_key_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_item_key_expressionContext)
}

func (s *Case_item_keyContext) Comma_case_item_key_expression_star() IComma_case_item_key_expression_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_case_item_key_expression_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_case_item_key_expression_starContext)
}

func (s *Case_item_keyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_item_keyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_item_keyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterCase_item_key(s)
	}
}

func (s *Case_item_keyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitCase_item_key(s)
	}
}

func (p *SysVerilogHDLParser) Case_item_key() (localctx ICase_item_keyContext) {
	localctx = NewCase_item_keyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, SysVerilogHDLParserRULE_case_item_key)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2732)
		p.Case_item_key_expression()
	}
	{
		p.SetState(2733)
		p.Comma_case_item_key_expression_star()
	}

	return localctx
}

// ICase_item_key_expressionContext is an interface to support dynamic dispatch.
type ICase_item_key_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_item_key_expressionContext differentiates from other interfaces.
	IsCase_item_key_expressionContext()
}

type Case_item_key_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_item_key_expressionContext() *Case_item_key_expressionContext {
	var p = new(Case_item_key_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_case_item_key_expression
	return p
}

func (*Case_item_key_expressionContext) IsCase_item_key_expressionContext() {}

func NewCase_item_key_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_item_key_expressionContext {
	var p = new(Case_item_key_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_case_item_key_expression

	return p
}

func (s *Case_item_key_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_item_key_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_item_key_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_item_key_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_item_key_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterCase_item_key_expression(s)
	}
}

func (s *Case_item_key_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitCase_item_key_expression(s)
	}
}

func (p *SysVerilogHDLParser) Case_item_key_expression() (localctx ICase_item_key_expressionContext) {
	localctx = NewCase_item_key_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, SysVerilogHDLParserRULE_case_item_key_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2735)
		p.Expression()
	}

	return localctx
}

// IComma_case_item_key_expressionContext is an interface to support dynamic dispatch.
type IComma_case_item_key_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_case_item_key_expressionContext differentiates from other interfaces.
	IsComma_case_item_key_expressionContext()
}

type Comma_case_item_key_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_case_item_key_expressionContext() *Comma_case_item_key_expressionContext {
	var p = new(Comma_case_item_key_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_case_item_key_expression
	return p
}

func (*Comma_case_item_key_expressionContext) IsComma_case_item_key_expressionContext() {}

func NewComma_case_item_key_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_case_item_key_expressionContext {
	var p = new(Comma_case_item_key_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_case_item_key_expression

	return p
}

func (s *Comma_case_item_key_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_case_item_key_expressionContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_case_item_key_expressionContext) Case_item_key_expression() ICase_item_key_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_item_key_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_item_key_expressionContext)
}

func (s *Comma_case_item_key_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_case_item_key_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_case_item_key_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_case_item_key_expression(s)
	}
}

func (s *Comma_case_item_key_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_case_item_key_expression(s)
	}
}

func (p *SysVerilogHDLParser) Comma_case_item_key_expression() (localctx IComma_case_item_key_expressionContext) {
	localctx = NewComma_case_item_key_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, SysVerilogHDLParserRULE_comma_case_item_key_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2737)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2738)
		p.Case_item_key_expression()
	}

	return localctx
}

// IComma_case_item_key_expression_starContext is an interface to support dynamic dispatch.
type IComma_case_item_key_expression_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_case_item_key_expression_starContext differentiates from other interfaces.
	IsComma_case_item_key_expression_starContext()
}

type Comma_case_item_key_expression_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_case_item_key_expression_starContext() *Comma_case_item_key_expression_starContext {
	var p = new(Comma_case_item_key_expression_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_case_item_key_expression_star
	return p
}

func (*Comma_case_item_key_expression_starContext) IsComma_case_item_key_expression_starContext() {}

func NewComma_case_item_key_expression_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_case_item_key_expression_starContext {
	var p = new(Comma_case_item_key_expression_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_case_item_key_expression_star

	return p
}

func (s *Comma_case_item_key_expression_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_case_item_key_expression_starContext) AllComma_case_item_key_expression() []IComma_case_item_key_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_case_item_key_expressionContext)(nil)).Elem())
	var tst = make([]IComma_case_item_key_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_case_item_key_expressionContext)
		}
	}

	return tst
}

func (s *Comma_case_item_key_expression_starContext) Comma_case_item_key_expression(i int) IComma_case_item_key_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_case_item_key_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_case_item_key_expressionContext)
}

func (s *Comma_case_item_key_expression_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_case_item_key_expression_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_case_item_key_expression_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_case_item_key_expression_star(s)
	}
}

func (s *Comma_case_item_key_expression_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_case_item_key_expression_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_case_item_key_expression_star() (localctx IComma_case_item_key_expression_starContext) {
	localctx = NewComma_case_item_key_expression_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, SysVerilogHDLParserRULE_comma_case_item_key_expression_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2743)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(2740)
			p.Comma_case_item_key_expression()
		}

		p.SetState(2745)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Unary_expression() IUnary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_expressionContext)
}

func (s *ExpressionContext) Unary_post_assign_expression() IUnary_post_assign_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_post_assign_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_post_assign_expressionContext)
}

func (s *ExpressionContext) Unary_pre_assign_expression() IUnary_pre_assign_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_pre_assign_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_pre_assign_expressionContext)
}

func (s *ExpressionContext) Binary_expression() IBinary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinary_expressionContext)
}

func (s *ExpressionContext) Ternary_expression() ITernary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITernary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITernary_expressionContext)
}

func (s *ExpressionContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *ExpressionContext) Single_expression() ISingle_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_expressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *SysVerilogHDLParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, SysVerilogHDLParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2753)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 213, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2746)
			p.Unary_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2747)
			p.Unary_post_assign_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2748)
			p.Unary_pre_assign_expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2749)
			p.Binary_expression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2750)
			p.Ternary_expression()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2751)
			p.Mintypmax_expression()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2752)
			p.Single_expression()
		}

	}

	return localctx
}

// ISingle_expressionContext is an interface to support dynamic dispatch.
type ISingle_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingle_expressionContext differentiates from other interfaces.
	IsSingle_expressionContext()
}

type Single_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_expressionContext() *Single_expressionContext {
	var p = new(Single_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_single_expression
	return p
}

func (*Single_expressionContext) IsSingle_expressionContext() {}

func NewSingle_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_expressionContext {
	var p = new(Single_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_single_expression

	return p
}

func (s *Single_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_expressionContext) String_literal() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserString_literal, 0)
}

func (s *Single_expressionContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *Single_expressionContext) Arrayed_structured_value() IArrayed_structured_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayed_structured_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayed_structured_valueContext)
}

func (s *Single_expressionContext) Structured_value() IStructured_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStructured_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStructured_valueContext)
}

func (s *Single_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterSingle_expression(s)
	}
}

func (s *Single_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitSingle_expression(s)
	}
}

func (p *SysVerilogHDLParser) Single_expression() (localctx ISingle_expressionContext) {
	localctx = NewSingle_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, SysVerilogHDLParserRULE_single_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2759)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 214, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2755)
			p.Match(SysVerilogHDLParserString_literal)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2756)
			p.Primary()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2757)
			p.Arrayed_structured_value()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2758)
			p.Structured_value()
		}

	}

	return localctx
}

// IPrimary_rangeContext is an interface to support dynamic dispatch.
type IPrimary_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_rangeContext differentiates from other interfaces.
	IsPrimary_rangeContext()
}

type Primary_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_rangeContext() *Primary_rangeContext {
	var p = new(Primary_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_primary_range
	return p
}

func (*Primary_rangeContext) IsPrimary_rangeContext() {}

func NewPrimary_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_rangeContext {
	var p = new(Primary_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_primary_range

	return p
}

func (s *Primary_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_rangeContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *Primary_rangeContext) Dimension() IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Primary_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Primary_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPrimary_range(s)
	}
}

func (s *Primary_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPrimary_range(s)
	}
}

func (p *SysVerilogHDLParser) Primary_range() (localctx IPrimary_rangeContext) {
	localctx = NewPrimary_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, SysVerilogHDLParserRULE_primary_range)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2761)
		p.Primary()
	}
	{
		p.SetState(2762)
		p.Dimension()
	}

	return localctx
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_primary
	return p
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *PrimaryContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *PrimaryContext) Multiple_concatenation() IMultiple_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiple_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiple_concatenationContext)
}

func (s *PrimaryContext) Function_call() IFunction_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_callContext)
}

func (s *PrimaryContext) System_function_call() ISystem_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_function_callContext)
}

func (s *PrimaryContext) Constant_function_call() IConstant_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_function_callContext)
}

func (s *PrimaryContext) Imported_function_call() IImported_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImported_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImported_function_callContext)
}

func (s *PrimaryContext) Primary_imported_hierarchical_identifier() IPrimary_imported_hierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_imported_hierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_imported_hierarchical_identifierContext)
}

func (s *PrimaryContext) Primary_hierarchical_identifier() IPrimary_hierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_hierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_hierarchical_identifierContext)
}

func (s *PrimaryContext) Type_cast_expression() IType_cast_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_cast_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_cast_expressionContext)
}

func (s *PrimaryContext) Parenthesis_expression() IParenthesis_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesis_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesis_expressionContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (p *SysVerilogHDLParser) Primary() (localctx IPrimaryContext) {
	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, SysVerilogHDLParserRULE_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2775)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 215, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2764)
			p.Number()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2765)
			p.Concatenation()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2766)
			p.Multiple_concatenation()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2767)
			p.Function_call()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2768)
			p.System_function_call()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2769)
			p.Constant_function_call()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2770)
			p.Imported_function_call()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2771)
			p.Primary_imported_hierarchical_identifier()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2772)
			p.Primary_hierarchical_identifier()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2773)
			p.Type_cast_expression()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2774)
			p.Parenthesis_expression()
		}

	}

	return localctx
}

// IUnary_expressionContext is an interface to support dynamic dispatch.
type IUnary_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_expressionContext differentiates from other interfaces.
	IsUnary_expressionContext()
}

type Unary_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_expressionContext() *Unary_expressionContext {
	var p = new(Unary_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_unary_expression
	return p
}

func (*Unary_expressionContext) IsUnary_expressionContext() {}

func NewUnary_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_expressionContext {
	var p = new(Unary_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_unary_expression

	return p
}

func (s *Unary_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_expressionContext) Unary_operator() IUnary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_operatorContext)
}

func (s *Unary_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Unary_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterUnary_expression(s)
	}
}

func (s *Unary_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitUnary_expression(s)
	}
}

func (p *SysVerilogHDLParser) Unary_expression() (localctx IUnary_expressionContext) {
	localctx = NewUnary_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, SysVerilogHDLParserRULE_unary_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2777)
		p.Unary_operator()
	}
	{
		p.SetState(2778)
		p.Expression()
	}

	return localctx
}

// IUnary_post_assign_expressionContext is an interface to support dynamic dispatch.
type IUnary_post_assign_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_post_assign_expressionContext differentiates from other interfaces.
	IsUnary_post_assign_expressionContext()
}

type Unary_post_assign_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_post_assign_expressionContext() *Unary_post_assign_expressionContext {
	var p = new(Unary_post_assign_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_unary_post_assign_expression
	return p
}

func (*Unary_post_assign_expressionContext) IsUnary_post_assign_expressionContext() {}

func NewUnary_post_assign_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_post_assign_expressionContext {
	var p = new(Unary_post_assign_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_unary_post_assign_expression

	return p
}

func (s *Unary_post_assign_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_post_assign_expressionContext) Single_expression() ISingle_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_expressionContext)
}

func (s *Unary_post_assign_expressionContext) Unary_assign_operator() IUnary_assign_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_assign_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_assign_operatorContext)
}

func (s *Unary_post_assign_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_post_assign_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_post_assign_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterUnary_post_assign_expression(s)
	}
}

func (s *Unary_post_assign_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitUnary_post_assign_expression(s)
	}
}

func (p *SysVerilogHDLParser) Unary_post_assign_expression() (localctx IUnary_post_assign_expressionContext) {
	localctx = NewUnary_post_assign_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, SysVerilogHDLParserRULE_unary_post_assign_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2780)
		p.Single_expression()
	}
	{
		p.SetState(2781)
		p.Unary_assign_operator()
	}

	return localctx
}

// IUnary_pre_assign_expressionContext is an interface to support dynamic dispatch.
type IUnary_pre_assign_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_pre_assign_expressionContext differentiates from other interfaces.
	IsUnary_pre_assign_expressionContext()
}

type Unary_pre_assign_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_pre_assign_expressionContext() *Unary_pre_assign_expressionContext {
	var p = new(Unary_pre_assign_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_unary_pre_assign_expression
	return p
}

func (*Unary_pre_assign_expressionContext) IsUnary_pre_assign_expressionContext() {}

func NewUnary_pre_assign_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_pre_assign_expressionContext {
	var p = new(Unary_pre_assign_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_unary_pre_assign_expression

	return p
}

func (s *Unary_pre_assign_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_pre_assign_expressionContext) Unary_assign_operator() IUnary_assign_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_assign_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_assign_operatorContext)
}

func (s *Unary_pre_assign_expressionContext) Single_expression() ISingle_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_expressionContext)
}

func (s *Unary_pre_assign_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_pre_assign_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_pre_assign_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterUnary_pre_assign_expression(s)
	}
}

func (s *Unary_pre_assign_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitUnary_pre_assign_expression(s)
	}
}

func (p *SysVerilogHDLParser) Unary_pre_assign_expression() (localctx IUnary_pre_assign_expressionContext) {
	localctx = NewUnary_pre_assign_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, SysVerilogHDLParserRULE_unary_pre_assign_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2783)
		p.Unary_assign_operator()
	}
	{
		p.SetState(2784)
		p.Single_expression()
	}

	return localctx
}

// IBinary_expressionContext is an interface to support dynamic dispatch.
type IBinary_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinary_expressionContext differentiates from other interfaces.
	IsBinary_expressionContext()
}

type Binary_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinary_expressionContext() *Binary_expressionContext {
	var p = new(Binary_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_binary_expression
	return p
}

func (*Binary_expressionContext) IsBinary_expressionContext() {}

func NewBinary_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Binary_expressionContext {
	var p = new(Binary_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_binary_expression

	return p
}

func (s *Binary_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Binary_expressionContext) Single_expression() ISingle_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_expressionContext)
}

func (s *Binary_expressionContext) Binary_operator() IBinary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinary_operatorContext)
}

func (s *Binary_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Binary_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Binary_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Binary_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterBinary_expression(s)
	}
}

func (s *Binary_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitBinary_expression(s)
	}
}

func (p *SysVerilogHDLParser) Binary_expression() (localctx IBinary_expressionContext) {
	localctx = NewBinary_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, SysVerilogHDLParserRULE_binary_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2786)
		p.Single_expression()
	}
	{
		p.SetState(2787)
		p.Binary_operator()
	}
	{
		p.SetState(2788)
		p.Expression()
	}

	return localctx
}

// ITernary_expressionContext is an interface to support dynamic dispatch.
type ITernary_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTernary_expressionContext differentiates from other interfaces.
	IsTernary_expressionContext()
}

type Ternary_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTernary_expressionContext() *Ternary_expressionContext {
	var p = new(Ternary_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_ternary_expression
	return p
}

func (*Ternary_expressionContext) IsTernary_expressionContext() {}

func NewTernary_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ternary_expressionContext {
	var p = new(Ternary_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_ternary_expression

	return p
}

func (s *Ternary_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Ternary_expressionContext) Single_expression() ISingle_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_expressionContext)
}

func (s *Ternary_expressionContext) Question_mark() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserQuestion_mark, 0)
}

func (s *Ternary_expressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Ternary_expressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Ternary_expressionContext) Colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserColon, 0)
}

func (s *Ternary_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ternary_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ternary_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTernary_expression(s)
	}
}

func (s *Ternary_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTernary_expression(s)
	}
}

func (p *SysVerilogHDLParser) Ternary_expression() (localctx ITernary_expressionContext) {
	localctx = NewTernary_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, SysVerilogHDLParserRULE_ternary_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2790)
		p.Single_expression()
	}
	{
		p.SetState(2791)
		p.Match(SysVerilogHDLParserQuestion_mark)
	}
	{
		p.SetState(2792)
		p.Expression()
	}
	{
		p.SetState(2793)
		p.Match(SysVerilogHDLParserColon)
	}
	{
		p.SetState(2794)
		p.Expression()
	}

	return localctx
}

// IMintypmax_expressionContext is an interface to support dynamic dispatch.
type IMintypmax_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMintypmax_expressionContext differentiates from other interfaces.
	IsMintypmax_expressionContext()
}

type Mintypmax_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMintypmax_expressionContext() *Mintypmax_expressionContext {
	var p = new(Mintypmax_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_mintypmax_expression
	return p
}

func (*Mintypmax_expressionContext) IsMintypmax_expressionContext() {}

func NewMintypmax_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mintypmax_expressionContext {
	var p = new(Mintypmax_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_mintypmax_expression

	return p
}

func (s *Mintypmax_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Mintypmax_expressionContext) Single_expression() ISingle_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_expressionContext)
}

func (s *Mintypmax_expressionContext) AllColon() []antlr.TerminalNode {
	return s.GetTokens(SysVerilogHDLParserColon)
}

func (s *Mintypmax_expressionContext) Colon(i int) antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserColon, i)
}

func (s *Mintypmax_expressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Mintypmax_expressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Mintypmax_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mintypmax_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mintypmax_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterMintypmax_expression(s)
	}
}

func (s *Mintypmax_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitMintypmax_expression(s)
	}
}

func (p *SysVerilogHDLParser) Mintypmax_expression() (localctx IMintypmax_expressionContext) {
	localctx = NewMintypmax_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, SysVerilogHDLParserRULE_mintypmax_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2796)
		p.Single_expression()
	}
	{
		p.SetState(2797)
		p.Match(SysVerilogHDLParserColon)
	}
	{
		p.SetState(2798)
		p.Expression()
	}
	{
		p.SetState(2799)
		p.Match(SysVerilogHDLParserColon)
	}
	{
		p.SetState(2800)
		p.Expression()
	}

	return localctx
}

// IStructured_valueContext is an interface to support dynamic dispatch.
type IStructured_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructured_valueContext differentiates from other interfaces.
	IsStructured_valueContext()
}

type Structured_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructured_valueContext() *Structured_valueContext {
	var p = new(Structured_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_structured_value
	return p
}

func (*Structured_valueContext) IsStructured_valueContext() {}

func NewStructured_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Structured_valueContext {
	var p = new(Structured_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_structured_value

	return p
}

func (s *Structured_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Structured_valueContext) Quote() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserQuote, 0)
}

func (s *Structured_valueContext) Left_curly_bracket() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserLeft_curly_bracket, 0)
}

func (s *Structured_valueContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Structured_valueContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Structured_valueContext) Right_curly_bracket() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRight_curly_bracket, 0)
}

func (s *Structured_valueContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SysVerilogHDLParserComma)
}

func (s *Structured_valueContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, i)
}

func (s *Structured_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Structured_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Structured_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterStructured_value(s)
	}
}

func (s *Structured_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitStructured_value(s)
	}
}

func (p *SysVerilogHDLParser) Structured_value() (localctx IStructured_valueContext) {
	localctx = NewStructured_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, SysVerilogHDLParserRULE_structured_value)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2821)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 217, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2802)
			p.Match(SysVerilogHDLParserQuote)
		}
		{
			p.SetState(2803)
			p.Match(SysVerilogHDLParserLeft_curly_bracket)
		}
		{
			p.SetState(2804)
			p.Expression()
		}
		p.SetState(2809)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SysVerilogHDLParserComma {
			{
				p.SetState(2805)
				p.Match(SysVerilogHDLParserComma)
			}
			{
				p.SetState(2806)
				p.Expression()
			}

			p.SetState(2811)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2812)
			p.Match(SysVerilogHDLParserRight_curly_bracket)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2814)
			p.Match(SysVerilogHDLParserQuote)
		}
		{
			p.SetState(2815)
			p.Match(SysVerilogHDLParserLeft_curly_bracket)
		}
		{
			p.SetState(2816)
			p.Expression()
		}
		{
			p.SetState(2817)
			p.Match(SysVerilogHDLParserRight_curly_bracket)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2819)
			p.Match(SysVerilogHDLParserLeft_curly_bracket)
		}
		{
			p.SetState(2820)
			p.Match(SysVerilogHDLParserRight_curly_bracket)
		}

	}

	return localctx
}

// IArrayed_structured_valueContext is an interface to support dynamic dispatch.
type IArrayed_structured_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayed_structured_valueContext differentiates from other interfaces.
	IsArrayed_structured_valueContext()
}

type Arrayed_structured_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayed_structured_valueContext() *Arrayed_structured_valueContext {
	var p = new(Arrayed_structured_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_arrayed_structured_value
	return p
}

func (*Arrayed_structured_valueContext) IsArrayed_structured_valueContext() {}

func NewArrayed_structured_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arrayed_structured_valueContext {
	var p = new(Arrayed_structured_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_arrayed_structured_value

	return p
}

func (s *Arrayed_structured_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Arrayed_structured_valueContext) Quote() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserQuote, 0)
}

func (s *Arrayed_structured_valueContext) Left_curly_bracket() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserLeft_curly_bracket, 0)
}

func (s *Arrayed_structured_valueContext) Arrayed_structure_item_plus() IArrayed_structure_item_plusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayed_structure_item_plusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayed_structure_item_plusContext)
}

func (s *Arrayed_structured_valueContext) Right_curly_bracket() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRight_curly_bracket, 0)
}

func (s *Arrayed_structured_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arrayed_structured_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Arrayed_structured_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterArrayed_structured_value(s)
	}
}

func (s *Arrayed_structured_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitArrayed_structured_value(s)
	}
}

func (p *SysVerilogHDLParser) Arrayed_structured_value() (localctx IArrayed_structured_valueContext) {
	localctx = NewArrayed_structured_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, SysVerilogHDLParserRULE_arrayed_structured_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2823)
		p.Match(SysVerilogHDLParserQuote)
	}
	{
		p.SetState(2824)
		p.Match(SysVerilogHDLParserLeft_curly_bracket)
	}
	{
		p.SetState(2825)
		p.Arrayed_structure_item_plus()
	}
	{
		p.SetState(2826)
		p.Match(SysVerilogHDLParserRight_curly_bracket)
	}

	return localctx
}

// IArrayed_structure_itemContext is an interface to support dynamic dispatch.
type IArrayed_structure_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayed_structure_itemContext differentiates from other interfaces.
	IsArrayed_structure_itemContext()
}

type Arrayed_structure_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayed_structure_itemContext() *Arrayed_structure_itemContext {
	var p = new(Arrayed_structure_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_arrayed_structure_item
	return p
}

func (*Arrayed_structure_itemContext) IsArrayed_structure_itemContext() {}

func NewArrayed_structure_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arrayed_structure_itemContext {
	var p = new(Arrayed_structure_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_arrayed_structure_item

	return p
}

func (s *Arrayed_structure_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Arrayed_structure_itemContext) Default() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDefault, 0)
}

func (s *Arrayed_structure_itemContext) Colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserColon, 0)
}

func (s *Arrayed_structure_itemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Arrayed_structure_itemContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Arrayed_structure_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arrayed_structure_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Arrayed_structure_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterArrayed_structure_item(s)
	}
}

func (s *Arrayed_structure_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitArrayed_structure_item(s)
	}
}

func (p *SysVerilogHDLParser) Arrayed_structure_item() (localctx IArrayed_structure_itemContext) {
	localctx = NewArrayed_structure_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, SysVerilogHDLParserRULE_arrayed_structure_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2835)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserDefault:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2828)
			p.Match(SysVerilogHDLParserDefault)
		}
		{
			p.SetState(2829)
			p.Match(SysVerilogHDLParserColon)
		}
		{
			p.SetState(2830)
			p.Expression()
		}

	case SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2831)
			p.Hierarchical_identifier()
		}
		{
			p.SetState(2832)
			p.Match(SysVerilogHDLParserColon)
		}
		{
			p.SetState(2833)
			p.Expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IComma_arrayed_structure_itemContext is an interface to support dynamic dispatch.
type IComma_arrayed_structure_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_arrayed_structure_itemContext differentiates from other interfaces.
	IsComma_arrayed_structure_itemContext()
}

type Comma_arrayed_structure_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_arrayed_structure_itemContext() *Comma_arrayed_structure_itemContext {
	var p = new(Comma_arrayed_structure_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_arrayed_structure_item
	return p
}

func (*Comma_arrayed_structure_itemContext) IsComma_arrayed_structure_itemContext() {}

func NewComma_arrayed_structure_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_arrayed_structure_itemContext {
	var p = new(Comma_arrayed_structure_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_arrayed_structure_item

	return p
}

func (s *Comma_arrayed_structure_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_arrayed_structure_itemContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_arrayed_structure_itemContext) Arrayed_structure_item() IArrayed_structure_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayed_structure_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayed_structure_itemContext)
}

func (s *Comma_arrayed_structure_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_arrayed_structure_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_arrayed_structure_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_arrayed_structure_item(s)
	}
}

func (s *Comma_arrayed_structure_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_arrayed_structure_item(s)
	}
}

func (p *SysVerilogHDLParser) Comma_arrayed_structure_item() (localctx IComma_arrayed_structure_itemContext) {
	localctx = NewComma_arrayed_structure_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, SysVerilogHDLParserRULE_comma_arrayed_structure_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2837)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(2838)
		p.Arrayed_structure_item()
	}

	return localctx
}

// IComma_arrayed_structure_item_starContext is an interface to support dynamic dispatch.
type IComma_arrayed_structure_item_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_arrayed_structure_item_starContext differentiates from other interfaces.
	IsComma_arrayed_structure_item_starContext()
}

type Comma_arrayed_structure_item_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_arrayed_structure_item_starContext() *Comma_arrayed_structure_item_starContext {
	var p = new(Comma_arrayed_structure_item_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_arrayed_structure_item_star
	return p
}

func (*Comma_arrayed_structure_item_starContext) IsComma_arrayed_structure_item_starContext() {}

func NewComma_arrayed_structure_item_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_arrayed_structure_item_starContext {
	var p = new(Comma_arrayed_structure_item_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_arrayed_structure_item_star

	return p
}

func (s *Comma_arrayed_structure_item_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_arrayed_structure_item_starContext) AllComma_arrayed_structure_item() []IComma_arrayed_structure_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_arrayed_structure_itemContext)(nil)).Elem())
	var tst = make([]IComma_arrayed_structure_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_arrayed_structure_itemContext)
		}
	}

	return tst
}

func (s *Comma_arrayed_structure_item_starContext) Comma_arrayed_structure_item(i int) IComma_arrayed_structure_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_arrayed_structure_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_arrayed_structure_itemContext)
}

func (s *Comma_arrayed_structure_item_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_arrayed_structure_item_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_arrayed_structure_item_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_arrayed_structure_item_star(s)
	}
}

func (s *Comma_arrayed_structure_item_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_arrayed_structure_item_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_arrayed_structure_item_star() (localctx IComma_arrayed_structure_item_starContext) {
	localctx = NewComma_arrayed_structure_item_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, SysVerilogHDLParserRULE_comma_arrayed_structure_item_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2843)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(2840)
			p.Comma_arrayed_structure_item()
		}

		p.SetState(2845)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArrayed_structure_item_plusContext is an interface to support dynamic dispatch.
type IArrayed_structure_item_plusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayed_structure_item_plusContext differentiates from other interfaces.
	IsArrayed_structure_item_plusContext()
}

type Arrayed_structure_item_plusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayed_structure_item_plusContext() *Arrayed_structure_item_plusContext {
	var p = new(Arrayed_structure_item_plusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_arrayed_structure_item_plus
	return p
}

func (*Arrayed_structure_item_plusContext) IsArrayed_structure_item_plusContext() {}

func NewArrayed_structure_item_plusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arrayed_structure_item_plusContext {
	var p = new(Arrayed_structure_item_plusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_arrayed_structure_item_plus

	return p
}

func (s *Arrayed_structure_item_plusContext) GetParser() antlr.Parser { return s.parser }

func (s *Arrayed_structure_item_plusContext) Arrayed_structure_item() IArrayed_structure_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayed_structure_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayed_structure_itemContext)
}

func (s *Arrayed_structure_item_plusContext) Comma_arrayed_structure_item_star() IComma_arrayed_structure_item_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_arrayed_structure_item_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_arrayed_structure_item_starContext)
}

func (s *Arrayed_structure_item_plusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arrayed_structure_item_plusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Arrayed_structure_item_plusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterArrayed_structure_item_plus(s)
	}
}

func (s *Arrayed_structure_item_plusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitArrayed_structure_item_plus(s)
	}
}

func (p *SysVerilogHDLParser) Arrayed_structure_item_plus() (localctx IArrayed_structure_item_plusContext) {
	localctx = NewArrayed_structure_item_plusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, SysVerilogHDLParserRULE_arrayed_structure_item_plus)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2846)
		p.Arrayed_structure_item()
	}
	{
		p.SetState(2847)
		p.Comma_arrayed_structure_item_star()
	}

	return localctx
}

// IVariable_type_castContext is an interface to support dynamic dispatch.
type IVariable_type_castContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_type_castContext differentiates from other interfaces.
	IsVariable_type_castContext()
}

type Variable_type_castContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_type_castContext() *Variable_type_castContext {
	var p = new(Variable_type_castContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_variable_type_cast
	return p
}

func (*Variable_type_castContext) IsVariable_type_castContext() {}

func NewVariable_type_castContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_type_castContext {
	var p = new(Variable_type_castContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_variable_type_cast

	return p
}

func (s *Variable_type_castContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_type_castContext) Variable_type() IVariable_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_typeContext)
}

func (s *Variable_type_castContext) Quote() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserQuote, 0)
}

func (s *Variable_type_castContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_type_castContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_type_castContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_type_castContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterVariable_type_cast(s)
	}
}

func (s *Variable_type_castContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitVariable_type_cast(s)
	}
}

func (p *SysVerilogHDLParser) Variable_type_cast() (localctx IVariable_type_castContext) {
	localctx = NewVariable_type_castContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 764, SysVerilogHDLParserRULE_variable_type_cast)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2849)
		p.Variable_type()
	}
	{
		p.SetState(2850)
		p.Match(SysVerilogHDLParserQuote)
	}
	{
		p.SetState(2851)
		p.Expression()
	}

	return localctx
}

// IWidth_type_castContext is an interface to support dynamic dispatch.
type IWidth_type_castContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWidth_type_castContext differentiates from other interfaces.
	IsWidth_type_castContext()
}

type Width_type_castContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWidth_type_castContext() *Width_type_castContext {
	var p = new(Width_type_castContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_width_type_cast
	return p
}

func (*Width_type_castContext) IsWidth_type_castContext() {}

func NewWidth_type_castContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Width_type_castContext {
	var p = new(Width_type_castContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_width_type_cast

	return p
}

func (s *Width_type_castContext) GetParser() antlr.Parser { return s.parser }

func (s *Width_type_castContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Width_type_castContext) Quote() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserQuote, 0)
}

func (s *Width_type_castContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Width_type_castContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Width_type_castContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Width_type_castContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterWidth_type_cast(s)
	}
}

func (s *Width_type_castContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitWidth_type_cast(s)
	}
}

func (p *SysVerilogHDLParser) Width_type_cast() (localctx IWidth_type_castContext) {
	localctx = NewWidth_type_castContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, SysVerilogHDLParserRULE_width_type_cast)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2853)
		p.Number()
	}
	{
		p.SetState(2854)
		p.Match(SysVerilogHDLParserQuote)
	}
	{
		p.SetState(2855)
		p.Expression()
	}

	return localctx
}

// ISign_type_castContext is an interface to support dynamic dispatch.
type ISign_type_castContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSign_type_castContext differentiates from other interfaces.
	IsSign_type_castContext()
}

type Sign_type_castContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySign_type_castContext() *Sign_type_castContext {
	var p = new(Sign_type_castContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_sign_type_cast
	return p
}

func (*Sign_type_castContext) IsSign_type_castContext() {}

func NewSign_type_castContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sign_type_castContext {
	var p = new(Sign_type_castContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_sign_type_cast

	return p
}

func (s *Sign_type_castContext) GetParser() antlr.Parser { return s.parser }

func (s *Sign_type_castContext) Quote() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserQuote, 0)
}

func (s *Sign_type_castContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Sign_type_castContext) Signed() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSigned, 0)
}

func (s *Sign_type_castContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserUnsigned, 0)
}

func (s *Sign_type_castContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sign_type_castContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sign_type_castContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterSign_type_cast(s)
	}
}

func (s *Sign_type_castContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitSign_type_cast(s)
	}
}

func (p *SysVerilogHDLParser) Sign_type_cast() (localctx ISign_type_castContext) {
	localctx = NewSign_type_castContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, SysVerilogHDLParserRULE_sign_type_cast)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2857)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2858)
		p.Match(SysVerilogHDLParserQuote)
	}
	{
		p.SetState(2859)
		p.Expression()
	}

	return localctx
}

// INull_type_castContext is an interface to support dynamic dispatch.
type INull_type_castContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNull_type_castContext differentiates from other interfaces.
	IsNull_type_castContext()
}

type Null_type_castContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_type_castContext() *Null_type_castContext {
	var p = new(Null_type_castContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_null_type_cast
	return p
}

func (*Null_type_castContext) IsNull_type_castContext() {}

func NewNull_type_castContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_type_castContext {
	var p = new(Null_type_castContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_null_type_cast

	return p
}

func (s *Null_type_castContext) GetParser() antlr.Parser { return s.parser }

func (s *Null_type_castContext) Quote() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserQuote, 0)
}

func (s *Null_type_castContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Null_type_castContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_type_castContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Null_type_castContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterNull_type_cast(s)
	}
}

func (s *Null_type_castContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitNull_type_cast(s)
	}
}

func (p *SysVerilogHDLParser) Null_type_cast() (localctx INull_type_castContext) {
	localctx = NewNull_type_castContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, SysVerilogHDLParserRULE_null_type_cast)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2861)
		p.Match(SysVerilogHDLParserQuote)
	}
	{
		p.SetState(2862)
		p.Expression()
	}

	return localctx
}

// IVariable_typeContext is an interface to support dynamic dispatch.
type IVariable_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_typeContext differentiates from other interfaces.
	IsVariable_typeContext()
}

type Variable_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_typeContext() *Variable_typeContext {
	var p = new(Variable_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_variable_type
	return p
}

func (*Variable_typeContext) IsVariable_typeContext() {}

func NewVariable_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_typeContext {
	var p = new(Variable_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_variable_type

	return p
}

func (s *Variable_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_typeContext) Int() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserInt, 0)
}

func (s *Variable_typeContext) User_type() IUser_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUser_typeContext)
}

func (s *Variable_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterVariable_type(s)
	}
}

func (s *Variable_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitVariable_type(s)
	}
}

func (p *SysVerilogHDLParser) Variable_type() (localctx IVariable_typeContext) {
	localctx = NewVariable_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, SysVerilogHDLParserRULE_variable_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2866)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserInt:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2864)
			p.Match(SysVerilogHDLParserInt)
		}

	case SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2865)
			p.User_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IType_cast_identifierContext is an interface to support dynamic dispatch.
type IType_cast_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_cast_identifierContext differentiates from other interfaces.
	IsType_cast_identifierContext()
}

type Type_cast_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_cast_identifierContext() *Type_cast_identifierContext {
	var p = new(Type_cast_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_type_cast_identifier
	return p
}

func (*Type_cast_identifierContext) IsType_cast_identifierContext() {}

func NewType_cast_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_cast_identifierContext {
	var p = new(Type_cast_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_type_cast_identifier

	return p
}

func (s *Type_cast_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_cast_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Type_cast_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_cast_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_cast_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterType_cast_identifier(s)
	}
}

func (s *Type_cast_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitType_cast_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Type_cast_identifier() (localctx IType_cast_identifierContext) {
	localctx = NewType_cast_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, SysVerilogHDLParserRULE_type_cast_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2868)
		p.Identifier()
	}

	return localctx
}

// IType_cast_expressionContext is an interface to support dynamic dispatch.
type IType_cast_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_cast_expressionContext differentiates from other interfaces.
	IsType_cast_expressionContext()
}

type Type_cast_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_cast_expressionContext() *Type_cast_expressionContext {
	var p = new(Type_cast_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_type_cast_expression
	return p
}

func (*Type_cast_expressionContext) IsType_cast_expressionContext() {}

func NewType_cast_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_cast_expressionContext {
	var p = new(Type_cast_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_type_cast_expression

	return p
}

func (s *Type_cast_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_cast_expressionContext) Variable_type_cast() IVariable_type_castContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_type_castContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_type_castContext)
}

func (s *Type_cast_expressionContext) Width_type_cast() IWidth_type_castContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWidth_type_castContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWidth_type_castContext)
}

func (s *Type_cast_expressionContext) Sign_type_cast() ISign_type_castContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISign_type_castContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISign_type_castContext)
}

func (s *Type_cast_expressionContext) Null_type_cast() INull_type_castContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INull_type_castContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INull_type_castContext)
}

func (s *Type_cast_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_cast_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_cast_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterType_cast_expression(s)
	}
}

func (s *Type_cast_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitType_cast_expression(s)
	}
}

func (p *SysVerilogHDLParser) Type_cast_expression() (localctx IType_cast_expressionContext) {
	localctx = NewType_cast_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, SysVerilogHDLParserRULE_type_cast_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2874)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserInt, SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2870)
			p.Variable_type_cast()
		}

	case SysVerilogHDLParserBinary_number, SysVerilogHDLParserDecimal_number, SysVerilogHDLParserFixed_point_number, SysVerilogHDLParserHex_number, SysVerilogHDLParserOctal_number, SysVerilogHDLParserReal_exp_form:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2871)
			p.Width_type_cast()
		}

	case SysVerilogHDLParserSigned, SysVerilogHDLParserUnsigned:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2872)
			p.Sign_type_cast()
		}

	case SysVerilogHDLParserQuote:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2873)
			p.Null_type_cast()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunction_callContext is an interface to support dynamic dispatch.
type IFunction_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_callContext differentiates from other interfaces.
	IsFunction_callContext()
}

type Function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_callContext() *Function_callContext {
	var p = new(Function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_function_call
	return p
}

func (*Function_callContext) IsFunction_callContext() {}

func NewFunction_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_callContext {
	var p = new(Function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_function_call

	return p
}

func (s *Function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_callContext) Hierarchical_function_identifier() IHierarchical_function_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_function_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_function_identifierContext)
}

func (s *Function_callContext) Attribute_instance_star() IAttribute_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instance_starContext)
}

func (s *Function_callContext) Function_interface_assignments() IFunction_interface_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_interface_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_interface_assignmentsContext)
}

func (s *Function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterFunction_call(s)
	}
}

func (s *Function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitFunction_call(s)
	}
}

func (p *SysVerilogHDLParser) Function_call() (localctx IFunction_callContext) {
	localctx = NewFunction_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, SysVerilogHDLParserRULE_function_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2876)
		p.Hierarchical_function_identifier()
	}
	{
		p.SetState(2877)
		p.Attribute_instance_star()
	}
	{
		p.SetState(2878)
		p.Function_interface_assignments()
	}

	return localctx
}

// IHierarchical_function_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_function_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_function_identifierContext differentiates from other interfaces.
	IsHierarchical_function_identifierContext()
}

type Hierarchical_function_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_function_identifierContext() *Hierarchical_function_identifierContext {
	var p = new(Hierarchical_function_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_function_identifier
	return p
}

func (*Hierarchical_function_identifierContext) IsHierarchical_function_identifierContext() {}

func NewHierarchical_function_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_function_identifierContext {
	var p = new(Hierarchical_function_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_function_identifier

	return p
}

func (s *Hierarchical_function_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_function_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_function_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_function_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_function_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterHierarchical_function_identifier(s)
	}
}

func (s *Hierarchical_function_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitHierarchical_function_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Hierarchical_function_identifier() (localctx IHierarchical_function_identifierContext) {
	localctx = NewHierarchical_function_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, SysVerilogHDLParserRULE_hierarchical_function_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2880)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IFunction_interface_assignmentsContext is an interface to support dynamic dispatch.
type IFunction_interface_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_interface_assignmentsContext differentiates from other interfaces.
	IsFunction_interface_assignmentsContext()
}

type Function_interface_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_interface_assignmentsContext() *Function_interface_assignmentsContext {
	var p = new(Function_interface_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_function_interface_assignments
	return p
}

func (*Function_interface_assignmentsContext) IsFunction_interface_assignmentsContext() {}

func NewFunction_interface_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_interface_assignmentsContext {
	var p = new(Function_interface_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_function_interface_assignments

	return p
}

func (s *Function_interface_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_interface_assignmentsContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Function_interface_assignmentsContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Function_interface_assignmentsContext) List_of_interface_assignments() IList_of_interface_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_interface_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_interface_assignmentsContext)
}

func (s *Function_interface_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_interface_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_interface_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterFunction_interface_assignments(s)
	}
}

func (s *Function_interface_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitFunction_interface_assignments(s)
	}
}

func (p *SysVerilogHDLParser) Function_interface_assignments() (localctx IFunction_interface_assignmentsContext) {
	localctx = NewFunction_interface_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, SysVerilogHDLParserRULE_function_interface_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2882)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	p.SetState(2884)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SysVerilogHDLParserT__1)|(1<<SysVerilogHDLParserT__2)|(1<<SysVerilogHDLParserT__3)|(1<<SysVerilogHDLParserT__4)|(1<<SysVerilogHDLParserT__5)|(1<<SysVerilogHDLParserT__6)|(1<<SysVerilogHDLParserT__7)|(1<<SysVerilogHDLParserT__8)|(1<<SysVerilogHDLParserT__9)|(1<<SysVerilogHDLParserT__10)|(1<<SysVerilogHDLParserT__26)|(1<<SysVerilogHDLParserT__27))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(SysVerilogHDLParserBinary_number-42))|(1<<(SysVerilogHDLParserDecimal_number-42))|(1<<(SysVerilogHDLParserFixed_point_number-42))|(1<<(SysVerilogHDLParserHex_number-42))|(1<<(SysVerilogHDLParserOctal_number-42))|(1<<(SysVerilogHDLParserReal_exp_form-42)))) != 0) || _la == SysVerilogHDLParserInt || _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned || (((_la-201)&-(0x1f+1)) == 0 && ((1<<uint((_la-201)))&((1<<(SysVerilogHDLParserDollar_Identifier-201))|(1<<(SysVerilogHDLParserEscaped_identifier-201))|(1<<(SysVerilogHDLParserSimple_identifier-201))|(1<<(SysVerilogHDLParserString_literal-201))|(1<<(SysVerilogHDLParserDot-201))|(1<<(SysVerilogHDLParserLeft_curly_bracket-201))|(1<<(SysVerilogHDLParserOpen_parenthesis-201))|(1<<(SysVerilogHDLParserQuote-201))|(1<<(SysVerilogHDLParserTilde-201)))) != 0) {
		{
			p.SetState(2883)
			p.List_of_interface_assignments()
		}

	}
	{
		p.SetState(2886)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// ISystem_function_callContext is an interface to support dynamic dispatch.
type ISystem_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_function_callContext differentiates from other interfaces.
	IsSystem_function_callContext()
}

type System_function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_function_callContext() *System_function_callContext {
	var p = new(System_function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_system_function_call
	return p
}

func (*System_function_callContext) IsSystem_function_callContext() {}

func NewSystem_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_function_callContext {
	var p = new(System_function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_system_function_call

	return p
}

func (s *System_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *System_function_callContext) System_function_identifier() ISystem_function_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_function_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_function_identifierContext)
}

func (s *System_function_callContext) Function_interface_assignments() IFunction_interface_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_interface_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_interface_assignmentsContext)
}

func (s *System_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterSystem_function_call(s)
	}
}

func (s *System_function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitSystem_function_call(s)
	}
}

func (p *SysVerilogHDLParser) System_function_call() (localctx ISystem_function_callContext) {
	localctx = NewSystem_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, SysVerilogHDLParserRULE_system_function_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2888)
		p.System_function_identifier()
	}
	p.SetState(2890)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 223, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2889)
			p.Function_interface_assignments()
		}

	}

	return localctx
}

// ISystem_function_identifierContext is an interface to support dynamic dispatch.
type ISystem_function_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_function_identifierContext differentiates from other interfaces.
	IsSystem_function_identifierContext()
}

type System_function_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_function_identifierContext() *System_function_identifierContext {
	var p = new(System_function_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_system_function_identifier
	return p
}

func (*System_function_identifierContext) IsSystem_function_identifierContext() {}

func NewSystem_function_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_function_identifierContext {
	var p = new(System_function_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_system_function_identifier

	return p
}

func (s *System_function_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *System_function_identifierContext) Dollar_Identifier() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDollar_Identifier, 0)
}

func (s *System_function_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_function_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_function_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterSystem_function_identifier(s)
	}
}

func (s *System_function_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitSystem_function_identifier(s)
	}
}

func (p *SysVerilogHDLParser) System_function_identifier() (localctx ISystem_function_identifierContext) {
	localctx = NewSystem_function_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 786, SysVerilogHDLParserRULE_system_function_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2892)
		p.Match(SysVerilogHDLParserDollar_Identifier)
	}

	return localctx
}

// IConstant_function_callContext is an interface to support dynamic dispatch.
type IConstant_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_function_callContext differentiates from other interfaces.
	IsConstant_function_callContext()
}

type Constant_function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_function_callContext() *Constant_function_callContext {
	var p = new(Constant_function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_constant_function_call
	return p
}

func (*Constant_function_callContext) IsConstant_function_callContext() {}

func NewConstant_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_function_callContext {
	var p = new(Constant_function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_constant_function_call

	return p
}

func (s *Constant_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_function_callContext) Function_call() IFunction_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_callContext)
}

func (s *Constant_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterConstant_function_call(s)
	}
}

func (s *Constant_function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitConstant_function_call(s)
	}
}

func (p *SysVerilogHDLParser) Constant_function_call() (localctx IConstant_function_callContext) {
	localctx = NewConstant_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, SysVerilogHDLParserRULE_constant_function_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2894)
		p.Function_call()
	}

	return localctx
}

// IImported_function_callContext is an interface to support dynamic dispatch.
type IImported_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImported_function_callContext differentiates from other interfaces.
	IsImported_function_callContext()
}

type Imported_function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImported_function_callContext() *Imported_function_callContext {
	var p = new(Imported_function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_imported_function_call
	return p
}

func (*Imported_function_callContext) IsImported_function_callContext() {}

func NewImported_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imported_function_callContext {
	var p = new(Imported_function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_imported_function_call

	return p
}

func (s *Imported_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Imported_function_callContext) Imported_function_hierarchical_identifier() IImported_function_hierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImported_function_hierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImported_function_hierarchical_identifierContext)
}

func (s *Imported_function_callContext) Attribute_instance_star() IAttribute_instance_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instance_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instance_starContext)
}

func (s *Imported_function_callContext) Function_interface_assignments() IFunction_interface_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_interface_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_interface_assignmentsContext)
}

func (s *Imported_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imported_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imported_function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterImported_function_call(s)
	}
}

func (s *Imported_function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitImported_function_call(s)
	}
}

func (p *SysVerilogHDLParser) Imported_function_call() (localctx IImported_function_callContext) {
	localctx = NewImported_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, SysVerilogHDLParserRULE_imported_function_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2896)
		p.Imported_function_hierarchical_identifier()
	}
	{
		p.SetState(2897)
		p.Attribute_instance_star()
	}
	{
		p.SetState(2898)
		p.Function_interface_assignments()
	}

	return localctx
}

// IImported_function_hierarchical_identifierContext is an interface to support dynamic dispatch.
type IImported_function_hierarchical_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImported_function_hierarchical_identifierContext differentiates from other interfaces.
	IsImported_function_hierarchical_identifierContext()
}

type Imported_function_hierarchical_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImported_function_hierarchical_identifierContext() *Imported_function_hierarchical_identifierContext {
	var p = new(Imported_function_hierarchical_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_imported_function_hierarchical_identifier
	return p
}

func (*Imported_function_hierarchical_identifierContext) IsImported_function_hierarchical_identifierContext() {
}

func NewImported_function_hierarchical_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imported_function_hierarchical_identifierContext {
	var p = new(Imported_function_hierarchical_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_imported_function_hierarchical_identifier

	return p
}

func (s *Imported_function_hierarchical_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Imported_function_hierarchical_identifierContext) Imported_hierarchical_identifier() IImported_hierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImported_hierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImported_hierarchical_identifierContext)
}

func (s *Imported_function_hierarchical_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imported_function_hierarchical_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imported_function_hierarchical_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterImported_function_hierarchical_identifier(s)
	}
}

func (s *Imported_function_hierarchical_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitImported_function_hierarchical_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Imported_function_hierarchical_identifier() (localctx IImported_function_hierarchical_identifierContext) {
	localctx = NewImported_function_hierarchical_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, SysVerilogHDLParserRULE_imported_function_hierarchical_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2900)
		p.Imported_hierarchical_identifier()
	}

	return localctx
}

// IPrimary_hierarchical_identifierContext is an interface to support dynamic dispatch.
type IPrimary_hierarchical_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_hierarchical_identifierContext differentiates from other interfaces.
	IsPrimary_hierarchical_identifierContext()
}

type Primary_hierarchical_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_hierarchical_identifierContext() *Primary_hierarchical_identifierContext {
	var p = new(Primary_hierarchical_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_primary_hierarchical_identifier
	return p
}

func (*Primary_hierarchical_identifierContext) IsPrimary_hierarchical_identifierContext() {}

func NewPrimary_hierarchical_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_hierarchical_identifierContext {
	var p = new(Primary_hierarchical_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_primary_hierarchical_identifier

	return p
}

func (s *Primary_hierarchical_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_hierarchical_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Primary_hierarchical_identifierContext) Dimension_plus() IDimension_plusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimension_plusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimension_plusContext)
}

func (s *Primary_hierarchical_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_hierarchical_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Primary_hierarchical_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPrimary_hierarchical_identifier(s)
	}
}

func (s *Primary_hierarchical_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPrimary_hierarchical_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Primary_hierarchical_identifier() (localctx IPrimary_hierarchical_identifierContext) {
	localctx = NewPrimary_hierarchical_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, SysVerilogHDLParserRULE_primary_hierarchical_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2902)
		p.Hierarchical_identifier()
	}
	p.SetState(2904)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 224, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2903)
			p.Dimension_plus()
		}

	}

	return localctx
}

// IPrimary_imported_hierarchical_identifierContext is an interface to support dynamic dispatch.
type IPrimary_imported_hierarchical_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_imported_hierarchical_identifierContext differentiates from other interfaces.
	IsPrimary_imported_hierarchical_identifierContext()
}

type Primary_imported_hierarchical_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_imported_hierarchical_identifierContext() *Primary_imported_hierarchical_identifierContext {
	var p = new(Primary_imported_hierarchical_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_primary_imported_hierarchical_identifier
	return p
}

func (*Primary_imported_hierarchical_identifierContext) IsPrimary_imported_hierarchical_identifierContext() {
}

func NewPrimary_imported_hierarchical_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_imported_hierarchical_identifierContext {
	var p = new(Primary_imported_hierarchical_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_primary_imported_hierarchical_identifier

	return p
}

func (s *Primary_imported_hierarchical_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_imported_hierarchical_identifierContext) Imported_hierarchical_identifier() IImported_hierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImported_hierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImported_hierarchical_identifierContext)
}

func (s *Primary_imported_hierarchical_identifierContext) Dimension_plus() IDimension_plusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimension_plusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimension_plusContext)
}

func (s *Primary_imported_hierarchical_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_imported_hierarchical_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Primary_imported_hierarchical_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPrimary_imported_hierarchical_identifier(s)
	}
}

func (s *Primary_imported_hierarchical_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPrimary_imported_hierarchical_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Primary_imported_hierarchical_identifier() (localctx IPrimary_imported_hierarchical_identifierContext) {
	localctx = NewPrimary_imported_hierarchical_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, SysVerilogHDLParserRULE_primary_imported_hierarchical_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2906)
		p.Imported_hierarchical_identifier()
	}
	p.SetState(2908)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 225, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2907)
			p.Dimension_plus()
		}

	}

	return localctx
}

// IImported_hierarchical_identifierContext is an interface to support dynamic dispatch.
type IImported_hierarchical_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImported_hierarchical_identifierContext differentiates from other interfaces.
	IsImported_hierarchical_identifierContext()
}

type Imported_hierarchical_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImported_hierarchical_identifierContext() *Imported_hierarchical_identifierContext {
	var p = new(Imported_hierarchical_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_imported_hierarchical_identifier
	return p
}

func (*Imported_hierarchical_identifierContext) IsImported_hierarchical_identifierContext() {}

func NewImported_hierarchical_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imported_hierarchical_identifierContext {
	var p = new(Imported_hierarchical_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_imported_hierarchical_identifier

	return p
}

func (s *Imported_hierarchical_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Imported_hierarchical_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Imported_hierarchical_identifierContext) Double_colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDouble_colon, 0)
}

func (s *Imported_hierarchical_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Imported_hierarchical_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imported_hierarchical_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imported_hierarchical_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterImported_hierarchical_identifier(s)
	}
}

func (s *Imported_hierarchical_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitImported_hierarchical_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Imported_hierarchical_identifier() (localctx IImported_hierarchical_identifierContext) {
	localctx = NewImported_hierarchical_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, SysVerilogHDLParserRULE_imported_hierarchical_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2910)
		p.Identifier()
	}
	{
		p.SetState(2911)
		p.Match(SysVerilogHDLParserDouble_colon)
	}
	{
		p.SetState(2912)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IParenthesis_expressionContext is an interface to support dynamic dispatch.
type IParenthesis_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesis_expressionContext differentiates from other interfaces.
	IsParenthesis_expressionContext()
}

type Parenthesis_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesis_expressionContext() *Parenthesis_expressionContext {
	var p = new(Parenthesis_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_parenthesis_expression
	return p
}

func (*Parenthesis_expressionContext) IsParenthesis_expressionContext() {}

func NewParenthesis_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parenthesis_expressionContext {
	var p = new(Parenthesis_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_parenthesis_expression

	return p
}

func (s *Parenthesis_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Parenthesis_expressionContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Parenthesis_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Parenthesis_expressionContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Parenthesis_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthesis_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parenthesis_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterParenthesis_expression(s)
	}
}

func (s *Parenthesis_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitParenthesis_expression(s)
	}
}

func (p *SysVerilogHDLParser) Parenthesis_expression() (localctx IParenthesis_expressionContext) {
	localctx = NewParenthesis_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, SysVerilogHDLParserRULE_parenthesis_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2914)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(2915)
		p.Expression()
	}
	{
		p.SetState(2916)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// IConcatenationContext is an interface to support dynamic dispatch.
type IConcatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConcatenationContext differentiates from other interfaces.
	IsConcatenationContext()
}

type ConcatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConcatenationContext() *ConcatenationContext {
	var p = new(ConcatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_concatenation
	return p
}

func (*ConcatenationContext) IsConcatenationContext() {}

func NewConcatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConcatenationContext {
	var p = new(ConcatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_concatenation

	return p
}

func (s *ConcatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConcatenationContext) Left_curly_bracket() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserLeft_curly_bracket, 0)
}

func (s *ConcatenationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConcatenationContext) Comma_expression_star() IComma_expression_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_expression_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_expression_starContext)
}

func (s *ConcatenationContext) Right_curly_bracket() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRight_curly_bracket, 0)
}

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

func (p *SysVerilogHDLParser) Concatenation() (localctx IConcatenationContext) {
	localctx = NewConcatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, SysVerilogHDLParserRULE_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2918)
		p.Match(SysVerilogHDLParserLeft_curly_bracket)
	}
	{
		p.SetState(2919)
		p.Expression()
	}
	{
		p.SetState(2920)
		p.Comma_expression_star()
	}
	{
		p.SetState(2921)
		p.Match(SysVerilogHDLParserRight_curly_bracket)
	}

	return localctx
}

// IMultiple_concatenationContext is an interface to support dynamic dispatch.
type IMultiple_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiple_concatenationContext differentiates from other interfaces.
	IsMultiple_concatenationContext()
}

type Multiple_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiple_concatenationContext() *Multiple_concatenationContext {
	var p = new(Multiple_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_multiple_concatenation
	return p
}

func (*Multiple_concatenationContext) IsMultiple_concatenationContext() {}

func NewMultiple_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multiple_concatenationContext {
	var p = new(Multiple_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_multiple_concatenation

	return p
}

func (s *Multiple_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Multiple_concatenationContext) Left_curly_bracket() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserLeft_curly_bracket, 0)
}

func (s *Multiple_concatenationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Multiple_concatenationContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Multiple_concatenationContext) Right_curly_bracket() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserRight_curly_bracket, 0)
}

func (s *Multiple_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multiple_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multiple_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterMultiple_concatenation(s)
	}
}

func (s *Multiple_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitMultiple_concatenation(s)
	}
}

func (p *SysVerilogHDLParser) Multiple_concatenation() (localctx IMultiple_concatenationContext) {
	localctx = NewMultiple_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, SysVerilogHDLParserRULE_multiple_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2923)
		p.Match(SysVerilogHDLParserLeft_curly_bracket)
	}
	{
		p.SetState(2924)
		p.Expression()
	}
	{
		p.SetState(2925)
		p.Concatenation()
	}
	{
		p.SetState(2926)
		p.Match(SysVerilogHDLParserRight_curly_bracket)
	}

	return localctx
}

// IComma_expression_plusContext is an interface to support dynamic dispatch.
type IComma_expression_plusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_expression_plusContext differentiates from other interfaces.
	IsComma_expression_plusContext()
}

type Comma_expression_plusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_expression_plusContext() *Comma_expression_plusContext {
	var p = new(Comma_expression_plusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_expression_plus
	return p
}

func (*Comma_expression_plusContext) IsComma_expression_plusContext() {}

func NewComma_expression_plusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_expression_plusContext {
	var p = new(Comma_expression_plusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_expression_plus

	return p
}

func (s *Comma_expression_plusContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_expression_plusContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SysVerilogHDLParserComma)
}

func (s *Comma_expression_plusContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, i)
}

func (s *Comma_expression_plusContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Comma_expression_plusContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Comma_expression_plusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_expression_plusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_expression_plusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_expression_plus(s)
	}
}

func (s *Comma_expression_plusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_expression_plus(s)
	}
}

func (p *SysVerilogHDLParser) Comma_expression_plus() (localctx IComma_expression_plusContext) {
	localctx = NewComma_expression_plusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, SysVerilogHDLParserRULE_comma_expression_plus)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2930)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SysVerilogHDLParserComma {
		{
			p.SetState(2928)
			p.Match(SysVerilogHDLParserComma)
		}
		{
			p.SetState(2929)
			p.Expression()
		}

		p.SetState(2932)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_expression_starContext is an interface to support dynamic dispatch.
type IComma_expression_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_expression_starContext differentiates from other interfaces.
	IsComma_expression_starContext()
}

type Comma_expression_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_expression_starContext() *Comma_expression_starContext {
	var p = new(Comma_expression_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_expression_star
	return p
}

func (*Comma_expression_starContext) IsComma_expression_starContext() {}

func NewComma_expression_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_expression_starContext {
	var p = new(Comma_expression_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_expression_star

	return p
}

func (s *Comma_expression_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_expression_starContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SysVerilogHDLParserComma)
}

func (s *Comma_expression_starContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, i)
}

func (s *Comma_expression_starContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Comma_expression_starContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Comma_expression_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_expression_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_expression_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_expression_star(s)
	}
}

func (s *Comma_expression_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_expression_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_expression_star() (localctx IComma_expression_starContext) {
	localctx = NewComma_expression_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, SysVerilogHDLParserRULE_comma_expression_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2938)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(2934)
			p.Match(SysVerilogHDLParserComma)
		}
		{
			p.SetState(2935)
			p.Expression()
		}

		p.SetState(2940)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypedef_declarationContext is an interface to support dynamic dispatch.
type ITypedef_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedef_declarationContext differentiates from other interfaces.
	IsTypedef_declarationContext()
}

type Typedef_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedef_declarationContext() *Typedef_declarationContext {
	var p = new(Typedef_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_typedef_declaration
	return p
}

func (*Typedef_declarationContext) IsTypedef_declarationContext() {}

func NewTypedef_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Typedef_declarationContext {
	var p = new(Typedef_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_typedef_declaration

	return p
}

func (s *Typedef_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Typedef_declarationContext) Typedef() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTypedef, 0)
}

func (s *Typedef_declarationContext) Typedef_definition() ITypedef_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedef_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedef_definitionContext)
}

func (s *Typedef_declarationContext) Typedef_identifier() ITypedef_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedef_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedef_identifierContext)
}

func (s *Typedef_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Typedef_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Typedef_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTypedef_declaration(s)
	}
}

func (s *Typedef_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTypedef_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Typedef_declaration() (localctx ITypedef_declarationContext) {
	localctx = NewTypedef_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 810, SysVerilogHDLParserRULE_typedef_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2941)
		p.Match(SysVerilogHDLParserTypedef)
	}
	{
		p.SetState(2942)
		p.Typedef_definition()
	}
	{
		p.SetState(2943)
		p.Typedef_identifier()
	}

	return localctx
}

// ITypedef_identifierContext is an interface to support dynamic dispatch.
type ITypedef_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedef_identifierContext differentiates from other interfaces.
	IsTypedef_identifierContext()
}

type Typedef_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedef_identifierContext() *Typedef_identifierContext {
	var p = new(Typedef_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_typedef_identifier
	return p
}

func (*Typedef_identifierContext) IsTypedef_identifierContext() {}

func NewTypedef_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Typedef_identifierContext {
	var p = new(Typedef_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_typedef_identifier

	return p
}

func (s *Typedef_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Typedef_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Typedef_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Typedef_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Typedef_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTypedef_identifier(s)
	}
}

func (s *Typedef_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTypedef_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Typedef_identifier() (localctx ITypedef_identifierContext) {
	localctx = NewTypedef_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 812, SysVerilogHDLParserRULE_typedef_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2945)
		p.Identifier()
	}

	return localctx
}

// ITypedef_definitionContext is an interface to support dynamic dispatch.
type ITypedef_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedef_definitionContext differentiates from other interfaces.
	IsTypedef_definitionContext()
}

type Typedef_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedef_definitionContext() *Typedef_definitionContext {
	var p = new(Typedef_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_typedef_definition
	return p
}

func (*Typedef_definitionContext) IsTypedef_definitionContext() {}

func NewTypedef_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Typedef_definitionContext {
	var p = new(Typedef_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_typedef_definition

	return p
}

func (s *Typedef_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Typedef_definitionContext) Typedef_definition_type() ITypedef_definition_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedef_definition_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedef_definition_typeContext)
}

func (s *Typedef_definitionContext) Enumerated_type() IEnumerated_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerated_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerated_typeContext)
}

func (s *Typedef_definitionContext) Struct_type() IStruct_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_typeContext)
}

func (s *Typedef_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Typedef_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Typedef_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTypedef_definition(s)
	}
}

func (s *Typedef_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTypedef_definition(s)
	}
}

func (p *SysVerilogHDLParser) Typedef_definition() (localctx ITypedef_definitionContext) {
	localctx = NewTypedef_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 814, SysVerilogHDLParserRULE_typedef_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2950)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserBit, SysVerilogHDLParserByte, SysVerilogHDLParserLogic, SysVerilogHDLParserNONE, SysVerilogHDLParserReg, SysVerilogHDLParserSupply0, SysVerilogHDLParserSupply1, SysVerilogHDLParserTri, SysVerilogHDLParserTri_and, SysVerilogHDLParserTri_or, SysVerilogHDLParserTri_reg, SysVerilogHDLParserTri0, SysVerilogHDLParserTri1, SysVerilogHDLParserUwire, SysVerilogHDLParserWand, SysVerilogHDLParserWire, SysVerilogHDLParserWor, SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2947)
			p.Typedef_definition_type()
		}

	case SysVerilogHDLParserEnum:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2948)
			p.Enumerated_type()
		}

	case SysVerilogHDLParserStruct, SysVerilogHDLParserUnionStruct:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2949)
			p.Struct_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypedef_definition_typeContext is an interface to support dynamic dispatch.
type ITypedef_definition_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedef_definition_typeContext differentiates from other interfaces.
	IsTypedef_definition_typeContext()
}

type Typedef_definition_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedef_definition_typeContext() *Typedef_definition_typeContext {
	var p = new(Typedef_definition_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_typedef_definition_type
	return p
}

func (*Typedef_definition_typeContext) IsTypedef_definition_typeContext() {}

func NewTypedef_definition_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Typedef_definition_typeContext {
	var p = new(Typedef_definition_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_typedef_definition_type

	return p
}

func (s *Typedef_definition_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Typedef_definition_typeContext) Complex_type() IComplex_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComplex_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComplex_typeContext)
}

func (s *Typedef_definition_typeContext) Typedef_type() ITypedef_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedef_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedef_typeContext)
}

func (s *Typedef_definition_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Typedef_definition_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Typedef_definition_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTypedef_definition_type(s)
	}
}

func (s *Typedef_definition_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTypedef_definition_type(s)
	}
}

func (p *SysVerilogHDLParser) Typedef_definition_type() (localctx ITypedef_definition_typeContext) {
	localctx = NewTypedef_definition_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 816, SysVerilogHDLParserRULE_typedef_definition_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2954)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 229, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2952)
			p.Complex_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2953)
			p.Typedef_type()
		}

	}

	return localctx
}

// IComplex_typeContext is an interface to support dynamic dispatch.
type IComplex_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComplex_typeContext differentiates from other interfaces.
	IsComplex_typeContext()
}

type Complex_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplex_typeContext() *Complex_typeContext {
	var p = new(Complex_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_complex_type
	return p
}

func (*Complex_typeContext) IsComplex_typeContext() {}

func NewComplex_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Complex_typeContext {
	var p = new(Complex_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_complex_type

	return p
}

func (s *Complex_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Complex_typeContext) Typedef_type() ITypedef_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedef_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedef_typeContext)
}

func (s *Complex_typeContext) Dimension_plus() IDimension_plusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimension_plusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimension_plusContext)
}

func (s *Complex_typeContext) Signed() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSigned, 0)
}

func (s *Complex_typeContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserUnsigned, 0)
}

func (s *Complex_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Complex_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Complex_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComplex_type(s)
	}
}

func (s *Complex_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComplex_type(s)
	}
}

func (p *SysVerilogHDLParser) Complex_type() (localctx IComplex_typeContext) {
	localctx = NewComplex_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 818, SysVerilogHDLParserRULE_complex_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2956)
		p.Typedef_type()
	}
	p.SetState(2958)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned {
		{
			p.SetState(2957)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SysVerilogHDLParserSigned || _la == SysVerilogHDLParserUnsigned) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2961)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserLeft_bracket {
		{
			p.SetState(2960)
			p.Dimension_plus()
		}

	}

	return localctx
}

// ITypedef_typeContext is an interface to support dynamic dispatch.
type ITypedef_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedef_typeContext differentiates from other interfaces.
	IsTypedef_typeContext()
}

type Typedef_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedef_typeContext() *Typedef_typeContext {
	var p = new(Typedef_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_typedef_type
	return p
}

func (*Typedef_typeContext) IsTypedef_typeContext() {}

func NewTypedef_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Typedef_typeContext {
	var p = new(Typedef_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_typedef_type

	return p
}

func (s *Typedef_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Typedef_typeContext) Reg() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserReg, 0)
}

func (s *Typedef_typeContext) Logic() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserLogic, 0)
}

func (s *Typedef_typeContext) Bits_type() IBits_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBits_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBits_typeContext)
}

func (s *Typedef_typeContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Typedef_typeContext) User_type() IUser_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUser_typeContext)
}

func (s *Typedef_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Typedef_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Typedef_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTypedef_type(s)
	}
}

func (s *Typedef_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTypedef_type(s)
	}
}

func (p *SysVerilogHDLParser) Typedef_type() (localctx ITypedef_typeContext) {
	localctx = NewTypedef_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 820, SysVerilogHDLParserRULE_typedef_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2968)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserReg:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2963)
			p.Match(SysVerilogHDLParserReg)
		}

	case SysVerilogHDLParserLogic:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2964)
			p.Match(SysVerilogHDLParserLogic)
		}

	case SysVerilogHDLParserBit, SysVerilogHDLParserByte:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2965)
			p.Bits_type()
		}

	case SysVerilogHDLParserNONE, SysVerilogHDLParserSupply0, SysVerilogHDLParserSupply1, SysVerilogHDLParserTri, SysVerilogHDLParserTri_and, SysVerilogHDLParserTri_or, SysVerilogHDLParserTri_reg, SysVerilogHDLParserTri0, SysVerilogHDLParserTri1, SysVerilogHDLParserUwire, SysVerilogHDLParserWand, SysVerilogHDLParserWire, SysVerilogHDLParserWor:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2966)
			p.Net_type()
		}

	case SysVerilogHDLParserEscaped_identifier, SysVerilogHDLParserSimple_identifier:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2967)
			p.User_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPar_blockContext is an interface to support dynamic dispatch.
type IPar_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPar_blockContext differentiates from other interfaces.
	IsPar_blockContext()
}

type Par_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPar_blockContext() *Par_blockContext {
	var p = new(Par_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_par_block
	return p
}

func (*Par_blockContext) IsPar_blockContext() {}

func NewPar_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Par_blockContext {
	var p = new(Par_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_par_block

	return p
}

func (s *Par_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Par_blockContext) Fork() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserFork, 0)
}

func (s *Par_blockContext) Block_item_declaration_star() IBlock_item_declaration_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declaration_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declaration_starContext)
}

func (s *Par_blockContext) Statement_star() IStatement_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_starContext)
}

func (s *Par_blockContext) Join_keyword() IJoin_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoin_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoin_keywordContext)
}

func (s *Par_blockContext) Colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserColon, 0)
}

func (s *Par_blockContext) Block_identifier() IBlock_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_identifierContext)
}

func (s *Par_blockContext) Colon_block_identifier() IColon_block_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColon_block_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColon_block_identifierContext)
}

func (s *Par_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Par_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Par_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterPar_block(s)
	}
}

func (s *Par_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitPar_block(s)
	}
}

func (p *SysVerilogHDLParser) Par_block() (localctx IPar_blockContext) {
	localctx = NewPar_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 822, SysVerilogHDLParserRULE_par_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2970)
		p.Match(SysVerilogHDLParserFork)
	}
	p.SetState(2973)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserColon {
		{
			p.SetState(2971)
			p.Match(SysVerilogHDLParserColon)
		}
		{
			p.SetState(2972)
			p.Block_identifier()
		}

	}
	{
		p.SetState(2975)
		p.Block_item_declaration_star()
	}
	{
		p.SetState(2976)
		p.Statement_star()
	}
	{
		p.SetState(2977)
		p.Join_keyword()
	}
	p.SetState(2979)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserColon {
		{
			p.SetState(2978)
			p.Colon_block_identifier()
		}

	}

	return localctx
}

// ISeq_blockContext is an interface to support dynamic dispatch.
type ISeq_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeq_blockContext differentiates from other interfaces.
	IsSeq_blockContext()
}

type Seq_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeq_blockContext() *Seq_blockContext {
	var p = new(Seq_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_seq_block
	return p
}

func (*Seq_blockContext) IsSeq_blockContext() {}

func NewSeq_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Seq_blockContext {
	var p = new(Seq_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_seq_block

	return p
}

func (s *Seq_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Seq_blockContext) Begin() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserBegin, 0)
}

func (s *Seq_blockContext) Block_item_declaration_star() IBlock_item_declaration_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declaration_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declaration_starContext)
}

func (s *Seq_blockContext) Statement_star() IStatement_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_starContext)
}

func (s *Seq_blockContext) End() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEnd, 0)
}

func (s *Seq_blockContext) Colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserColon, 0)
}

func (s *Seq_blockContext) Block_identifier() IBlock_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_identifierContext)
}

func (s *Seq_blockContext) Colon_block_identifier() IColon_block_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColon_block_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColon_block_identifierContext)
}

func (s *Seq_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Seq_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Seq_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterSeq_block(s)
	}
}

func (s *Seq_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitSeq_block(s)
	}
}

func (p *SysVerilogHDLParser) Seq_block() (localctx ISeq_blockContext) {
	localctx = NewSeq_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 824, SysVerilogHDLParserRULE_seq_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2981)
		p.Match(SysVerilogHDLParserBegin)
	}
	p.SetState(2984)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserColon {
		{
			p.SetState(2982)
			p.Match(SysVerilogHDLParserColon)
		}
		{
			p.SetState(2983)
			p.Block_identifier()
		}

	}
	{
		p.SetState(2986)
		p.Block_item_declaration_star()
	}
	{
		p.SetState(2987)
		p.Statement_star()
	}
	{
		p.SetState(2988)
		p.Match(SysVerilogHDLParserEnd)
	}
	p.SetState(2990)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserColon {
		{
			p.SetState(2989)
			p.Colon_block_identifier()
		}

	}

	return localctx
}

// IBlock_identifierContext is an interface to support dynamic dispatch.
type IBlock_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_identifierContext differentiates from other interfaces.
	IsBlock_identifierContext()
}

type Block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_identifierContext() *Block_identifierContext {
	var p = new(Block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_block_identifier
	return p
}

func (*Block_identifierContext) IsBlock_identifierContext() {}

func NewBlock_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_identifierContext {
	var p = new(Block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_block_identifier

	return p
}

func (s *Block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterBlock_identifier(s)
	}
}

func (s *Block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitBlock_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Block_identifier() (localctx IBlock_identifierContext) {
	localctx = NewBlock_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 826, SysVerilogHDLParserRULE_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2992)
		p.Identifier()
	}

	return localctx
}

// IColon_block_identifierContext is an interface to support dynamic dispatch.
type IColon_block_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColon_block_identifierContext differentiates from other interfaces.
	IsColon_block_identifierContext()
}

type Colon_block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColon_block_identifierContext() *Colon_block_identifierContext {
	var p = new(Colon_block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_colon_block_identifier
	return p
}

func (*Colon_block_identifierContext) IsColon_block_identifierContext() {}

func NewColon_block_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Colon_block_identifierContext {
	var p = new(Colon_block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_colon_block_identifier

	return p
}

func (s *Colon_block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Colon_block_identifierContext) Colon() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserColon, 0)
}

func (s *Colon_block_identifierContext) Block_identifier() IBlock_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_identifierContext)
}

func (s *Colon_block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Colon_block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Colon_block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterColon_block_identifier(s)
	}
}

func (s *Colon_block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitColon_block_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Colon_block_identifier() (localctx IColon_block_identifierContext) {
	localctx = NewColon_block_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 828, SysVerilogHDLParserRULE_colon_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2994)
		p.Match(SysVerilogHDLParserColon)
	}
	{
		p.SetState(2995)
		p.Block_identifier()
	}

	return localctx
}

// IBlock_item_declaration_starContext is an interface to support dynamic dispatch.
type IBlock_item_declaration_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_item_declaration_starContext differentiates from other interfaces.
	IsBlock_item_declaration_starContext()
}

type Block_item_declaration_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_item_declaration_starContext() *Block_item_declaration_starContext {
	var p = new(Block_item_declaration_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_block_item_declaration_star
	return p
}

func (*Block_item_declaration_starContext) IsBlock_item_declaration_starContext() {}

func NewBlock_item_declaration_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_item_declaration_starContext {
	var p = new(Block_item_declaration_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_block_item_declaration_star

	return p
}

func (s *Block_item_declaration_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_item_declaration_starContext) AllBlock_item_declaration_semicolon() []IBlock_item_declaration_semicolonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declaration_semicolonContext)(nil)).Elem())
	var tst = make([]IBlock_item_declaration_semicolonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declaration_semicolonContext)
		}
	}

	return tst
}

func (s *Block_item_declaration_starContext) Block_item_declaration_semicolon(i int) IBlock_item_declaration_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declaration_semicolonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declaration_semicolonContext)
}

func (s *Block_item_declaration_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_item_declaration_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_item_declaration_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterBlock_item_declaration_star(s)
	}
}

func (s *Block_item_declaration_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitBlock_item_declaration_star(s)
	}
}

func (p *SysVerilogHDLParser) Block_item_declaration_star() (localctx IBlock_item_declaration_starContext) {
	localctx = NewBlock_item_declaration_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 830, SysVerilogHDLParserRULE_block_item_declaration_star)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3000)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 237, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2997)
				p.Block_item_declaration_semicolon()
			}

		}
		p.SetState(3002)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 237, p.GetParserRuleContext())
	}

	return localctx
}

// IBlock_item_declaration_semicolonContext is an interface to support dynamic dispatch.
type IBlock_item_declaration_semicolonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_item_declaration_semicolonContext differentiates from other interfaces.
	IsBlock_item_declaration_semicolonContext()
}

type Block_item_declaration_semicolonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_item_declaration_semicolonContext() *Block_item_declaration_semicolonContext {
	var p = new(Block_item_declaration_semicolonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_block_item_declaration_semicolon
	return p
}

func (*Block_item_declaration_semicolonContext) IsBlock_item_declaration_semicolonContext() {}

func NewBlock_item_declaration_semicolonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_item_declaration_semicolonContext {
	var p = new(Block_item_declaration_semicolonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_block_item_declaration_semicolon

	return p
}

func (s *Block_item_declaration_semicolonContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_item_declaration_semicolonContext) Block_item_declaration() IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Block_item_declaration_semicolonContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Block_item_declaration_semicolonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_item_declaration_semicolonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_item_declaration_semicolonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterBlock_item_declaration_semicolon(s)
	}
}

func (s *Block_item_declaration_semicolonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitBlock_item_declaration_semicolon(s)
	}
}

func (p *SysVerilogHDLParser) Block_item_declaration_semicolon() (localctx IBlock_item_declaration_semicolonContext) {
	localctx = NewBlock_item_declaration_semicolonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 832, SysVerilogHDLParserRULE_block_item_declaration_semicolon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3003)
		p.Block_item_declaration()
	}
	{
		p.SetState(3004)
		p.Semicolon()
	}

	return localctx
}

// IBlock_item_declarationContext is an interface to support dynamic dispatch.
type IBlock_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_item_declarationContext differentiates from other interfaces.
	IsBlock_item_declarationContext()
}

type Block_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_item_declarationContext() *Block_item_declarationContext {
	var p = new(Block_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_block_item_declaration
	return p
}

func (*Block_item_declarationContext) IsBlock_item_declarationContext() {}

func NewBlock_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_item_declarationContext {
	var p = new(Block_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_block_item_declaration

	return p
}

func (s *Block_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_item_declarationContext) Reg_declaration() IReg_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReg_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReg_declarationContext)
}

func (s *Block_item_declarationContext) Event_declaration() IEvent_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_declarationContext)
}

func (s *Block_item_declarationContext) Logic_declaration() ILogic_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogic_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogic_declarationContext)
}

func (s *Block_item_declarationContext) Bits_declaration() IBits_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBits_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBits_declarationContext)
}

func (s *Block_item_declarationContext) Integer_declaration() IInteger_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_declarationContext)
}

func (s *Block_item_declarationContext) Int_declaration() IInt_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_declarationContext)
}

func (s *Block_item_declarationContext) Local_parameter_declaration() ILocal_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocal_parameter_declarationContext)
}

func (s *Block_item_declarationContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Block_item_declarationContext) Real_declaration() IReal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_declarationContext)
}

func (s *Block_item_declarationContext) Realtime_declaration() IRealtime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRealtime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRealtime_declarationContext)
}

func (s *Block_item_declarationContext) Time_declaration() ITime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITime_declarationContext)
}

func (s *Block_item_declarationContext) String_declaration() IString_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_declarationContext)
}

func (s *Block_item_declarationContext) Usertype_variable_declaration() IUsertype_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUsertype_variable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUsertype_variable_declarationContext)
}

func (s *Block_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterBlock_item_declaration(s)
	}
}

func (s *Block_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitBlock_item_declaration(s)
	}
}

func (p *SysVerilogHDLParser) Block_item_declaration() (localctx IBlock_item_declarationContext) {
	localctx = NewBlock_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 834, SysVerilogHDLParserRULE_block_item_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3019)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 238, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3006)
			p.Reg_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3007)
			p.Event_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3008)
			p.Logic_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3009)
			p.Bits_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3010)
			p.Integer_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3011)
			p.Int_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3012)
			p.Local_parameter_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3013)
			p.Parameter_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3014)
			p.Real_declaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3015)
			p.Realtime_declaration()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3016)
			p.Time_declaration()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3017)
			p.String_declaration()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3018)
			p.Usertype_variable_declaration()
		}

	}

	return localctx
}

// IJoin_keywordContext is an interface to support dynamic dispatch.
type IJoin_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoin_keywordContext differentiates from other interfaces.
	IsJoin_keywordContext()
}

type Join_keywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_keywordContext() *Join_keywordContext {
	var p = new(Join_keywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_join_keyword
	return p
}

func (*Join_keywordContext) IsJoin_keywordContext() {}

func NewJoin_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_keywordContext {
	var p = new(Join_keywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_join_keyword

	return p
}

func (s *Join_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_keywordContext) Join() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserJoin, 0)
}

func (s *Join_keywordContext) Join_none() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserJoin_none, 0)
}

func (s *Join_keywordContext) Join_any() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserJoin_any, 0)
}

func (s *Join_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterJoin_keyword(s)
	}
}

func (s *Join_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitJoin_keyword(s)
	}
}

func (p *SysVerilogHDLParser) Join_keyword() (localctx IJoin_keywordContext) {
	localctx = NewJoin_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 836, SysVerilogHDLParserRULE_join_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3021)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-111)&-(0x1f+1)) == 0 && ((1<<uint((_la-111)))&((1<<(SysVerilogHDLParserJoin-111))|(1<<(SysVerilogHDLParserJoin_any-111))|(1<<(SysVerilogHDLParserJoin_none-111)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IContinuous_assignContext is an interface to support dynamic dispatch.
type IContinuous_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinuous_assignContext differentiates from other interfaces.
	IsContinuous_assignContext()
}

type Continuous_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinuous_assignContext() *Continuous_assignContext {
	var p = new(Continuous_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_continuous_assign
	return p
}

func (*Continuous_assignContext) IsContinuous_assignContext() {}

func NewContinuous_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Continuous_assignContext {
	var p = new(Continuous_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_continuous_assign

	return p
}

func (s *Continuous_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Continuous_assignContext) Assign() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserAssign, 0)
}

func (s *Continuous_assignContext) List_of_variable_assignments() IList_of_variable_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_assignmentsContext)
}

func (s *Continuous_assignContext) Semicolon() ISemicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemicolonContext)
}

func (s *Continuous_assignContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *Continuous_assignContext) Delay() IDelayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelayContext)
}

func (s *Continuous_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continuous_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Continuous_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterContinuous_assign(s)
	}
}

func (s *Continuous_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitContinuous_assign(s)
	}
}

func (p *SysVerilogHDLParser) Continuous_assign() (localctx IContinuous_assignContext) {
	localctx = NewContinuous_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 838, SysVerilogHDLParserRULE_continuous_assign)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3023)
		p.Match(SysVerilogHDLParserAssign)
	}
	p.SetState(3025)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserOpen_parenthesis {
		{
			p.SetState(3024)
			p.Drive_strength()
		}

	}
	p.SetState(3028)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SysVerilogHDLParserHash {
		{
			p.SetState(3027)
			p.Delay()
		}

	}
	{
		p.SetState(3030)
		p.List_of_variable_assignments()
	}
	{
		p.SetState(3031)
		p.Semicolon()
	}

	return localctx
}

// IList_of_variable_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_variable_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_variable_assignmentsContext differentiates from other interfaces.
	IsList_of_variable_assignmentsContext()
}

type List_of_variable_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_variable_assignmentsContext() *List_of_variable_assignmentsContext {
	var p = new(List_of_variable_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_variable_assignments
	return p
}

func (*List_of_variable_assignmentsContext) IsList_of_variable_assignmentsContext() {}

func NewList_of_variable_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_variable_assignmentsContext {
	var p = new(List_of_variable_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_list_of_variable_assignments

	return p
}

func (s *List_of_variable_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_variable_assignmentsContext) Variable_assignment() IVariable_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_assignmentContext)
}

func (s *List_of_variable_assignmentsContext) Comma_variable_assignment_star() IComma_variable_assignment_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_variable_assignment_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComma_variable_assignment_starContext)
}

func (s *List_of_variable_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_variable_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_variable_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterList_of_variable_assignments(s)
	}
}

func (s *List_of_variable_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitList_of_variable_assignments(s)
	}
}

func (p *SysVerilogHDLParser) List_of_variable_assignments() (localctx IList_of_variable_assignmentsContext) {
	localctx = NewList_of_variable_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 840, SysVerilogHDLParserRULE_list_of_variable_assignments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3033)
		p.Variable_assignment()
	}
	{
		p.SetState(3034)
		p.Comma_variable_assignment_star()
	}

	return localctx
}

// IComma_variable_assignment_starContext is an interface to support dynamic dispatch.
type IComma_variable_assignment_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_variable_assignment_starContext differentiates from other interfaces.
	IsComma_variable_assignment_starContext()
}

type Comma_variable_assignment_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_variable_assignment_starContext() *Comma_variable_assignment_starContext {
	var p = new(Comma_variable_assignment_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_variable_assignment_star
	return p
}

func (*Comma_variable_assignment_starContext) IsComma_variable_assignment_starContext() {}

func NewComma_variable_assignment_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_variable_assignment_starContext {
	var p = new(Comma_variable_assignment_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_variable_assignment_star

	return p
}

func (s *Comma_variable_assignment_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_variable_assignment_starContext) AllComma_variable_assignment() []IComma_variable_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComma_variable_assignmentContext)(nil)).Elem())
	var tst = make([]IComma_variable_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComma_variable_assignmentContext)
		}
	}

	return tst
}

func (s *Comma_variable_assignment_starContext) Comma_variable_assignment(i int) IComma_variable_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComma_variable_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComma_variable_assignmentContext)
}

func (s *Comma_variable_assignment_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_variable_assignment_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_variable_assignment_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_variable_assignment_star(s)
	}
}

func (s *Comma_variable_assignment_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_variable_assignment_star(s)
	}
}

func (p *SysVerilogHDLParser) Comma_variable_assignment_star() (localctx IComma_variable_assignment_starContext) {
	localctx = NewComma_variable_assignment_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 842, SysVerilogHDLParserRULE_comma_variable_assignment_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3039)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(3036)
			p.Comma_variable_assignment()
		}

		p.SetState(3041)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComma_variable_assignmentContext is an interface to support dynamic dispatch.
type IComma_variable_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComma_variable_assignmentContext differentiates from other interfaces.
	IsComma_variable_assignmentContext()
}

type Comma_variable_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComma_variable_assignmentContext() *Comma_variable_assignmentContext {
	var p = new(Comma_variable_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_comma_variable_assignment
	return p
}

func (*Comma_variable_assignmentContext) IsComma_variable_assignmentContext() {}

func NewComma_variable_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comma_variable_assignmentContext {
	var p = new(Comma_variable_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_comma_variable_assignment

	return p
}

func (s *Comma_variable_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Comma_variable_assignmentContext) Comma() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, 0)
}

func (s *Comma_variable_assignmentContext) Variable_assignment() IVariable_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_assignmentContext)
}

func (s *Comma_variable_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comma_variable_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comma_variable_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterComma_variable_assignment(s)
	}
}

func (s *Comma_variable_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitComma_variable_assignment(s)
	}
}

func (p *SysVerilogHDLParser) Comma_variable_assignment() (localctx IComma_variable_assignmentContext) {
	localctx = NewComma_variable_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 844, SysVerilogHDLParserRULE_comma_variable_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3042)
		p.Match(SysVerilogHDLParserComma)
	}
	{
		p.SetState(3043)
		p.Variable_assignment()
	}

	return localctx
}

// IVariable_assignmentContext is an interface to support dynamic dispatch.
type IVariable_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_assignmentContext differentiates from other interfaces.
	IsVariable_assignmentContext()
}

type Variable_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_assignmentContext() *Variable_assignmentContext {
	var p = new(Variable_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_variable_assignment
	return p
}

func (*Variable_assignmentContext) IsVariable_assignmentContext() {}

func NewVariable_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_assignmentContext {
	var p = new(Variable_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_variable_assignment

	return p
}

func (s *Variable_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Variable_assignmentContext) Equal() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEqual, 0)
}

func (s *Variable_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterVariable_assignment(s)
	}
}

func (s *Variable_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitVariable_assignment(s)
	}
}

func (p *SysVerilogHDLParser) Variable_assignment() (localctx IVariable_assignmentContext) {
	localctx = NewVariable_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 846, SysVerilogHDLParserRULE_variable_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3045)
		p.Variable_lvalue()
	}
	{
		p.SetState(3046)
		p.Match(SysVerilogHDLParserEqual)
	}
	{
		p.SetState(3047)
		p.Expression()
	}

	return localctx
}

// IInitial_constructContext is an interface to support dynamic dispatch.
type IInitial_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitial_constructContext differentiates from other interfaces.
	IsInitial_constructContext()
}

type Initial_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitial_constructContext() *Initial_constructContext {
	var p = new(Initial_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_initial_construct
	return p
}

func (*Initial_constructContext) IsInitial_constructContext() {}

func NewInitial_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Initial_constructContext {
	var p = new(Initial_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_initial_construct

	return p
}

func (s *Initial_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Initial_constructContext) Initial() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserInitial, 0)
}

func (s *Initial_constructContext) Statement_semicolon() IStatement_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_semicolonContext)
}

func (s *Initial_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Initial_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Initial_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterInitial_construct(s)
	}
}

func (s *Initial_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitInitial_construct(s)
	}
}

func (p *SysVerilogHDLParser) Initial_construct() (localctx IInitial_constructContext) {
	localctx = NewInitial_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 848, SysVerilogHDLParserRULE_initial_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3049)
		p.Match(SysVerilogHDLParserInitial)
	}
	{
		p.SetState(3050)
		p.Statement_semicolon()
	}

	return localctx
}

// IFinal_constructContext is an interface to support dynamic dispatch.
type IFinal_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinal_constructContext differentiates from other interfaces.
	IsFinal_constructContext()
}

type Final_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinal_constructContext() *Final_constructContext {
	var p = new(Final_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_final_construct
	return p
}

func (*Final_constructContext) IsFinal_constructContext() {}

func NewFinal_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Final_constructContext {
	var p = new(Final_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_final_construct

	return p
}

func (s *Final_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Final_constructContext) Final() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserFinal, 0)
}

func (s *Final_constructContext) Statement_semicolon() IStatement_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_semicolonContext)
}

func (s *Final_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Final_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Final_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterFinal_construct(s)
	}
}

func (s *Final_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitFinal_construct(s)
	}
}

func (p *SysVerilogHDLParser) Final_construct() (localctx IFinal_constructContext) {
	localctx = NewFinal_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 850, SysVerilogHDLParserRULE_final_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3052)
		p.Match(SysVerilogHDLParserFinal)
	}
	{
		p.SetState(3053)
		p.Statement_semicolon()
	}

	return localctx
}

// IAlways_keywordContext is an interface to support dynamic dispatch.
type IAlways_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlways_keywordContext differentiates from other interfaces.
	IsAlways_keywordContext()
}

type Always_keywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlways_keywordContext() *Always_keywordContext {
	var p = new(Always_keywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_always_keyword
	return p
}

func (*Always_keywordContext) IsAlways_keywordContext() {}

func NewAlways_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Always_keywordContext {
	var p = new(Always_keywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_always_keyword

	return p
}

func (s *Always_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Always_keywordContext) Always() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserAlways, 0)
}

func (s *Always_keywordContext) Always_comb() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserAlways_comb, 0)
}

func (s *Always_keywordContext) Always_ff() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserAlways_ff, 0)
}

func (s *Always_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Always_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Always_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAlways_keyword(s)
	}
}

func (s *Always_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAlways_keyword(s)
	}
}

func (p *SysVerilogHDLParser) Always_keyword() (localctx IAlways_keywordContext) {
	localctx = NewAlways_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 852, SysVerilogHDLParserRULE_always_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3055)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-49)&-(0x1f+1)) == 0 && ((1<<uint((_la-49)))&((1<<(SysVerilogHDLParserAlways-49))|(1<<(SysVerilogHDLParserAlways_comb-49))|(1<<(SysVerilogHDLParserAlways_ff-49)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAlways_constructContext is an interface to support dynamic dispatch.
type IAlways_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlways_constructContext differentiates from other interfaces.
	IsAlways_constructContext()
}

type Always_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlways_constructContext() *Always_constructContext {
	var p = new(Always_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_always_construct
	return p
}

func (*Always_constructContext) IsAlways_constructContext() {}

func NewAlways_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Always_constructContext {
	var p = new(Always_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_always_construct

	return p
}

func (s *Always_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Always_constructContext) Always_keyword() IAlways_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlways_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlways_keywordContext)
}

func (s *Always_constructContext) Statement_semicolon() IStatement_semicolonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_semicolonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_semicolonContext)
}

func (s *Always_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Always_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Always_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAlways_construct(s)
	}
}

func (s *Always_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAlways_construct(s)
	}
}

func (p *SysVerilogHDLParser) Always_construct() (localctx IAlways_constructContext) {
	localctx = NewAlways_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 854, SysVerilogHDLParserRULE_always_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3057)
		p.Always_keyword()
	}
	{
		p.SetState(3058)
		p.Statement_semicolon()
	}

	return localctx
}

// IAttribute_instance_starContext is an interface to support dynamic dispatch.
type IAttribute_instance_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_instance_starContext differentiates from other interfaces.
	IsAttribute_instance_starContext()
}

type Attribute_instance_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_instance_starContext() *Attribute_instance_starContext {
	var p = new(Attribute_instance_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attribute_instance_star
	return p
}

func (*Attribute_instance_starContext) IsAttribute_instance_starContext() {}

func NewAttribute_instance_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_instance_starContext {
	var p = new(Attribute_instance_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attribute_instance_star

	return p
}

func (s *Attribute_instance_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_instance_starContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Attribute_instance_starContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Attribute_instance_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_instance_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_instance_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttribute_instance_star(s)
	}
}

func (s *Attribute_instance_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttribute_instance_star(s)
	}
}

func (p *SysVerilogHDLParser) Attribute_instance_star() (localctx IAttribute_instance_starContext) {
	localctx = NewAttribute_instance_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 856, SysVerilogHDLParserRULE_attribute_instance_star)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3063)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3060)
				p.Attribute_instance()
			}

		}
		p.SetState(3065)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext())
	}

	return localctx
}

// IAttribute_instanceContext is an interface to support dynamic dispatch.
type IAttribute_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_instanceContext differentiates from other interfaces.
	IsAttribute_instanceContext()
}

type Attribute_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_instanceContext() *Attribute_instanceContext {
	var p = new(Attribute_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attribute_instance
	return p
}

func (*Attribute_instanceContext) IsAttribute_instanceContext() {}

func NewAttribute_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_instanceContext {
	var p = new(Attribute_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attribute_instance

	return p
}

func (s *Attribute_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_instanceContext) Open_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOpen_parenthesis, 0)
}

func (s *Attribute_instanceContext) AllStar() []antlr.TerminalNode {
	return s.GetTokens(SysVerilogHDLParserStar)
}

func (s *Attribute_instanceContext) Star(i int) antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserStar, i)
}

func (s *Attribute_instanceContext) Attr_spec() IAttr_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_specContext)
}

func (s *Attribute_instanceContext) Attr_spec_star() IAttr_spec_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_spec_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_spec_starContext)
}

func (s *Attribute_instanceContext) Close_parenthesis() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserClose_parenthesis, 0)
}

func (s *Attribute_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttribute_instance(s)
	}
}

func (s *Attribute_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttribute_instance(s)
	}
}

func (p *SysVerilogHDLParser) Attribute_instance() (localctx IAttribute_instanceContext) {
	localctx = NewAttribute_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 858, SysVerilogHDLParserRULE_attribute_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3066)
		p.Match(SysVerilogHDLParserOpen_parenthesis)
	}
	{
		p.SetState(3067)
		p.Match(SysVerilogHDLParserStar)
	}
	{
		p.SetState(3068)
		p.Attr_spec()
	}
	{
		p.SetState(3069)
		p.Attr_spec_star()
	}
	{
		p.SetState(3070)
		p.Match(SysVerilogHDLParserStar)
	}
	{
		p.SetState(3071)
		p.Match(SysVerilogHDLParserClose_parenthesis)
	}

	return localctx
}

// IAttr_spec_starContext is an interface to support dynamic dispatch.
type IAttr_spec_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_spec_starContext differentiates from other interfaces.
	IsAttr_spec_starContext()
}

type Attr_spec_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_spec_starContext() *Attr_spec_starContext {
	var p = new(Attr_spec_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attr_spec_star
	return p
}

func (*Attr_spec_starContext) IsAttr_spec_starContext() {}

func NewAttr_spec_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_spec_starContext {
	var p = new(Attr_spec_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attr_spec_star

	return p
}

func (s *Attr_spec_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_spec_starContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(SysVerilogHDLParserComma)
}

func (s *Attr_spec_starContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserComma, i)
}

func (s *Attr_spec_starContext) AllAttr_spec() []IAttr_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttr_specContext)(nil)).Elem())
	var tst = make([]IAttr_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttr_specContext)
		}
	}

	return tst
}

func (s *Attr_spec_starContext) Attr_spec(i int) IAttr_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttr_specContext)
}

func (s *Attr_spec_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_spec_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_spec_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttr_spec_star(s)
	}
}

func (s *Attr_spec_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttr_spec_star(s)
	}
}

func (p *SysVerilogHDLParser) Attr_spec_star() (localctx IAttr_spec_starContext) {
	localctx = NewAttr_spec_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 860, SysVerilogHDLParserRULE_attr_spec_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3077)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserComma {
		{
			p.SetState(3073)
			p.Match(SysVerilogHDLParserComma)
		}
		{
			p.SetState(3074)
			p.Attr_spec()
		}

		p.SetState(3079)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAttr_specContext is an interface to support dynamic dispatch.
type IAttr_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_specContext differentiates from other interfaces.
	IsAttr_specContext()
}

type Attr_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_specContext() *Attr_specContext {
	var p = new(Attr_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attr_spec
	return p
}

func (*Attr_specContext) IsAttr_specContext() {}

func NewAttr_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_specContext {
	var p = new(Attr_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attr_spec

	return p
}

func (s *Attr_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_specContext) Attr_name() IAttr_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_nameContext)
}

func (s *Attr_specContext) Equal() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEqual, 0)
}

func (s *Attr_specContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Attr_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttr_spec(s)
	}
}

func (s *Attr_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttr_spec(s)
	}
}

func (p *SysVerilogHDLParser) Attr_spec() (localctx IAttr_specContext) {
	localctx = NewAttr_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 862, SysVerilogHDLParserRULE_attr_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3085)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 244, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3080)
			p.Attr_name()
		}
		{
			p.SetState(3081)
			p.Match(SysVerilogHDLParserEqual)
		}
		{
			p.SetState(3082)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3084)
			p.Attr_name()
		}

	}

	return localctx
}

// IAttr_nameContext is an interface to support dynamic dispatch.
type IAttr_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_nameContext differentiates from other interfaces.
	IsAttr_nameContext()
}

type Attr_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_nameContext() *Attr_nameContext {
	var p = new(Attr_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_attr_name
	return p
}

func (*Attr_nameContext) IsAttr_nameContext() {}

func NewAttr_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_nameContext {
	var p = new(Attr_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_attr_name

	return p
}

func (s *Attr_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Attr_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterAttr_name(s)
	}
}

func (s *Attr_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitAttr_name(s)
	}
}

func (p *SysVerilogHDLParser) Attr_name() (localctx IAttr_nameContext) {
	localctx = NewAttr_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 864, SysVerilogHDLParserRULE_attr_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3087)
		p.Identifier()
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Simple_identifier() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserSimple_identifier, 0)
}

func (s *IdentifierContext) Escaped_identifier() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserEscaped_identifier, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *SysVerilogHDLParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 866, SysVerilogHDLParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3089)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SysVerilogHDLParserEscaped_identifier || _la == SysVerilogHDLParserSimple_identifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IHierarchical_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_identifierContext differentiates from other interfaces.
	IsHierarchical_identifierContext()
}

type Hierarchical_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_identifierContext() *Hierarchical_identifierContext {
	var p = new(Hierarchical_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_identifier
	return p
}

func (*Hierarchical_identifierContext) IsHierarchical_identifierContext() {}

func NewHierarchical_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_identifierContext {
	var p = new(Hierarchical_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_identifier

	return p
}

func (s *Hierarchical_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_identifierContext) Hierarchical_identifier_branch_item() IHierarchical_identifier_branch_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifier_branch_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifier_branch_itemContext)
}

func (s *Hierarchical_identifierContext) Dot_hierarchical_identifier_branch_item_star() IDot_hierarchical_identifier_branch_item_starContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDot_hierarchical_identifier_branch_item_starContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDot_hierarchical_identifier_branch_item_starContext)
}

func (s *Hierarchical_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterHierarchical_identifier(s)
	}
}

func (s *Hierarchical_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitHierarchical_identifier(s)
	}
}

func (p *SysVerilogHDLParser) Hierarchical_identifier() (localctx IHierarchical_identifierContext) {
	localctx = NewHierarchical_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 868, SysVerilogHDLParserRULE_hierarchical_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3091)
		p.Hierarchical_identifier_branch_item()
	}
	{
		p.SetState(3092)
		p.Dot_hierarchical_identifier_branch_item_star()
	}

	return localctx
}

// IDot_hierarchical_identifier_branch_item_starContext is an interface to support dynamic dispatch.
type IDot_hierarchical_identifier_branch_item_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDot_hierarchical_identifier_branch_item_starContext differentiates from other interfaces.
	IsDot_hierarchical_identifier_branch_item_starContext()
}

type Dot_hierarchical_identifier_branch_item_starContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDot_hierarchical_identifier_branch_item_starContext() *Dot_hierarchical_identifier_branch_item_starContext {
	var p = new(Dot_hierarchical_identifier_branch_item_starContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_dot_hierarchical_identifier_branch_item_star
	return p
}

func (*Dot_hierarchical_identifier_branch_item_starContext) IsDot_hierarchical_identifier_branch_item_starContext() {
}

func NewDot_hierarchical_identifier_branch_item_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dot_hierarchical_identifier_branch_item_starContext {
	var p = new(Dot_hierarchical_identifier_branch_item_starContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_dot_hierarchical_identifier_branch_item_star

	return p
}

func (s *Dot_hierarchical_identifier_branch_item_starContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *Dot_hierarchical_identifier_branch_item_starContext) AllDot_hierarchical_identifier_branch_item() []IDot_hierarchical_identifier_branch_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDot_hierarchical_identifier_branch_itemContext)(nil)).Elem())
	var tst = make([]IDot_hierarchical_identifier_branch_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDot_hierarchical_identifier_branch_itemContext)
		}
	}

	return tst
}

func (s *Dot_hierarchical_identifier_branch_item_starContext) Dot_hierarchical_identifier_branch_item(i int) IDot_hierarchical_identifier_branch_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDot_hierarchical_identifier_branch_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDot_hierarchical_identifier_branch_itemContext)
}

func (s *Dot_hierarchical_identifier_branch_item_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dot_hierarchical_identifier_branch_item_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dot_hierarchical_identifier_branch_item_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDot_hierarchical_identifier_branch_item_star(s)
	}
}

func (s *Dot_hierarchical_identifier_branch_item_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDot_hierarchical_identifier_branch_item_star(s)
	}
}

func (p *SysVerilogHDLParser) Dot_hierarchical_identifier_branch_item_star() (localctx IDot_hierarchical_identifier_branch_item_starContext) {
	localctx = NewDot_hierarchical_identifier_branch_item_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 870, SysVerilogHDLParserRULE_dot_hierarchical_identifier_branch_item_star)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3097)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SysVerilogHDLParserDot {
		{
			p.SetState(3094)
			p.Dot_hierarchical_identifier_branch_item()
		}

		p.SetState(3099)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDot_hierarchical_identifier_branch_itemContext is an interface to support dynamic dispatch.
type IDot_hierarchical_identifier_branch_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDot_hierarchical_identifier_branch_itemContext differentiates from other interfaces.
	IsDot_hierarchical_identifier_branch_itemContext()
}

type Dot_hierarchical_identifier_branch_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDot_hierarchical_identifier_branch_itemContext() *Dot_hierarchical_identifier_branch_itemContext {
	var p = new(Dot_hierarchical_identifier_branch_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_dot_hierarchical_identifier_branch_item
	return p
}

func (*Dot_hierarchical_identifier_branch_itemContext) IsDot_hierarchical_identifier_branch_itemContext() {
}

func NewDot_hierarchical_identifier_branch_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dot_hierarchical_identifier_branch_itemContext {
	var p = new(Dot_hierarchical_identifier_branch_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_dot_hierarchical_identifier_branch_item

	return p
}

func (s *Dot_hierarchical_identifier_branch_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Dot_hierarchical_identifier_branch_itemContext) Dot() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDot, 0)
}

func (s *Dot_hierarchical_identifier_branch_itemContext) Hierarchical_identifier_branch_item() IHierarchical_identifier_branch_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifier_branch_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifier_branch_itemContext)
}

func (s *Dot_hierarchical_identifier_branch_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dot_hierarchical_identifier_branch_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dot_hierarchical_identifier_branch_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDot_hierarchical_identifier_branch_item(s)
	}
}

func (s *Dot_hierarchical_identifier_branch_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDot_hierarchical_identifier_branch_item(s)
	}
}

func (p *SysVerilogHDLParser) Dot_hierarchical_identifier_branch_item() (localctx IDot_hierarchical_identifier_branch_itemContext) {
	localctx = NewDot_hierarchical_identifier_branch_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 872, SysVerilogHDLParserRULE_dot_hierarchical_identifier_branch_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3100)
		p.Match(SysVerilogHDLParserDot)
	}
	{
		p.SetState(3101)
		p.Hierarchical_identifier_branch_item()
	}

	return localctx
}

// IHierarchical_identifier_branch_itemContext is an interface to support dynamic dispatch.
type IHierarchical_identifier_branch_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_identifier_branch_itemContext differentiates from other interfaces.
	IsHierarchical_identifier_branch_itemContext()
}

type Hierarchical_identifier_branch_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_identifier_branch_itemContext() *Hierarchical_identifier_branch_itemContext {
	var p = new(Hierarchical_identifier_branch_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_identifier_branch_item
	return p
}

func (*Hierarchical_identifier_branch_itemContext) IsHierarchical_identifier_branch_itemContext() {}

func NewHierarchical_identifier_branch_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_identifier_branch_itemContext {
	var p = new(Hierarchical_identifier_branch_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_hierarchical_identifier_branch_item

	return p
}

func (s *Hierarchical_identifier_branch_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_identifier_branch_itemContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Hierarchical_identifier_branch_itemContext) Dimension_plus() IDimension_plusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimension_plusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimension_plusContext)
}

func (s *Hierarchical_identifier_branch_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_identifier_branch_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_identifier_branch_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterHierarchical_identifier_branch_item(s)
	}
}

func (s *Hierarchical_identifier_branch_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitHierarchical_identifier_branch_item(s)
	}
}

func (p *SysVerilogHDLParser) Hierarchical_identifier_branch_item() (localctx IHierarchical_identifier_branch_itemContext) {
	localctx = NewHierarchical_identifier_branch_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 874, SysVerilogHDLParserRULE_hierarchical_identifier_branch_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3103)
		p.Identifier()
	}
	p.SetState(3105)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 246, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3104)
			p.Dimension_plus()
		}

	}

	return localctx
}

// ITimescale_compiler_directiveContext is an interface to support dynamic dispatch.
type ITimescale_compiler_directiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimescale_compiler_directiveContext differentiates from other interfaces.
	IsTimescale_compiler_directiveContext()
}

type Timescale_compiler_directiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimescale_compiler_directiveContext() *Timescale_compiler_directiveContext {
	var p = new(Timescale_compiler_directiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_timescale_compiler_directive
	return p
}

func (*Timescale_compiler_directiveContext) IsTimescale_compiler_directiveContext() {}

func NewTimescale_compiler_directiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timescale_compiler_directiveContext {
	var p = new(Timescale_compiler_directiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_timescale_compiler_directive

	return p
}

func (s *Timescale_compiler_directiveContext) GetParser() antlr.Parser { return s.parser }

func (s *Timescale_compiler_directiveContext) Tick_timescale() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTick_timescale, 0)
}

func (s *Timescale_compiler_directiveContext) AllTime_literal() []antlr.TerminalNode {
	return s.GetTokens(SysVerilogHDLParserTime_literal)
}

func (s *Timescale_compiler_directiveContext) Time_literal(i int) antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTime_literal, i)
}

func (s *Timescale_compiler_directiveContext) Forward_slash() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserForward_slash, 0)
}

func (s *Timescale_compiler_directiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timescale_compiler_directiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timescale_compiler_directiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTimescale_compiler_directive(s)
	}
}

func (s *Timescale_compiler_directiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTimescale_compiler_directive(s)
	}
}

func (p *SysVerilogHDLParser) Timescale_compiler_directive() (localctx ITimescale_compiler_directiveContext) {
	localctx = NewTimescale_compiler_directiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 876, SysVerilogHDLParserRULE_timescale_compiler_directive)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3107)
		p.Match(SysVerilogHDLParserTick_timescale)
	}
	{
		p.SetState(3108)
		p.Match(SysVerilogHDLParserTime_literal)
	}
	{
		p.SetState(3109)
		p.Match(SysVerilogHDLParserForward_slash)
	}
	{
		p.SetState(3110)
		p.Match(SysVerilogHDLParserTime_literal)
	}

	return localctx
}

// ITimeunit_directiveContext is an interface to support dynamic dispatch.
type ITimeunit_directiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimeunit_directiveContext differentiates from other interfaces.
	IsTimeunit_directiveContext()
}

type Timeunit_directiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeunit_directiveContext() *Timeunit_directiveContext {
	var p = new(Timeunit_directiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_timeunit_directive
	return p
}

func (*Timeunit_directiveContext) IsTimeunit_directiveContext() {}

func NewTimeunit_directiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timeunit_directiveContext {
	var p = new(Timeunit_directiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_timeunit_directive

	return p
}

func (s *Timeunit_directiveContext) GetParser() antlr.Parser { return s.parser }

func (s *Timeunit_directiveContext) Timeunit() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTimeunit, 0)
}

func (s *Timeunit_directiveContext) Time_literal() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTime_literal, 0)
}

func (s *Timeunit_directiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timeunit_directiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timeunit_directiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTimeunit_directive(s)
	}
}

func (s *Timeunit_directiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTimeunit_directive(s)
	}
}

func (p *SysVerilogHDLParser) Timeunit_directive() (localctx ITimeunit_directiveContext) {
	localctx = NewTimeunit_directiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 878, SysVerilogHDLParserRULE_timeunit_directive)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3112)
		p.Match(SysVerilogHDLParserTimeunit)
	}
	{
		p.SetState(3113)
		p.Match(SysVerilogHDLParserTime_literal)
	}

	return localctx
}

// ITimeprecision_directiveContext is an interface to support dynamic dispatch.
type ITimeprecision_directiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimeprecision_directiveContext differentiates from other interfaces.
	IsTimeprecision_directiveContext()
}

type Timeprecision_directiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeprecision_directiveContext() *Timeprecision_directiveContext {
	var p = new(Timeprecision_directiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_timeprecision_directive
	return p
}

func (*Timeprecision_directiveContext) IsTimeprecision_directiveContext() {}

func NewTimeprecision_directiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timeprecision_directiveContext {
	var p = new(Timeprecision_directiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_timeprecision_directive

	return p
}

func (s *Timeprecision_directiveContext) GetParser() antlr.Parser { return s.parser }

func (s *Timeprecision_directiveContext) Timeprecision() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTimeprecision, 0)
}

func (s *Timeprecision_directiveContext) Time_literal() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserTime_literal, 0)
}

func (s *Timeprecision_directiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timeprecision_directiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timeprecision_directiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterTimeprecision_directive(s)
	}
}

func (s *Timeprecision_directiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitTimeprecision_directive(s)
	}
}

func (p *SysVerilogHDLParser) Timeprecision_directive() (localctx ITimeprecision_directiveContext) {
	localctx = NewTimeprecision_directiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 880, SysVerilogHDLParserRULE_timeprecision_directive)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3115)
		p.Match(SysVerilogHDLParserTimeprecision)
	}
	{
		p.SetState(3116)
		p.Match(SysVerilogHDLParserTime_literal)
	}

	return localctx
}

// IDefault_nettype_statementContext is an interface to support dynamic dispatch.
type IDefault_nettype_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefault_nettype_statementContext differentiates from other interfaces.
	IsDefault_nettype_statementContext()
}

type Default_nettype_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefault_nettype_statementContext() *Default_nettype_statementContext {
	var p = new(Default_nettype_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_default_nettype_statement
	return p
}

func (*Default_nettype_statementContext) IsDefault_nettype_statementContext() {}

func NewDefault_nettype_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Default_nettype_statementContext {
	var p = new(Default_nettype_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_default_nettype_statement

	return p
}

func (s *Default_nettype_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Default_nettype_statementContext) Default_nettype() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDefault_nettype, 0)
}

func (s *Default_nettype_statementContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Default_nettype_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Default_nettype_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Default_nettype_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterDefault_nettype_statement(s)
	}
}

func (s *Default_nettype_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitDefault_nettype_statement(s)
	}
}

func (p *SysVerilogHDLParser) Default_nettype_statement() (localctx IDefault_nettype_statementContext) {
	localctx = NewDefault_nettype_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 882, SysVerilogHDLParserRULE_default_nettype_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3118)
		p.Match(SysVerilogHDLParserDefault_nettype)
	}
	{
		p.SetState(3119)
		p.Net_type()
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) Integral_number() IIntegral_numberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegral_numberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegral_numberContext)
}

func (s *NumberContext) Real_number() IReal_numberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_numberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_numberContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitNumber(s)
	}
}

func (p *SysVerilogHDLParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 884, SysVerilogHDLParserRULE_number)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3123)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SysVerilogHDLParserBinary_number, SysVerilogHDLParserDecimal_number, SysVerilogHDLParserHex_number, SysVerilogHDLParserOctal_number:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3121)
			p.Integral_number()
		}

	case SysVerilogHDLParserFixed_point_number, SysVerilogHDLParserReal_exp_form:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3122)
			p.Real_number()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIntegral_numberContext is an interface to support dynamic dispatch.
type IIntegral_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegral_numberContext differentiates from other interfaces.
	IsIntegral_numberContext()
}

type Integral_numberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegral_numberContext() *Integral_numberContext {
	var p = new(Integral_numberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_integral_number
	return p
}

func (*Integral_numberContext) IsIntegral_numberContext() {}

func NewIntegral_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integral_numberContext {
	var p = new(Integral_numberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_integral_number

	return p
}

func (s *Integral_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Integral_numberContext) Decimal_number() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserDecimal_number, 0)
}

func (s *Integral_numberContext) Octal_number() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserOctal_number, 0)
}

func (s *Integral_numberContext) Binary_number() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserBinary_number, 0)
}

func (s *Integral_numberContext) Hex_number() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserHex_number, 0)
}

func (s *Integral_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integral_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integral_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterIntegral_number(s)
	}
}

func (s *Integral_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitIntegral_number(s)
	}
}

func (p *SysVerilogHDLParser) Integral_number() (localctx IIntegral_numberContext) {
	localctx = NewIntegral_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 886, SysVerilogHDLParserRULE_integral_number)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3125)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(SysVerilogHDLParserBinary_number-42))|(1<<(SysVerilogHDLParserDecimal_number-42))|(1<<(SysVerilogHDLParserHex_number-42))|(1<<(SysVerilogHDLParserOctal_number-42)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IReal_numberContext is an interface to support dynamic dispatch.
type IReal_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReal_numberContext differentiates from other interfaces.
	IsReal_numberContext()
}

type Real_numberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_numberContext() *Real_numberContext {
	var p = new(Real_numberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SysVerilogHDLParserRULE_real_number
	return p
}

func (*Real_numberContext) IsReal_numberContext() {}

func NewReal_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_numberContext {
	var p = new(Real_numberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SysVerilogHDLParserRULE_real_number

	return p
}

func (s *Real_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_numberContext) Fixed_point_number() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserFixed_point_number, 0)
}

func (s *Real_numberContext) Real_exp_form() antlr.TerminalNode {
	return s.GetToken(SysVerilogHDLParserReal_exp_form, 0)
}

func (s *Real_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.EnterReal_number(s)
	}
}

func (s *Real_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SysVerilogHDLListener); ok {
		listenerT.ExitReal_number(s)
	}
}

func (p *SysVerilogHDLParser) Real_number() (localctx IReal_numberContext) {
	localctx = NewReal_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 888, SysVerilogHDLParserRULE_real_number)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3127)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SysVerilogHDLParserFixed_point_number || _la == SysVerilogHDLParserReal_exp_form) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}
